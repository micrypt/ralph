(define-module tests
  import: (core test))

;; TODO: test get

(print (not (block () #f)))
(print (not (block (return)
	      (return #f))))


(print (handler-case
	(not (block (return)
	       (js:throw (js:new (js:identifier "Error") "!"))
	       (return #t)))
	(((js:identifier "Error") condition: condition)
	 #t)))

(print (not ((complement (method (a b)
			   (and a b)))
	     #t #t)))

(print (binary< 0 1))
(print ((complement binary<) 1 0))

(print (> 1 0))
(print (not (> 1 1)))
(print (not (> 2 3 4)))
(print (> 4 3 2))
(print (<= 1 1))
(print (<= 1 2))
(print (not (<= 2 1)))


(print "test %parallel-set:")
(bind ((i 0)
       (v 0))
  (%parallel-set
   i 1
   v (inc i))
  (print (== i 1))
  (print (== v 1)))

(print "test for")
(print (== 11
	   (for ((i 0 (inc i)))
		((> i 10) i))))
(print (== 3628800
	   (for ((i 10 (dec i))
		 (v 1 (* v i)))
		((<= i 0) v))))


(print "test true?")
(print (not (true? js:null)))
(print (not (true? js:undefined)))

(print "test or")
(print (js:=== "" (or "" 1)))
(print (js:=== "0" (or "0" 1)))
(print (js:=== 0 (or 0 1)))
(print (js:=== "" (or "" #f)))
(print (js:=== "0" (or "0" #f)))
(print (js:=== 0 (or 0 #f)))

(print "test and")
(print (not (and #f 1)))
(print (js:=== 1 (and "" 1)))
(print (js:=== 1 (and "0" 1)))
(print (js:=== "" (and #t "")))
(print (js:=== "0" (and #t "0")))
(print (js:=== 0 (and #t 0)))
(print (not (and #t #f)))
(print (and #t #t))
(print (js:=== 23
	       (when (and "" "0" 0)
		 23)))

(print "test #rest arguments")
(print (js:=== 1 (+ 1)))
(print (js:=== 3 (+ 1 2)))
(print (js:=== 10 (+ 1 2 3 4)))

(print "test apply")
(print (js:=== 10 (apply + 1 2 (make-array 3 4))))

(print "test element")
(print (js:=== 1 (element (make-array 1 2 3) 0)))
(print (js:=== 2 (element (make-array 1 2 3) 1)))
(print (js:=== 3 (element (make-array 1 2 3) 2)))

(print "test but-last")
(print (== (last (but-last (make-array 1 2 3 4) n: 2)) 2))

(print "test block (non-local exit)")
(print (js:=== 2
	       (block (foo)
	         1
		 (foo 2)
		 3)))

(print "test ==")
(print (== #f #f))
(print (== 0 0))
(print (not (== "0" 0)))
(print (not (== "1" 1)))
(print (not (== "" #f)))

(print "test =")
(print (not (= #f "")))
(print (not (= #f "0")))
(print (not (= #f 0)))
(print (not (= #t "")))
(print (not (= #t "0")))
(print (not (= #t 0)))
(print (not (= #t "1")))
(print (not (= 1 "1")))
(print (not (= 0 "0")))
(print (= 1 1))
(print (= (js:new (js:identifier "Number") 1) 1))

(print "test instance?")
(print (instance? "test" (js:identifier "String")))
(print (instance? 1 (js:identifier "Number")))
(print (instance? "test" <string>))
(print (instance? 1 <number>))

(print "test definition of setter before getter")

(define-function (setter foo) (object new-value)
  (set! (js:get-property object "foo") new-value))

(define-function foo (object)
  (js:get-property object "foo"))

(bind ((bar (make-object)))
  (set! (foo bar) 1)
  (print (== 1 (foo bar))))

(print "test any? and rcurry")
(print (any? (rcurry > 2)
	     (make-array 1 2 3 4)))

(print "test bind")
(print (== 2 (bind ((x 0)
		    (y (+ x 1)))
		   (bind ((y (+ y 1)))
			 y))))

(print "test complement")
(print (not ((complement (method (x y)
			   (and x y)))
	      #t #t)))

(print "test scope")
(bind ((elements (make-array 0 1 2 3 4 5 6 7 8 9))
       (fns (make-array)))
  (for ((i 0 (+ i 1)))
       ((>= i (size elements)))
    (bind ((el (element elements i)))
      (push-last fns (method ()
			el))))
  (print (== 2 ((element fns 2)))))

(print "test rcurry")
(print (== 1 ((rcurry element 1)
	      (make-array 0 1 2))))

(print "test dotimes")
(print (true?
	(dotimes (i 10 #t)
	  (print i))))

(print "test find-key")
;; from start
(print (= 3 (find-key (make-array 0 0 0 1 0 0 1 0 0)
		      (rcurry > 0))))
(print (= 6 (find-key (make-array 0 0 0 1 0 0 1 0 0)
		      (rcurry > 0)
		      skip: 1)))
(print (= #f (find-key (make-array 0 0 0 1 0 0 1 0 0)
		       (rcurry > 0)
		       skip: 2)))
;; from end
(print (= 6 (find-key (make-array 0 0 0 1 0 0 1 0 0)
		      (rcurry > 0)
		      from-end: #t)))
(print (= 3 (find-key (make-array 0 0 0 1 0 0 1 0 0)
		      (rcurry > 0)
		      from-end: #t
		      skip: 1)))
(print (= #f (find-key (make-array 0 0 0 1 0 0 1 0 0)
		       (rcurry > 0)
		       from-end: #t
		       skip: 2)))

(print "test <")
(print (true? (< 1 2 3 4)))
(print (not (true? (< 2 1 3 4))))
(print (not (true? (< 3 2 1 4))))
(print (not (true? (< 4 3 2 1))))

(print "test truth values")
(print (not (= 0 #f)))
(print (true? 0))
(print (= 1 1 1))
(print (not (= 1 2 1)))
(print (not (= #f #f 0)))

(print "test reduce")
(print (== (reduce1 + (make-array 1 2 3 4 5)) 15))
(print (== (reduce + 1 (make-array 2 3 4 5)) 15))

(print "test apply")
(print (== (apply + 1 (make-array 2 3 4 5)) 15))
(print (== (apply + 1 2 3 (make-array 4 5)) 15))

;; (define-function test-format-to-string ()
;;   (check-equal "" (format-to-string "%d%%%d" 1 2) "1%2")
;;   (check-equal "" (format-to-string "x%mx"
;; 				    (method (stream)
;; 				      (write stream "%test%")))
;; 	       "x%test%x"))
;;
;; test every?
;; (bind ((table (make <table>))
;;        (list (make <list> size: 2)))
;;   (set! (element table "0") #t)
;;   (set! (element table "1") #t)
;;   (check-true (format-to-string "every? true? on table %="
;; 				table)
;; 	      (every? true? table))
;;   (set! (element table "0") #f)
;;     (set! (element table "1") #f)
;;     (check-true (format-to-string "every? false? on table %="
;; 				  table)
;; 		(every? false? table))
;;     (set! (element table "0") #t)
;;     (check-false (format-to-string "every? false? on table %="
;; 				   table)
;; 		 (every? false? table))
;;     (set! (element list 0) #t)
;;     (set! (element list 1) #t)
;;     (check-true (format-to-string "every? true? on list %="
;; 				  list)
;; 		(every? true? list))
;;     (set! (element list 0) #f)
;;     (set! (element list 1) #f)
;;     (check-true (format-to-string "every? false? on list %="
;; 				  list)
;; 		(every? false? list))
;;     (set! (element list 0) #t)
;;     (check-false (format-to-string "every? false? on list %="
;; 				   list)
;; 		 (every? false? list)))
;;
;; test any?
;; (bind ((table (make <table>))
;;        (list (make <list> size: 2)))
;;   (set! (element table "0") #t)
;;   (set! (element table "1") #t)
;;   (check-true (format-to-string "any? true? on table %="
;; 				table)
;; 	      (any? true? table))
;;   (set! (element table "0") #f)
;;   (set! (element table "1") #f)
;;   (check-true (format-to-string "any? false? on table %="
;; 				table)
;; 	      (any? false? table))
;;   (set! (element table "0") #t)
;;     (check-true (format-to-string "any? true? on table %="
;; 				  table)
;; 		(any? true? table))
;;     (check-true (format-to-string "any? false? on table %="
;; 				  table)
;; 		(any? false? table))
;;     (set! (element list 0) #t)
;;     (set! (element list 1) #t)
;;     (check-true (format-to-string "any? true? on list %="
;; 				  list)
;; 		(any? true? list))
;;     (set! (element list 0) #f)
;;     (set! (element list 1) #f)
;;     (check-true (format-to-string "any? false? on list %="
;; 				  list)
;; 		(any? false? list))
;;     (set! (element list 0) #t)
;;     (check-true (format-to-string "any? true? on list %="
;; 				  list)
;; 		(any? true? list))
;;     (check-true (format-to-string "any? false? on list %="
;; 				  list)
;; 		(any? false? list)))

;; test block
(bind-methods ((block1 ()
		 (block ()
		   (bind ((a 1))
		     a
		     2)))
	       (block2 ()
	         (block (success)
		   (bind ((a 1))
		     (success a)
	             2))))
  (print "test block without exit-variable")
  (print (== (block1) 2))
  (print "test block with exit variable")
  (print (== (block2) 1)))

(print "test get")
(bind ((x (make-object)))
  (set! (get x "1" "2" "3") 4)
  (print (== (get x "1" "2" "3") 4)))
