(define-module compiler
    import: (core reader))

(define S symbol)

(define *macros*
    (make-object
     "%function"
     (method (name arguments body)
       (make-array (S "js:function") name args
		   (macroexpand body)))
     "define"
     (method (name value)
       (make-array (S "%define")
     		   (make-array (S "js:escape") name)
     		   (macroexpand value)))
     "if"
     (method (test then else)
       (make-array (S "js:if")
		   (make-array (S "true?") test)
		   then
		   else))
     "when"
     (method (test #rest body)
       (make-array (S "if")
		   test
		   (concatenate (make-array (S "begin"))
				body)
		   #f))
     "unless"
     (method (test #rest body)
       (make-array (S "if")
		   (make-array (S "not") test)
		   (concatenate (make-array (S "begin"))
				body)
		   #f))))

(define *symbol-macros* (make-object))

;; (set! (get *macros* "define-macro")
;;       (method (name arguments #rest body)
;;         (set! (get *macros* name)
;; 	      (method

(define *special-forms*
    (make-object
     "js:array" 0
     "js:defined" 0
     "js:negative" 0
     "js:not" 0
     "begin" 0
     "js:if" 0
     "js:throw" 0
     "js:return" 0
     "js:while" 0
     "js:new" 1
     "js:var" 1
     "js:set" 1
     "js:for-in" 1
     "js:function" 2
     "js:var" #f
     "js:escape" #f
     "js:identifier" #f
     "js:get-property" #f
     "js:for"
     (method (clauses #rest body)
       (concatenate
	(make-array (S "js:for")
		    (map (method (clause)
			   (destructuring-bind ((var value) #rest rest) clause
			     (concatenate (make-array var (macroexpand value))
			 		  (map macroexpand rest))))
			 clauses))
	(macroexpand body)))
     "js:try"
     (method (body var catch finally)
       (make-array (S "js:try")
		   (macroexpand body)
		   var
		   (macroexpand catch)
		   (macroexpand finally)))))

(define *infix*
    (make-object
     "js:and" "&&"
     "js:or" "||"
     "js:+" "+"
     "js:-" "-"
     "js:*" "*"
     "js:/" "/"
     "js:>" ">"
     "js:<" "<"
     "js:>=" ">="
     "js:<=" "<="
     "js:==" "=="
     "js:===" "==="
     "js:instanceof" "instanceof"))

(define *symbols*
    (make-object
     "js:null" "null"
     "js:this" "this"
     "js:undefined" "undefined"
     "js:arguments" "arguments"))

(define *symbol-escapes*
    (make-object
     "-" "_M_"
     "+" "_PL_"
     "!" "_B_"
     "?" "_W_"
     "%" "_PE_"
     "#" "_H_"
     "@" "_A_"
     "*" "_ST_"
     "/" "_SL_"
     "=" "_E_"
     ":" "_C_"
     "<" "_LT_"
     ">" "_GT_"
     "_" "__"
     "[" "_SO_"
     "]" "_SC_"
     "{" "_BO_"
     "}" "_BC_"))

(define *reserved*
    (make-array
     "break" "case" "catch" "continue" "default" "delete" "do" "else"
     "finally" "for" "function" "if" "in" "instanceof" "new" "return"
     "switch" "this" "throw" "try" "typeof" "var" "void" "while"
     "with" "abstract" "boolean" "byte" "char" "class" "const"
     "debugger" "double" "enum" "export" "extends" "final" "float"
     "goto" "implements" "import" "int" "interface" "long" "native"
     "package" "private" "protected" "public" "short" "static" "super"
     "synchronized" "throws" "transient" "volatile" "null" "true" "false"
     "arguments" "object" "number" "string" "array"))

(define *symbol-count* 0)

(define-function generate-symbol ()
  (bind ((symbol (make <symbol> name: (concatenate "_" (as-string *symbol-count*)))))
    (inc! *symbol-count*)
    (set! (get symbol "generated") #t)
    symbol))

(define *hyphen-pattern*
    (make <regexp>
	  pattern: "-(.)"
	  global?: #t))

(define-function escape (name)
  (join (map (method (char)
	       (if-bind (replacement (get *symbol-escapes* char))
	         replacement
		 char))
	     (as-array
	      (replace-all *hyphen-pattern* name
			   (method (match)
			     (as-uppercase (second match)))))) ""))

(define-function escape-symbol (symbol)
  (bind ((name (symbol-name symbol)))
    (cond
      ((get symbol "generated")
       name)
      ((member? name *reserved*)
       (concatenate "_" name))
      ((and (= (first name) "<")
	    (= (last name) ">")
	    (> (size name) 2))
       (concatenate "_CL_"
		    (escape (but-last (rest name)))))
      ((and (= (first name) "*")
	    (= (last name) "*")
	    (> (size name) 2))
       (as-uppercase
	(escape (but-last (rest name)))))
      (else:
       (escape name)))))

(define-function wrap-block (code)
  (format-to-string "(function(){\n%s\n})()"
		    code))

(define-function write-body (body)
  (write-statements
   (concatenate
    (make-array (S "begin"))
    body)))

(define *property-pattern*
    (make <regexp>
	  pattern: "^[a-z_]+[a-z0-9]*$"
	  ignore-case?: #t))

(define *writers*
    (make-object
     "js:negative"
     (method (_ object)
       (format-to-string "(- %s)" (write object)))
     "js:not"
     (method (_ expression)
       (concatenate "!" (write expression)))
     "begin"
     (method (statements? #rest forms)
       (cond
	 (statements?
	  (join (map write-statements
		     forms)
		";\n"))
	 ((> (size forms) 1)
	  (concatenate
	   "(" (join (map write forms) ", ") ")"))
	 (else:
	  (write (first forms)))))
     "js:if"
     (method (statements? test then else)
       (if statements?
	   (format-to-string
	    "if (%s) {\n%s\n}%s"
	    (write test)
	    (write-statements then)
	    (if else
		(format-to-string
		 " else {%s\n}"
		 (write-statements else))
		""))
	   (apply format-to-string
		  "(%s ? %s : %s)"
		  (map write
		       (make-array test then else)))))
     "js:array"
     (method (_ #rest elements)
       (format-to-string "[%s]" (join (map write elements) ", ")))
     "js:defined"
     (method (_ expression)
       (format-to-string "(typeof (%s) != 'undefined')"
			 (write expression)))
     "js:try"
     (method (statements? body condition catch finally)
       (bind ((result
	       (format-to-string
		"try {\n%s\n}%s%s"
		(write-statements body)
		(if catch
		    (format-to-string
		     " catch (%s) {\n%s\n}"
		     (write condition)
		     (write-statements catch))
		    "")
		(if finally
		    (format-to-string
		     " finally {\n%s\n}"
		     (write-statements finally))
		    ""))))
         (if statements?
	     result
	     (wrap-block result))))
     "js:for-in"
     (method (statements? variable/expression #rest body)
	(destructuring-bind (variable expression) variable/expression
	  (bind ((result
		  (format-to-string "for (var %s in %s) {\n%s\n}"
				    variable
				    (write expression)
				    (write-body body))))
	    (if statements?
		result
		(wrap-block result)))))
     "js:for"
     (method (statements? clauses #rest body) {
       (bind ((inits (make-array))
	      (tests (make-array))
	      (nexts (make-array)))
         (do (method (clause)
	       (destructuring-bind ((var value) test next) clause
		 (bind ((set (S "js:set")))
		   (push-last
		    inits (write (make-array set var value)))
		   (push-last
		    tests (write test))
		   (push-last
		    nexts (write (make-array set var next))))))
	     clauses)
	 (bind ((result
		 (format-to-string
		  "for (var %s) {\n%s\n}"
		  (join (map (method (parts)
			       (join parts ", "))
			     (make-array inits tests nexts))
			"; ")
		  (write-body body))))
	 (if statements?
	     result
	     (wrap-block result)))))
     "js:while"
     (method (statements? test #rest body)
       (bind ((result
	       (format-to-string
		"while (%s) {\n%s\n}"
		(write test)
		(write-body body))))
         (if statements?
	     result
	     (wrap-block result))))
     "js:identifier"
     (method (_ identifier)
       (as-string identifier))
     "js:get-property"
     (method (_ object #rest elements)
       (concatenate
	(if (instance? object <string>)
	    string
	    (write string))
	(apply concatenate
	       (method (element)
	         (if (and (instance? element <string>)
			  (match *property-pattern* element))
		     (concatenate "." element)
		     (concatenate "[" (write element) "]")))
	       elements)))
     "js:new"
     (method (_ name #rest arguments)
       (format-to-string "new %s (%s)"
			 (write name)
			 (join (map write arguments) ", ")))
     "js:var"
     (method (_ name value)
       (concatenate
	"var " name
	(if (and value
		 (not (= value (S "js:undefined"))))
	    (concatenate " = " value)
	    "")))
     "js:set"
     (method (_ name value)
       (concatenate (write name) " = " (write value)))
     "js:return"
     (method (_ body)
       (concatenate "return " (write body)))
     "js:function"
     (method (_ name arguments body)
       (format-to-string "function %s(%s) {%s}"
			 (if name
			     (concatenate name " ")
			     "")
			 (join (map write arguments) ", ")
			 (if body
			     (format-to-string
			      "\n%s\n" (write-statements body))
			     "")))
     "js:escape"
     (method (_ symbol)
       (write (escape-symbol symbol)))
     "js:throw"
     (method (statements? error)
       (bind ((result (concatenate "throw " (write error))))
             (if statements?
		 result
		 (wrap-block result))))))

(define-function compile (form)
  (write (macroexpand form)))

(define-function macroexpand (form)
  (select form instance?
    ((<array>)
     ;; apply macros
     (while (and (instance? form <array>)
		 (instance? (first form) <symbol>)
		 (get *macros* (symbol-name (first form))))
       (bind ((macro (get *macros* (symbol-name (first form)))))
         (set! form (apply macro (rest form)))))
     ;; still array?
     (if (instance? form <array>)
	 (bind ((head (first form)))
	   ;; special?
	   (if-bind (expander (and (instance? head <symbol>)
				   (get *special-forms*
					(symbol-name head))))
	     (select expander instance?
	       ((<number>)
		(concatenate
		 ;; skip n arguments, macroexpand rest
		 (copy-sequence form end: (inc expander))
		 (map macroexpand (copy-sequence form start: (inc expander)))))
	       ((<function>)
		;; custom expander
		(apply expander (rest form)))
	       (else:
		;; form mustn't be expanded
		form))
	     ;; not special
	     (map macroexpand form)))
	 ;; not a macro
	 (macroexpand form)))
    ((<symbol>)
     ;; symbol-macro?
     (if-bind (symbol-macro (get *symbol-macros*
				 (symbol-name form)))
       (macroexpand (symbol-macro))
       form))
    (else: form)))

(define-function write (form #key statements?)
  (select form instance?
    ;; array?
    ((<array>)
     (bind ((head (first form))
	    (head-name (symbol-name head))
	    (tail (rest form)))
       (cond
	 ;; infix?
	 ((and (instance? head <symbol>)
	       (get *infix* head-name))
	  (bind ((infix (get *infix* head-name))
		 (inside (join (map write tail)
			       (concatenate " " infix " "))))
	    (concatenate "(" inside ")")))
	 ;; writer?
	 ((and (instance? head <symbol>)
	       (get *writers* head-name))
	  (apply (get *writers* head-name)
		 statements?
		 tail))
	 ((and (instance? head <array>)
	       (instance? (first head) <symbol>)
	       (= (symbol-name (first head))
		  "js:function"))
	  (concatenate "(" (write head) ")"
		       "(" (join (map write tail) ", ") ")"))
	 (else:
	  (concatenate
	   (write head)
	   "(" (join (map write tail) ", ") ")")))))
    ;; string?
    ((<string>)
     (description form))
    ((<symbol>)
      (if-bind (symbol (get *symbols* (symbol-name form)))
        symbol
	(begin
	 (escape-symbol form))))
    (else:
       form)))

(define write-statements
    (rcurry write statements?: #t))