(define-module compiler
    import: (core reader))

(define S symbol)

(define-function prepend-return (forms)
  (concatenate
   (but-last forms)
   (make-array
    (bind ((last (last forms)))
      (if (= (first last)
             (S "js:return"))
          (last forms)
          (make-array (S "js:return")
                      ;; TODO: maybe needs to be
                      ;;       wrapped in a 'begin'
                      last))))))

(define *macros*
    (make-object
     "%backquote"
     (method (form)
       (bind-methods ((transform (form)
                        (cond
                          ((and (instance? form <array>)
                                (not (empty? form)))
                           (if (= (first form)
                                  (S "%comma"))
                               (second form)
                               (concatenate `(make-array)
                                            (map transform
                                                 form))))
                          ((instance? form <symbol>)
                           `(symbol ,(symbol-name form)))
                          (else:
                           form))))
         (transform form)))
     "%comma"
     identity
     "%function"
     (method (name arguments body)
       (make-array (S "js:function") name args
                   (macroexpand body)))
     "define"
     (method (name value)
       `(%define (js:escape ,name)
         ,value))
     "if"
     (method (test then else)
       `(js:if (true? ,test)
               ,then
               ,else))
     "when"
     (method (test #rest body)
       `(if ,test
            ,(concatenate `(begin) body)
            #f))
     "unless"
     (method (test #rest body)
       `(if (not ,test)
            ,(concatenate `(begin) body)
            #f))
     "bind"
     (method (bindings #rest body)
       (destructuring-bind ((var value) #rest other) bindings
         (concatenate
          `(,(concatenate `(js:function js:null (,var))
                          `(,(if (empty? other)
                                 (concatenate `(begin)
                                              (prepend-return body))
                                 (concatenate `(bind ,other)
                                              body)))))
          (if value `(,value) `()))))
     "if-bind"
     (method (binding then else)
       (destructuring-bind (var value) binding
         (bind ((temp (generate-symbol)))
           `(bind ((,temp ,value))
              (if ,temp
                  (bind ((,var ,temp))
                    ,then)
                  ,else)))))
     "set!"
     (method (expression value)
       (if (and (instance? expression <array>)
                (not (= (first expression)
                        (S "js:get-property"))))
           (concatenate `(%set)
                        expression
                        `(value))
           `(js:set ,expression ,value)))
     "while"
     (method (test #rest body)
       `((js:function js:null ()
           ,(concatenate
             `(begin)
             `(,(concatenate `(js:while ,test)
                             body)
                (js:return #f))))))
     "define-protocol"
     (method (protocol #rest functions)
       (bind-methods ((declare (f)
                        (bind ((name (first f)))
                          `(define ,name
                               (%make-dispatcher ,protocol
                                 (js:escape ,name))))))
         (concatenate `(begin
                        (define ,protocol (%make-protocol)))
                      (map declare functions))))
     "and"
     (method (#rest expressions)
       (or (empty? expressions)
           `(when ,(concatenate `(js:and)
                                (map (method (expression)
                                       `(true? ,expression))
                                     (but-last expressions)))
              ,(last expressions))))
     "or"
     (method (#rest expressions)
       (and (not (empty? expressions))
            (bind ((bindings (make-array))
                   (clauses (map (method (expression)
                                   (bind ((temp (generate-symbol)))
                                     (push-last bindings
                                                `(,temp js:undefined))
                                     `((begin
                                        (set! ,temp ,expression)
                                        (true? ,temp))
                                       ,temp)))
                                 expressions)))
              `(bind ,bindings
                 ,(concatenate `(cond)
                               clauses)))))
     "define-function"
     (method (name arguments #rest body)
       (destructuring-bind (setter? name)
           (if (and (instance? name <array>)
                    (= (size name) 2)
                    (first name)
                    (= (first name) (S "setter")))
               (make-array #t (first name))
               (make-array #f name))
         (when (not (or (instance? name <symbol>)
                        setter?))
           (signal (make <error> message:
                         "define-function: name => symbol or (setter name)")))
         (bind ((type (if (empty? arguments)
                          (S "js:null")
                          (bind ((head (first arguments)))
                            (if (and (instance? head <array>)
                                     (> (size (first head)) 1))
                                (symbol-name (second head))
                                "Object")))))
           `(,(if setter?
                  (S "%define-setter")
                  (S "%define-getter"))
              *module*
              exports
              (js:escape ,name)
              ,(concatenate `(method ,arguments)
                            body)
              ,type))))
     "inc!"
     (method (object value)
       `(set! ,object
              (js:+ ,object ,(or value 1))))
     "dotimes"
     (method (binding #rest body)
       (destructuring-bind (var count result) binding
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) (or result #f)))
                      body)))
     "for"
     (method (clauses end #rest body)
       (bind ((init-clauses (make-array))
              (next-clauses (make-array)))
         (do (method (clause)
               (push-last init-clauses
                          (copy-sequence clause end: 2))
               (push-last next-clauses
                          (first clause))
               (push-last next-clauses
                          (third clause)))
             clauses)
         `(bind ,init-clauses
            ,(concatenate `(while (not ,(first end)))
                          body
                          `(,(concatenate `(%parallel-set)
                                          next-clauses)))
            ,(if (empty? (rest end))
                 #f
                 (second end)))))))

(define *symbol-macros* (make-object))

;; (set! (get *macros* "define-macro")
;;       (method (name arguments #rest body)
;;         (set! (get *macros* name)
;;            (method

(define *special-forms*
    (make-object
     "js:array" 0
     "js:defined" 0
     "js:negative" 0
     "js:not" 0
     "begin" 0
     "js:if" 0
     "js:throw" 0
     "js:return" 0
     "js:while" 0
     "js:new" 1
     "js:var" 1
     "js:set" 1
     "js:for-in" 1
     "js:function" 2
     "js:escape" #f
     "js:identifier" #f
     "js:get-property" #f
     "js:for"
     (method (clauses #rest body)
       (concatenate
        (make-array (S "js:for")
                    (map (method (clause)
                           (destructuring-bind ((var value) #rest rest) clause
                             (concatenate (make-array var (macroexpand value))
                                          (map macroexpand rest))))
                         clauses))
        (macroexpand body)))
     "js:try"
     (method (body var catch finally)
       (make-array (S "js:try")
                   (macroexpand body)
                   var
                   (macroexpand catch)
                   (macroexpand finally)))))

(define *infix*
    (make-object
     "js:and" "&&"
     "js:or" "||"
     "js:+" "+"
     "js:-" "-"
     "js:*" "*"
     "js:/" "/"
     "js:>" ">"
     "js:<" "<"
     "js:>=" ">="
     "js:<=" "<="
     "js:==" "=="
     "js:===" "==="
     "js:instanceof" "instanceof"))

(define *symbols*
    (make-object
     "js:null" "null"
     "js:this" "this"
     "js:undefined" "undefined"
     "js:arguments" "arguments"))

(define *symbol-escapes*
    (make-object
     "-" "_M_"
     "+" "_PL_"
     "!" "_B_"
     "?" "_W_"
     "%" "_PE_"
     "#" "_H_"
     "@" "_A_"
     "*" "_ST_"
     "/" "_SL_"
     "=" "_E_"
     ":" "_C_"
     "<" "_LT_"
     ">" "_GT_"
     "_" "__"
     "[" "_SO_"
     "]" "_SC_"
     "{" "_BO_"
     "}" "_BC_"))

(define *reserved*
    (make-array
     "break" "case" "catch" "continue" "default" "delete" "do" "else"
     "finally" "for" "function" "if" "in" "instanceof" "new" "return"
     "switch" "this" "throw" "try" "typeof" "var" "void" "while"
     "with" "abstract" "boolean" "byte" "char" "class" "const"
     "debugger" "double" "enum" "export" "extends" "final" "float"
     "goto" "implements" "import" "int" "interface" "long" "native"
     "package" "private" "protected" "public" "short" "static" "super"
     "synchronized" "throws" "transient" "volatile" "null" "true" "false"
     "arguments" "object" "number" "string" "array"))

(define *symbol-count* 0)

(define-function generate-symbol ()
  (bind ((symbol (make <symbol> name:
                       (concatenate "_" (as-string *symbol-count*)))))
    (inc! *symbol-count*)
    (set! (get symbol "generated") #t)
    symbol))

(define *hyphen-pattern*
    (make <regexp>
          pattern: "-(.)"
          global?: #t))

(define-function escape (name)
  (join (map (method (char)
               (if-bind (replacement (get *symbol-escapes* char))
                 replacement
                 char))
             (as-array
              (replace-all *hyphen-pattern* name
                           (method (match)
                             (as-uppercase (second match)))))) ""))

(define-function escape-symbol (symbol)
  (bind ((name (symbol-name symbol)))
    (cond
      ((get symbol "generated")
       name)
      ((member? name *reserved*)
       (concatenate "_" name))
      ((and (= (first name) "<")
            (= (last name) ">")
            (> (size name) 2))
       (concatenate "_CL_"
                    (escape (but-last (rest name)))))
      ((and (= (first name) "*")
            (= (last name) "*")
            (> (size name) 2))
       (as-uppercase
        (escape (but-last (rest name)))))
      (else:
       (escape name)))))

(define-function wrap-block (code)
  (format-to-string "(function(){\n%s\n})()"
                    code))

(define-function write-body (body)
  (write-statements
   (concatenate
    (make-array (S "begin"))
    body)))

(define *property-pattern*
    (make <regexp>
          pattern: "^[a-z_]+[a-z0-9]*$"
          ignore-case?: #t))

(define *writers*
    (make-object
     "js:negative"
     (method (_ object)
       (format-to-string "(- %s)" (write object)))
     "js:not"
     (method (_ expression)
       (concatenate "!" (write expression)))
     "begin"
     (method (statements? #rest forms)
       (cond
         (statements?
          (join (map write-statements
                     forms)
                ";\n"))
         ((> (size forms) 1)
          (concatenate
           "(" (join (map write forms) ", ") ")"))
         (else:
          (write (first forms)))))
     "js:if"
     (method (statements? test then else)
       (if statements?
           (format-to-string
            "if (%s) {\n%s\n}%s"
            (write test)
            (write-statements then)
            (if else
                (format-to-string
                 " else {%s\n}"
                 (write-statements else))
                ""))
           (apply format-to-string
                  "(%s ? %s : %s)"
                  (map write
                       (make-array test then else)))))
     "js:array"
     (method (_ #rest elements)
       (format-to-string "[%s]" (join (map write elements) ", ")))
     "js:defined"
     (method (_ expression)
       (format-to-string "(typeof (%s) != 'undefined')"
                         (write expression)))
     "js:try"
     (method (statements? body condition catch finally)
       (bind ((result
               (format-to-string
                "try {\n%s\n}%s%s"
                (write-statements body)
                (if catch
                    (format-to-string
                     " catch (%s) {\n%s\n}"
                     (write condition)
                     (write-statements catch))
                    "")
                (if finally
                    (format-to-string
                     " finally {\n%s\n}"
                     (write-statements finally))
                    ""))))
         (if statements?
             result
             (wrap-block result))))
     "js:for-in"
     (method (statements? variable/expression #rest body)
        (destructuring-bind (variable expression) variable/expression
          (bind ((result
                  (format-to-string "for (var %s in %s) {\n%s\n}"
                                    variable
                                    (write expression)
                                    (write-body body))))
            (if statements?
                result
                (wrap-block result)))))
     "js:for"
     (method (statements? clauses #rest body) {
       (bind ((inits (make-array))
              (tests (make-array))
              (nexts (make-array)))
         (do (method (clause)
               (destructuring-bind ((var value) test next) clause
                 (bind ((set (S "js:set")))
                   (push-last
                    inits (write (make-array set var value)))
                   (push-last
                    tests (write test))
                   (push-last
                    nexts (write (make-array set var next))))))
             clauses)
         (bind ((result
                 (format-to-string
                  "for (var %s) {\n%s\n}"
                  (join (map (method (parts)
                               (join parts ", "))
                             (make-array inits tests nexts))
                        "; ")
                  (write-body body))))
         (if statements?
             result
             (wrap-block result)))))
     "js:while"
     (method (statements? test #rest body)
       (bind ((result
               (format-to-string
                "while (%s) {\n%s\n}"
                (write test)
                (write-body body))))
         (if statements?
             result
             (wrap-block result))))
     "js:identifier"
     (method (_ identifier)
       (as-string identifier))
     "js:get-property"
     (method (_ object #rest elements)
       (concatenate
        (if (instance? object <string>)
            string
            (write string))
        (apply concatenate
               (method (element)
                 (if (and (instance? element <string>)
                          (match *property-pattern* element))
                     (concatenate "." element)
                     (concatenate "[" (write element) "]")))
               elements)))
     "js:new"
     (method (_ name #rest arguments)
       (format-to-string "new %s (%s)"
                         (write name)
                         (join (map write arguments) ", ")))
     "js:var"
     (method (_ name value)
       (concatenate
        "var " name
        (if (and value
                 (not (= value (S "js:undefined"))))
            (concatenate " = " value)
            "")))
     "js:set"
     (method (_ name value)
       (concatenate (write name) " = " (write value)))
     "js:return"
     (method (_ body)
       (concatenate "return " (write body)))
     "js:function"
     (method (_ name arguments body)
       (format-to-string "function %s(%s) {%s}"
                         (if (and name
                                  (not (= name (S "js:null"))))
                             (concatenate (escape-symbol name) " ")
                             "")
                         (join (map write arguments) ", ")
                         (if body
                             (format-to-string
                              "\n%s\n" (write-statements body))
                             "")))
     "js:escape"
     (method (_ symbol)
       (write (escape-symbol symbol)))
     "js:throw"
     (method (statements? error)
       (bind ((result (concatenate "throw " (write error))))
             (if statements?
                 result
                 (wrap-block result))))))

(define-function compile (form #key statements?)
  (write (macroexpand form)
         statements?: statements?))

(define-function macroexpand (form)
  (select form instance?
    ((<array>)
     ;; apply macros
     (while (and (instance? form <array>)
                 (instance? (first form) <symbol>)
                 (get *macros* (symbol-name (first form))))
       (bind ((macro (get *macros* (symbol-name (first form)))))
         (set! form (apply macro (rest form)))))
     ;; still array?
     (if (instance? form <array>)
         (bind ((head (first form)))
           ;; special?
           (if-bind (expander (and (instance? head <symbol>)
                                   (get *special-forms*
                                        (symbol-name head))))
             (select expander instance?
               ((<number>)
                (concatenate
                 ;; skip n arguments, macroexpand rest
                 (copy-sequence form end: (inc expander))
                 (map macroexpand (copy-sequence form start: (inc expander)))))
               ((<function>)
                ;; custom expander
                (apply expander (rest form)))
               (else:
                ;; form mustn't be expanded
                form))
             ;; not special
             (map macroexpand form)))
         ;; not a macro
         (macroexpand form)))
    ((<symbol>)
     ;; symbol-macro?
     (if-bind (symbol-macro (get *symbol-macros*
                                 (symbol-name form)))
       (macroexpand (symbol-macro))
       form))
    (else: form)))

(define-function write (form #key statements?)
  (select form instance?
    ;; array?
    ((<array>)
     (bind ((head (first form))
            (head-name (symbol-name head))
            (tail (rest form)))
       (cond
         ;; infix?
         ((and (instance? head <symbol>)
               (get *infix* head-name))
          (bind ((infix (get *infix* head-name))
                 (inside (join (map write tail)
                               (concatenate " " infix " "))))
            (concatenate "(" inside ")")))
         ;; writer?
         ((and (instance? head <symbol>)
               (get *writers* head-name))
          (apply (get *writers* head-name)
                 statements?
                 tail))
         ;; anonymous function call?
         ((and (instance? head <array>)
               (instance? (first head) <symbol>)
               (= (symbol-name (first head))
                  "js:function"))
          (concatenate "(" (write head) ")"
                       "(" (join (map write tail) ", ") ")"))
         (else:
          (concatenate
           (write head)
           "(" (join (map write tail) ", ") ")")))))
    ((<symbol>)
     (if-bind (symbol (get *symbols* (symbol-name form)))
       symbol
       (escape-symbol form)))
    ((<boolean>)
     (if form "true" "false"))
    (else:
     (description form))))

(define write-statements
    (rcurry write statements?: #t))