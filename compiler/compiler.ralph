(define-module compiler
    import: (core reader format regexp)
    export: (compile))

(define S symbol)

(define-function prepend-return (forms)
  (concatenate
   (but-last forms)
   (make-array
    (bind ((tail (last forms)))
      (if (= (first tail)
             (S "js:return"))
          (last forms)
          `(js:return ,tail))))))

(define-function argument-names (arguments)
  (map (method (argument)
         (if (instance? argument <array>)
             (first argument)
             argument))
       arguments))

(define-function required-arguments (arguments)
  (bind ((length (size arguments)))
    (bind-methods ((position (hash-symbol)
                     (find-key arguments (curry = hash-symbol)
                               failure: length)))
      (copy-sequence arguments
                     end: (apply min length
                                 (map position
                                      (make-array #key #rest)))))))

(define-function function-declaration (name arguments body)
  (bind-methods ((position (symbol)
                  (find-key arguments (curry = symbol))))
    (bind ((required (required-arguments arguments))
           (body (if (and (> (size body) 1)
                          (instance? (first body) <string>))
                     ;; strip documentation
                     (copy-sequence body start: 1)
                     body))
           (rest-position (position #rest))
           (key-position (position #key))
           (rest/key-code (make-array)))
      ;; key
      (when (or rest-position
                key-position)
        (bind ((rest-var (if rest-position
                             (element arguments
                                      (inc rest-position))
                             (generate-symbol))))
          (push-last rest/key-code
                     `(js:var ,rest-var
                              (as-array js:arguments
                                        ,(size required))))
          (when key-position
            ;; check #rest and #key are in order
            (when (and rest-position
                       (< key-position rest-position))
              (signal (make <error>
                            message: "#key should appear after #rest")))
            (destructuring-bind (key-var value-var index-var)
                (repeatedly generate-symbol 3)
              (bind ((setter-code `(select ,key-var js:==)))
                (do (method (key)
                      (destructuring-bind (name default)
                          (if (instance? key <array>)
                              key
                              (make-array key #f))
                        (push-last rest/key-code
                                   `(js:var ,name ,default))
                        (push-last setter-code
                                   `((,(keyword (symbol-name name)))
                                     (js:set ,name ,value-var)))))
                    (copy-sequence arguments
                                   start: (inc key-position)))
                (push-last rest/key-code
                           `(js:for (((,index-var 0)
                                      (js:< ,index-var
                                            (js:get-property ,rest-var "length"))
                                      (js:+ ,index-var 2)))
                                    (js:var ,key-var
                                            (js:get-property ,rest-var ,index-var))
                                    (js:var ,value-var
                                            (js:get-property ,rest-var
                                                             (js:+ ,index-var 1)))
                                    (when (keyword? ,key-var)
                                      ,setter-code))))))))
      ;; function
      `(js:function ,(or name (S "js:null"))
                    ,(argument-names required)
                    ,(concatenate `(begin)
                                  rest/key-code
                                  ;; body
                                  (prepend-return body))))))


(define *macros*
    (make-object
     "define-macro"
     (method (name arguments #rest body)
       (bind ((compiled (compile
                         (concatenate `(method ,arguments)
                                      body))))
         (print "MACRO:" compiled)))



       ;; (set! (get *macros* name)
       ;;       macro


     "make-array"
     (method (#rest elements)
       (concatenate `(js:array)
                    elements))
     "has?"
     (method (object property)
       `((js:get-property ,object "hasOwnProperty")
         ,property))
     "%has-constructor?"
     (method (object constructor)
       `(js:=== (js:get-property ,object "constructor")
                ,constructor))
     "%backquote"
     (method (form)
       (bind-methods ((transform (form)
                        (cond
                          ((and (instance? form <array>)
                                (not (empty? form)))
                           (if (= (first form)
                                  (S "%comma"))
                               (second form)
                               (concatenate `(make-array)
                                            (map transform
                                                 form))))
                          ((instance? form <symbol>)
                           `(symbol ,(symbol-name form)))
                          (else:
                           form))))
         (transform form)))
;; TODO:
;;     "%comma"
;;     (method (value)
;;       (signal (make <error> message: "comma not inside backquote")))
     "%parallel-set"
     (method (#rest clauses)
       (bind ((temp-clauses (make-array))
              (set-clauses (make-array)))
         (if (> (size clauses) 2)
             (begin
              (for ((i 0 (+ i 2)))
                   ((>= i (size clauses)))
               (bind ((temp (generate-symbol)))
                  (push-last temp-clauses
                             `(js:var ,temp ,(element clauses (inc i))))
                  (push-last set-clauses
                             `(js:set ,(element clauses i) ,temp))))
              (concatenate `(begin)
                           temp-clauses
                           set-clauses))
             (concatenate `(js:set)
                          clauses))))
     "define"
     (method (name value)
       `(%define *module* exports
                 (js:escape ,name)
                 ,value))
     "if"
     (method (test then else)
       `(js:if (true? ,test)
               ,then
               ,else))
     "when"
     (method (test #rest body)
       `(if ,test
            ,(concatenate `(begin) body)
            #f))
     "unless"
     (method (test #rest body)
       `(if (not ,test)
            ,(concatenate `(begin) body)
            #f))
     "bind"
     (method (bindings #rest body)
       (destructuring-bind ((var value) #rest other) bindings
         (concatenate
          `(,(concatenate `(js:function js:null (,var))
                          `(,(if (empty? other)
                                 (concatenate `(begin)
                                              (prepend-return body))
                                 (concatenate `(js:return
                                                ,(concatenate
                                                  `(bind ,other)
                                                  body)))))))
          (if value `(,value) `()))))
     "if-bind"
     (method (binding then else)
       (destructuring-bind (var value) binding
         (bind ((temp (generate-symbol)))
           `(bind ((,temp ,value))
              (if ,temp
                  (bind ((,var ,temp))
                    ,then)
                  ,else)))))
     "set!"
     (method (expression value)
       (if (and (instance? expression <array>)
                (not (= (first expression)
                        (S "js:get-property"))))
           (concatenate `(%set)
                        expression
                        `(,value))
           `(js:set ,expression ,value)))
     "while"
     (method (test #rest body)
       `((js:function js:null ()
           ,(concatenate
             `(begin)
             `(,(concatenate `(js:while ,test)
                             body)
                (js:return #f))))))
     "define-protocol"
     (method (protocol #rest functions)
       (bind-methods ((declare (f)
                        (bind ((name (first f)))
                          `(define ,name
                               (%make-dispatcher ,protocol
                                 (js:escape ,name))))))
         (concatenate `(begin
                        (define ,protocol (%make-protocol)))
                      (map declare functions))))
     "and"
     (method (#rest expressions)
       (or (empty? expressions)
           `(when ,(concatenate `(js:and)
                                (map (method (expression)
                                       `(true? ,expression))
                                     (but-last expressions)))
              ,(last expressions))))
     "or"
     (method (#rest expressions)
       (and (not (empty? expressions))
            (bind ((variables (make-array))
                   (clauses (map (method (expression)
                                   (bind ((temp (generate-symbol)))
                                     (push-last variables
                                                `(js:var ,temp))
                                     `((begin
                                        (set! ,temp ,expression)
                                        (true? ,temp))
                                       ,temp)))
                                 expressions)))
                  `((js:function js:null ()
                      ,(concatenate `(begin)
                                    variables
                                    `((js:return
                                        ,(concatenate `(cond)
                                                      clauses)))))))))
     "define-function"
     (method (name arguments #rest body)
       (destructuring-bind (setter? name)
           (if (and (instance? name <array>)
                    (= (size name) 2)
                    (first name)
                    (= (first name) (S "setter")))
               (make-array #t (second name))
               (make-array #f name))
         (when (not (or (instance? name <symbol>)
                        setter?))
           (signal (make <error> message:
                         "define-function: name => symbol or (setter name)")))
         (bind ((type (if (empty? arguments)
                          (S "js:null")
                          (bind ((head (first arguments)))
                            (if (and (instance? head <array>)
                                     (> (size head) 1))
                                `(js:escape ,(second head))
                                "Object")))))
           `(,(if setter?
                  (S "%define-setter")
                  (S "%define-getter"))
              *module*
              exports
              (js:escape ,name)
              ,(concatenate `(method ,arguments)
                            body)
              ,type))))
     "inc!"
     (method (object value)
       `(set! ,object
              (js:+ ,object ,(or value 1))))
     "dotimes"
     (method (binding #rest body)
       (destructuring-bind (var count result) binding
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) (or result #f)))
                      body)))
     "for"
     (method (clauses end #rest body)
       (bind ((init-clauses (make-array))
              (next-clauses (make-array)))
         (do (method (clause)
               (push-last init-clauses
                          (copy-sequence clause end: 2))
               (push-last next-clauses
                          (first clause))
               (push-last next-clauses
                          (third clause)))
             clauses)
         `(bind ,init-clauses
            ,(concatenate `(while (not ,(first end)))
                          body
                          `(,(concatenate `(%parallel-set)
                                          next-clauses)))
            ,(if (empty? (rest end))
                 #f
                 (second end)))))
     "method"
     (method (arguments #rest body)
       (function-declaration (S "js:null")
                             arguments body))
     "cond"
     (method (#rest cases)
       (if (empty? cases)
           #f
           (destructuring-bind (test #rest then) (first cases)
             (bind ((then (concatenate `(begin) then)))
               (if (= test else:)
                   then
                   `(if ,test
                        ,then
                        ,(concatenate `(cond)
                                      (rest cases))))))))
     "select"
     (method (value test #rest cases)
        (bind-methods ((test-expression (test-value)
                         `(,test ,value ,test-value)))
          (concatenate `(cond)
                       (map (method (case)
                              (destructuring-bind (tests #rest then) case
                                (if (= tests else:)
                                    case
                                    (concatenate
                                     `(,(concatenate `(or)
                                                     (map test-expression tests)))
                                     then))))
                            cases))))
     "handler-case"
     (method (body #rest conditions)
       (bind ((condition-var (generate-symbol)))
         `((js:function js:null ()
             (begin
               (js:try
                (js:return ,body)
                ,condition-var
                ,(concatenate
                  `(cond)
                  (map (method (condition)
                         (destructuring-bind ((type #rest arguments) #rest body)
                             condition
                           (concatenate `((instance? ,condition-var ,type))
                                        (destructuring-bind (#key condition)
                                            arguments
                                          (if condition
                                              `((js:var ,condition ,condition-var))
                                              `()))
                                        (prepend-return body))))
                       conditions))))))))
     "define-class"
     (method (class superclass #rest slots)
       (concatenate `(begin
                      (define ,class
                        (js:function js:null ()))
                      (set! (js:get-property ,class "%name")
                            ,(symbol-name class)))
                    (if (empty? slots)
                        `()
                        `(,(concatenate `(define-function initialize
                                           ,(concatenate `((object ,class) #key)
                                                         slots))
                                        (map (method (slot)
                                              `(set! (js:get-property object
                                                                      ,(symbol-name slot))
                                                     ,slot))
                                             (argument-names slots)))))
                    (if (empty? superclass)
                        `()
                        `((%inherit ,class ,(first superclass))))))
     "define-module"
     (method (name #key (import `()) (export `()))
       (bind ((property (generate-symbol))
              (module (generate-symbol)))
         (concatenate `(begin
                        (js:var *module* js:this)
                        (js:set (js:get-property *module* "%exports")
                                ,(concatenate `(js:array)
                                              (map (method (name)
                                                     (if (instance? name <symbol>)
                                                         (escape-symbol name)
                                                         (write name)))
                                                   export))))
                      (map (method (name)
                             `(begin
                                (js:var ,module (require (js:escape ,name)))
                                (js:for-in (,property ,module)
                                  (js:if ((js:get-property ,module "hasOwnProperty")
                                          ,property)
                                    (js:set (js:get-property *module* ,property)
                                            (js:get-property ,module ,property))))))
                           import))))
     "block"
     (method (argument #rest body)
        (destructuring-bind ((name)) argument
          (if name
              (bind ((condition (generate-symbol)))
                `(js:try
                  (js:return
                   ,(concatenate `(bind ((,name (%make-non-local-exit-function
                                                 ,(symbol-name name)))))
                                 body))
                  ,condition
                  (if (and (%non-local-exit? ,condition)
                           (js:=== (js:get-property ,condition "name")
                                   ,(symbol-name name)))
                      (js:return (js:get-property ,condition "value"))
                      (js:throw ,condition))))
              (concatenate `(begin) body))))
     "dotimes"
     (method (var/count/result #rest body)
       (destructuring-bind (var count result)
           var/count/result
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) ,(or result #f)))
                      body)))
     "bind-methods"
     (method (bindings #rest body)
        (concatenate `(bind
                       ,(map (method (binding)
                               (destructuring-bind (name arguments #rest body)
                                   binding
                               `(,name ,(function-declaration
                                         name arguments body))))
                             bindings))
                     body))
     "destructuring-bind"
     (method (pattern value #rest body)
       (bind ((target))
         (bind-methods ((destructure (pattern value)
                          (bind ((nested (make-array))
                                 (inner
                                  `(method ,(map (method (var)
                                                   (if (instance? var <array>)
                                                       (bind ((temp (generate-symbol)))
                                                         (push-last nested
                                                                    `(,var ,temp))
                                                         temp)
                                                       var))
                                                 pattern)))
                                 (wrapper `(apply ,inner ,value)))
                            (set! target inner)
                            (do (method (n)
                                  (bind ((sub-wrapper (apply destructure n)))
                                    (push-last inner sub-wrapper)
                                    (set! inner (second sub-wrapper))))
                                nested)
                            wrapper)))
         (bind ((wrapping (destructure pattern value)))
           (replace-subsequence! target body start: (size target))
           wrapping))))))

(define *symbol-macros* (make-object))

(define *special-forms*
    (make-object
     "js:array" 0
     "js:defined" 0
     "js:delete" 0
     "js:negative" 0
     "js:not" 0
     "begin" 0
     "js:if" 0
     "js:throw" 0
     "js:return" 0
     "js:while" 0
     "js:new" 1
     "js:var" 1
     "js:set" 1
     "js:for-in" 1
     "js:function" 2
     "js:escape" #f
     "js:identifier" #f
     "js:get-property" #f
     "js:for"
     (method (clauses #rest body)
       (concatenate
        (make-array (S "js:for")
                    (map (method (clause)
                           (destructuring-bind ((var value) #rest rest) clause
                             (concatenate
                              (make-array (make-array var (macroexpand value)))
                              (map macroexpand rest))))
                         clauses))
        (macroexpand body)))
     "js:try"
     (method (body var catch finally)
       (make-array (S "js:try")
                   (macroexpand body)
                   var
                   (macroexpand catch)
                   (macroexpand finally)))))

(define *infix*
    (make-object
     "js:and" "&&"
     "js:or" "||"
     "js:+" "+"
     "js:-" "-"
     "js:*" "*"
     "js:/" "/"
     "js:>" ">"
     "js:<" "<"
     "js:>=" ">="
     "js:<=" "<="
     "js:==" "=="
     "js:===" "==="
     "js:instanceof" "instanceof"))

(define *symbols*
    (make-object
     "js:null" "null"
     "js:this" "this"
     "js:undefined" "undefined"
     "js:arguments" "arguments"))

(define *symbol-escapes*
    (make-object
     "-" "_M_"
     "+" "_PL_"
     "!" "_B_"
     "?" "_W_"
     "%" "_PE_"
     "#" "_H_"
     "@" "_A_"
     "*" "_ST_"
     "/" "_SL_"
     "=" "_E_"
     ":" "_C_"
     "<" "_LT_"
     ">" "_GT_"
     "_" "__"
     "[" "_SO_"
     "]" "_SC_"
     "{" "_BO_"
     "}" "_BC_"))

(define *reserved*
    (make-array
     "break" "case" "catch" "continue" "default" "delete" "do" "else"
     "finally" "for" "function" "if" "in" "instanceof" "new" "return"
     "switch" "this" "throw" "try" "typeof" "var" "void" "while"
     "with" "abstract" "boolean" "byte" "char" "class" "const"
     "debugger" "double" "enum" "export" "extends" "final" "float"
     "goto" "implements" "import" "int" "interface" "long" "native"
     "package" "private" "protected" "public" "short" "static" "super"
     "synchronized" "throws" "transient" "volatile" "null" "true" "false"
     "arguments" "object" "number" "string" "array"))

(define *symbol-count* 0)

(define-function generate-symbol ()
  (bind ((symbol (make <symbol> name:
                       (concatenate "_" (as-string *symbol-count*)))))
    (inc! *symbol-count*)
    (set! (get symbol "generated") #t)
    symbol))

(define *hyphen-pattern*
    (make <regexp>
          pattern: "-(.)"
          global?: #t))

(define-function escape (name)
  (join (map (method (char)
               (if-bind (replacement (get *symbol-escapes* char))
                 replacement
                 char))
             (as-array
              (replace-all *hyphen-pattern* name
                           (method (match)
                             (as-uppercase (second match)))))) ""))

(define-function escape-symbol (symbol)
  (bind ((name (symbol-name symbol)))
    (cond
      ((has? symbol "generated")
       name)
      ((member? name *reserved*)
       (concatenate "_" name))
      ((and (= (first name) "<")
            (= (last name) ">")
            (> (size name) 2))
       (concatenate "_CL_"
                    (escape (but-last (rest name)))))
      ((and (= (first name) "*")
            (= (last name) "*")
            (> (size name) 2))
       (as-uppercase
        (escape (but-last (rest name)))))
      (else:
       (escape name)))))

(define-function wrap-block (code)
  (concatenate
   "(function(){\n" code "\n})()"))

(define-function write-body (body)
  (write-statements
   (concatenate
    (make-array (S "begin"))
    body)))

(define *property-pattern*
    (make <regexp>
          pattern: "^[a-z_]+[a-z0-9]*$"
          ignore-case?: #t))

(define *writers*
    (make-object
     "js:negative"
     (method (_ object)
       (concatenate
        "(- " (write object) ")"))
     "js:not"
     (method (_ expression)
       (concatenate
        "!" (write expression)))
     "begin"
     (method (statements? #rest forms)
       (cond
         (statements?
          (join (map write-statements
                     forms)
                ";\n"))
         ((> (size forms) 1)
          (concatenate
           "(" (join (map write forms) ", ") ")"))
         (else:
          (write (first forms)))))
     "js:if"
     (method (statements? test then else)
       (if statements?
           (concatenate
            "if (" (write test) ") {\n"
            (write-statements then)
            "\n}"
            (if else
                (concatenate
                 " else {\n" (write-statements else) "\n}")
                ""))
           (concatenate
            "(" (write test)
            " ? " (write then)
            " : " (write else)
            ")")))
     "js:array"
     (method (_ #rest elements)
       (concatenate
        "[" (join (map write elements) ", ") "]"))
     "js:defined"
     (method (_ expression)
       (concatenate
        "(typeof (" (write expression) ") != 'undefined')"))
     "js:delete"
     (method (_ expression)
       (concatenate "(delete (" (write expression) "))"))
     "js:try"
     (method (statements? body condition catch finally)
       (bind ((result
               (concatenate
                "try {\n"
                (write-statements body)
                "\n}"
                (if catch
                    (concatenate
                     " catch (" (write condition) ") {\n"
                     (write-statements catch) "\n}")
                    "")
                (if finally
                    (concatenate
                     " finally {\n"
                     (write-statements finally)
                     "\n}")
                  ""))))
         (if statements?
             result
             (wrap-block result))))
     "js:for-in"
     (method (statements? variable/expression #rest body)
        (destructuring-bind (variable expression) variable/expression
          (bind ((result
                  (concatenate
                   "for (var " (write variable)
                   " in " (write expression) ") {\n"
                   (write-body body) "\n}")))
            (if statements?
                result
                (wrap-block result)))))
     "js:for"
     (method (statements? clauses #rest body)
       (bind ((inits (make-array))
              (tests (make-array))
              (nexts (make-array)))
         (do (method (clause)
               (destructuring-bind ((var value) test next) clause
                 (bind ((set (S "js:set")))
                   (push-last
                    inits (write (make-array set var value)))
                   (push-last
                    tests (write test))
                   (push-last
                    nexts (write (make-array set var next))))))
             clauses)
         (bind ((result
                 (concatenate
                  "for (var "
                  (join (map (method (parts)
                               (join parts ", "))
                             (make-array inits tests nexts))
                        "; ")
                  ") {\n" (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result)))))
     "js:while"
     (method (statements? test #rest body)
       (bind ((result
               (concatenate
                "while (" (write test) ") {\n"
                (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result))))
     "js:identifier"
     (method (_ identifier)
       (as-string identifier))
     "js:get-property"
     (method (_ object #rest elements)
       (concatenate
        (if (instance? object <string>)
            object
            (write object))
        (apply concatenate
               (map (method (element)
                      (if (and (instance? element <string>)
                               (match *property-pattern* element))
                          (concatenate "." element)
                          (concatenate "[" (write element) "]")))
                    elements))))
     "js:new"
     (method (_ name #rest arguments)
       (concatenate
        "new " (write name)
        " (" (join (map write arguments) ", ") ")"))
     "js:var"
     (method (_ name value)
       (concatenate
        "var " (write name)
        (if (and value
                 (not (= value (S "js:undefined"))))
            (concatenate " = " (write value))
            "")))
     "js:set"
     (method (_ name value)
       (concatenate (write name) " = " (write value)))
     "js:return"
     (method (_ body)
       (concatenate "return " (write body)))
     "js:function"
     (method (_ name arguments body)
       (concatenate
        "function " (if (and name
                             (not (= name (S "js:null"))))
                        (concatenate (escape-symbol name) " ")
                      "")
        "(" (join (map write arguments) ", ") ") {"
        (if body
            (concatenate "\n" (write-statements body) "\n")
            "")
        "}"))
     "js:escape"
     (method (_ symbol)
       (write (escape-symbol symbol)))
     "js:throw"
     (method (statements? error)
       (bind ((result (concatenate "throw " (write error))))
             (if statements?
                 result
                 (wrap-block result))))))

(define-function compile (form #key statements?)
  (write (macroexpand form)
         statements?: statements?))

(define-function macroexpand (form)
  (select form instance?
    ((<array>)
     ;; apply macros
     (while (and (instance? form <array>)
                 (instance? (first form) <symbol>)
                 (has? *macros* (symbol-name (first form))))
       (bind ((macro (get *macros* (symbol-name (first form)))))
         (set! form (apply macro (rest form)))))
     ;; still array?
     (if (instance? form <array>)
         (bind ((head (first form)))
           ;; special?
           (if (and (instance? head <symbol>)
                    (has? *special-forms*
                          (symbol-name head)))
               (bind ((expander (get *special-forms*
                                     (symbol-name head))))
                 (select expander instance?
                   ((<number>)
                    (concatenate
                     ;; skip n arguments, macroexpand rest
                     (copy-sequence form end: (inc expander))
                     (map macroexpand (copy-sequence form start: (inc expander)))))
                   ((<function>)
                    ;; custom expander
                    (apply expander (rest form)))
                   (else:
                    ;; form mustn't be expanded
                    form)))
             ;; not special
             (map macroexpand form)))
         ;; not an array
         (macroexpand form)))
    ((<symbol>)
     ;; symbol-macro?
     (if-bind (symbol-macro (get *symbol-macros*
                                 (symbol-name form)))
       (macroexpand (symbol-macro))
       form))
    (else: form)))

(define-function write (form #key statements?)
  (select form instance?
    ;; array?
    ((<array>)
     (bind ((head (first form))
            (head-name (symbol-name head))
            (tail (rest form)))
       (cond
         ;; infix?
         ((and (instance? head <symbol>)
               (has? *infix* head-name))
          (bind ((infix (get *infix* head-name))
                 (inside (join (map write tail)
                               (concatenate " " infix " "))))
            (concatenate "(" inside ")")))
         ;; writer?
         ((and (instance? head <symbol>)
               (has? *writers* head-name))
          (apply (get *writers* head-name)
                 statements?
                 tail))
         ;; anonymous function call?
         ((and (instance? head <array>)
               (instance? (first head) <symbol>)
               (= (symbol-name (first head))
                  "js:function"))
          (concatenate "(" (write head) ")"
                       "(" (join (map write tail) ", ") ")"))
         (head
          (concatenate
           (write head)
           "(" (join (map write tail) ", ") ")"))
         (else:
          "[]"))))
    ((<symbol>)
     (if-bind (symbol (get *symbols* (symbol-name form)))
       symbol
       (escape-symbol form)))
    ((<boolean>)
     (if form "true" "false"))
    ((<keyword>)
     (concatenate "_k('" (symbol-name form) "')"))
    ((<string>)
     (concatenate "\"" form "\""))
    (else:
     (description form))))

(define write-statements
    (rcurry write statements?: #t))