* Approach
** everything is an expression, transform to statements after ANF easy
** instead of trying to use JS statements (while, try, etc.) as expressions,
by wrapping them in lambdas, allways generate statements (while, but also if, etc.)
(e.g. instead of "return x ? (x = 3, 1) : 2"
=> "var t1; if (x) { x = 3; t1 = 1 } else { t1 = 2 }; return t1")
** closures are expensive, try to only generate them when necessary
** macro "safety" by using prefixed versions in expansion
* Questions
** beta reduction
*** binds:what about assignment of variables?
(e.g. ((n 3) (i n)) .... (inc! i))
*** what about explicit closures, e.g. loops?
** inlining
*** 2 cases, see M. Comp. Impl. P322
(maybe only do last, beta-reduction should get rid of rebindings)
**** all parameters simple variables => simply rename vars in body
**** non-trivial expressions => evaluate all once, then rename
*** (full ANF would make inlining easier)
*** simple for in-module, but what about cross-module inlining?!
*** (%inline! <var>) after definition?
*** how to make sure it is actually bound to core-method?
(bind ((not (method (x) x)))
  (not 1))
*** import definitons from ralph/core by default? treat special?
** ANF
*** only normalizes expressions containing statements
*** reduces amount of bindings directly, instead of normalization,
then reverse and reduce back
*** "direct" approach/non-normalization maybe wrong when inlining?!
* ANF
** "The Essence of Compiling with Continuations"
Flanagan, Sabry, Duba, Felleisen
** "A-Normalization: Why and How"
Matt Might (http://matt.might.net/articles/a-normalization/)
** modified:
*** support for %while
*** create less bindings for expressions involving
**** no control-flow statements (see contains-statements?)
**** reduces JS variable bindings (5-20% performance hit)
* Languages/Passes
** L1: Source
#+BEGIN_SRC
<prog> ::= <dec>*
<dec> ::= (define <var> <exp>)
       |  (define-function <var> <lambda-list> <exp>*)
       |  (define-function (setter <var>) <lambda-list> <exp>*)
       |  (define-generic <var> <lambda-list>)
       |  (define-method <var> <typed-lambda-list> <exp>*)
       |  (define-method (setter <var>) <typed-lambda-list> <exp>*)
       |  <exp>

<lambda-list> ::= (<var>* <rest-key>)

<typed-lambda-list> ::= ([(<var> <exp>)] <var>* <rest-key>)
                     |  <lambda-list>
<nested-lambda-list> ::= ({<nested-lambda-list> | <var>}* <rest-key>)

<rest-key> ::= [#rest <var>] [#key <var> | (<var> <exp>)]

<exp> ::= (bind ((<var> <exp>)*) <exp>*)
        | (begin <exp>*)
        | (if <exp> <exp> <exp>)
        | (if-bind (<var> <exp>) <exp> <exp>)
        | (when <exp> <exp>*)
        | (unless <exp> <exp>*)
        | (set! <var> <exp>)
        | (set! <exp> <exp>*)
        | (parallel-set! {<var> <exp>}*)
        | (method <lambda-list> <exp>*)
        | (and <exp>*)
        | (or <exp>*)
        | (while <exp> <exp>*)
        | (dotimes (<var> <exp> <exp>) <exp>*)
        | (until <exp> <exp>*)
        | (bind-properties (<var>*) <exp> <exp>*)
        | (destructuring-bind <nested-lambda-list> <exp> <exp>*)
        | (. <exp> ({<string>|<symbol>} <exp>*)*)
        | <number>
        | <boolean>
        | <string>
        | <var>
        | <symbol>

<var> ::= <symbol>
#+END_SRC
** L2: expanded top-level defines
#+BEGIN_SRC
<prog> ::= <dec>*
<dec> ::= (define <var> <L1.exp>)
       | <L1.exp>
#+END_SRC
** L3: macroexpanded
#+BEGIN_SRC
<prog> ::= <dec>*
<dec> ::= (%define <var> <exp>)
       |  <exp>
<exp> ::= (%bind (<var> <exp>) <exp>)
       |  (%begin <exp>+)
       |  (%if <exp> <exp> <exp>)
       |  (%set <var> <exp>)
       |  (%method (<var>*) <exp>)
       |  (%while <exp> <exp>)
       |  (%array <exp>*)
       |  (%object {<string> <exp>}*)
       |  <number>
       |  <boolean>
       |  <string>
       |  <var>
#+END_SRC
** alpha-converted
(ANF algorithm assumes unique naming of variables:
 "We assume the front-end uniquely renames all variables [...]")
** in ANF
** beta-reduced
** TODO: constant propagation, constant folding
** TODO: unreachable code elimination
** TODO: dead-code elimination
check all but last expressions in body:
side-effect free? no function call, constant or symbol
** lift and reuse symbols/keywords/hash-symbols
** in statement form (with explicit returns)
** folding: transform nested %bind to sing %var, collapse %begin
** TODO: check tests are boolean, if not: wrap with true?
(requires type inference)
** TODO: inline
** TODO: optimize else when if uses explicit returns (always ok?):
(%if ... (return .1.) (return .2.))
=> (%begin (%if ... (return .1.) #f) (return .2.))
** TODO: JS' return has false value as default:
(%return #f) => (js:return)
 define free variables
* free variables/usage
** problem:
usage of identifier before definition = free variable
=> not renamed by alpha-convert
** solution:
before alpha-conversion, detect free variables in
definition and create empty definition (if not defined yet)
** normally closure-conversion before alpha-conversion
** TODO: signal warning
