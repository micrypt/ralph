
;; TODO: change imports to ralph2 when self-hosting
;; TODO: adjust to core API changes:
;;  - keys => object-properties
;; TODO: move helper macros into own module

(define-module ralph2/compiler
  import: (ralph/core ralph/format ralph/regexp ralph/reader ralph/date)
  export: (<environment> macroexpand-1
                         macroexpand
                         macroexpand-all
                         alpha-convert
                         reset-symbol-counter!
                         atomic?
                         normalize-term))

;; TODO: cross-module inlining

;; TODO: use verbs in function names

;; TODO: naming convention: identifier = symbol, name = string

;; TODO: refactor nodejs specific code into file stream

;; TODO: hygienic expansion:
;;       - rename symbols before passing to expander
;;       - rename after expansion
;;       - lift external references

;; TODO: constant propagation, constant folding
;; TODO: dead code elimination
;; TODO: fix form/env naming convention

;; TODO: signal warning in define-free-variables

;; TODO: fix calling behaviour: var x = y.foo; x() VS y.foo()
;;       problematic when normalization binds %get-property
;;       => .bind?

;; NOTE: no symbol expansion after macroexpand-all,
;;       as ANF uses atomic? to decide if expression
;;       has side-effects and needs to be normalized
;;       (influences evaluation order)

;; TODO: Clojure(Script) loop/recur

;; TODO: ensure symbol-macro expanded before whole form

;; TODO: update language definitions,
;;       ensure each pass respects all cases correctly


;;;; modules

;; module-name => <module>
(define *modules* (make-object))

(define-class <module> (<object>)
  name
  (exports [])
  ;; NOTE: resolved: [module-name names*]*
  (imports []))

(define *defined?*
  `(%all-arguments %this-method))

(define-class <environment> (<object>)
  module
  (macros (make-plain-object))
  (symbol-macros (make-plain-object))
  (names (make-object))
  (defined? (make-object))
  (lifted (make-object))
  (import-names (make-plain-object)))

;;;; utilities

(define-function expression? (form)
  (and (instance? form <array>)
       (not (empty? form))
       (instance? (first form) <symbol>)))

(define-function setter-symbol (name)
  (symbol (concatenate (symbol-name name) "-setter")))

(define-function setter-name? (name)
  (and (instance? name <array>)
       (== (size name) 2)
       (every? (rcurry instance? <symbol>) name)
       (== (symbol-name (first name)) "setter")))

(define *symbol-count* 0)

(define-function reset-symbol-counter! ()
  (set! *symbol-count* 0))

(define-function generate-symbol ()
  (bind ((name (concatenate "$" (as-string (inc! *symbol-count*))))
         (result (symbol name)))
    (set! (get result "generated?") #t)
    result))

;;;; special forms

;; utilities

(define *special-forms*
  (make-object))

(define-function special-form-definition (form env)
  (get *special-forms* (symbol-name (first form))))

(define-macro define-special-form (name #rest definition)
  `(set! (get *special-forms* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-special-form
  %method (env arguments body)
  `(%method ,arguments
     ,(macroexpand-all body env)))

(define-special-form
  %set (env name value)
  `(%set ,name ,(macroexpand-all value env)))

(define-special-form
  define (env name value)
  `(define ,name ,(macroexpand-all value env)))

(define-special-form
  %bind (env binding body)
  (destructuring-bind (var value) binding
    `(%bind (,var ,(macroexpand-all value env))
       ,(macroexpand-all body env))))

;;;; core macros

;; utilities

(define *core-macros*
  (make-object))

(define-macro define-core-macro (name #rest definition)
  `(set! (get *core-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

(define-function maybe-begin (expressions)
  (select (size expressions) ==
    ((0) #f)
    ((1) (first expressions))
    (else:
     (concatenate `(%begin)
                  expressions))))

;; => [required rest keys]
(define-function analyze-lambda-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function wrap (exp #rest wrappers)
  (reduce (method (result wrapper)
            (wrapper result))
          exp
          wrappers))

(define-function wrap-rest/keys (body all required rest key)
  (bind ((rest? rest)
         (rest (or rest
                   (unless (empty? key)
                     (generate-symbol)))))
    (wrap body
          (method (body)
            (if (empty? key)
                body
                (bind ((key-values
                        (map (method (binding)
                               (if (instance? binding <array>)
                                   binding
                                   [binding #f]))
                             key)))
                  `(bind-properties ,(map first key-values)
                       (%keys ,rest
                              ,(concatenate `(%object)
                                            (reduce1 concatenate
                                                     (map (method (key-value)
                                                            (destructuring-bind (key value)
                                                                key-value
                                                              [(symbol-name key) value]))
                                                          key-values))))
                     ,body))))
          (method (body)
            (if (or rest? (not (empty? key)))
                `(bind ((,rest (%native-call "$SL.call" ,all ,(size required))))
                   ,body)
                body)))))

;; definitions

(define-core-macro begin (_ #rest expressions)
  (maybe-begin expressions))

(define-core-macro method (_ arguments #rest body)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    `(%method ,required
       ,(wrap-rest/keys
         (maybe-begin body)
         (symbol "%all-arguments")
         required rest key))))


(define-core-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (maybe-begin body)
      (reduce (method (body binding)
                `(%bind
                  ,(if (instance? binding <symbol>)
                       `(,binding #f)
                       binding)
                  ,body))
              (maybe-begin body)
              (reverse bindings))))

(define-core-macro if (_ test then else)
  `(%if ,test ,then ,else))

(define-core-macro set! (_ place #rest rest)
  (if (and (instance? place <array>)
           (not (== (first place)
                    (symbol "%get-property"))))
      (concatenate `(,(setter-symbol (first place)))
                   (rest place)
                   rest)
      `(%set ,place ,(first rest))))


(define-core-macro parallel-set! (_ var value #rest clauses)
  (if (empty? clauses)
      `(set! ,var ,value)
      (bind ((temp (generate-symbol)))
        `(bind ((,temp ,value))
           ,(concatenate `(parallel-set!)
                         clauses)
           (set! ,var ,temp)))))


(define-core-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (maybe-begin then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-core-macro when (_ test #rest body)
  `(if ,test
       ,(maybe-begin body)
       #f))

(define-core-macro unless (_ test #rest body)
  `(if (not ,test)
       ,(maybe-begin body)
       #f))

(define-core-macro and (_ #rest values)
  (select (size values) ==
    ((0) #t)
    ((1) (first values))
    (else: `(when ,(first values)
              ,(concatenate `(and)
                            (rest values))))))

(define-core-macro or (_ #rest values)
  (select (size values) ==
    ((0) #f)
    ((1) (first values))
    (else:
     (bind ((value (generate-symbol)))
       `(bind ((,value ,(first values)))
          (if ,value
              ,value
              ,(concatenate `(or)
                            (rest values))))))))

(define-core-macro if-bind (_ binding then else)
  (destructuring-bind (var value) binding
    (bind ((temp (generate-symbol)))
      `(bind ((,temp ,value))
         (if ,temp
             (bind ((,var ,temp))
               ,then)
             ,else)))))

(define-core-macro while (_ test #rest body)
  `(%while ,test
     ,(maybe-begin body)))

(define-core-macro until (_ test #rest body)
  (concatenate `(while (not ,test))
               body))

(define-core-macro dotimes (_ binding #rest body)
  (bind ((temp (generate-symbol)))
    (destructuring-bind (var count result) binding
      `(bind ((,temp ,count))
         ,(concatenate
           `(for ((,var 0 (+ ,var 1)))
                 ((>= ,var ,temp) ,(or result #f)))
           body)))))

(define-core-macro for (_ clauses end #rest body)
  (bind ((init-clauses [])
         (next-clauses [])
         (vars (map first clauses)))
    (for-each ((clause clauses))
              ()
      ;; init
      (push-last init-clauses
                 (slice clause 0 2))
      ;; next
      (push-last next-clauses
                 (first clause))
      (push-last next-clauses
                 (third clause)))
    `(bind ,init-clauses
       ,(concatenate `(while ,(or (empty? end)
                                  `(not ,(first end)))
                        ,(concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)
                        ,(concatenate `(parallel-set!)
                                      next-clauses)))
       ,(unless (empty? (rest end))
          (concatenate `(begin)
                       (rest end))))))

(define-core-macro for-each (_ clauses end #rest body)
  (bind ((clauses
          (map (method (clause)
                 (concatenate [(generate-symbol)]
                              clause))
               clauses))
         (end? (generate-symbol))
         (values (generate-symbol))
         (result (generate-symbol))
         (body (concatenate
                `(begin
                  ;; rebind variables to create closure
                  ,(bind ((vars (map second clauses)))
                     (concatenate
                      `(,(concatenate `(method ,vars)
                                      ;; actual body
                                      body))
                      vars)))
                ;; update temporary collection bindings
                (map (method (clause)
                       `(set! ,(first clause)
                              (rest ,(first clause))))
                     clauses)
                `((set! ,values
                        ,(concatenate `(%array)
                                      (map first clauses)))))))
    ;; evaluate each collection once
    `(bind ,(concatenate
             (map (method (clause)
                    (destructuring-bind (temp var values) clause
                      [temp values]))
                  clauses)
             `((,end? #f)
               (,result #f)
               (,values ,(concatenate `(%array)
                                      (map first clauses)))))
       ;; check exhaustion
       (until (or ,end? (any? empty? ,values))
         ;; bind each var to next element
         (bind ,(map (method (clause)
                       (destructuring-bind (temp var values) clause
                         [var `(first ,temp)]))
                     clauses)
           ,(if-bind (end-test (first end))
              `(if ,end-test
                   (begin
                    (set! ,result
                          ,(maybe-begin
                            ;; execute all result expressions, returning last; false if none
                            (bind ((results (rest end)))
                              (if (empty? results)
                                  [#f]
                                  results))))
                    (set! ,end? #t))
                   ,body)
              body)))
       ,result)))

(define-core-macro bind-properties (_ properties object #rest body)
  (bind ((object* (generate-symbol)))
    (concatenate
     `(bind ,(concatenate
              `((,object* ,object))
              (map (method (property)
                     `(,property
                       (%get-property ,object*
                                      ,(symbol-name property))))
                   properties)))
     body)))

(define-core-macro select (_ value test #rest cases)
  (bind ((value* (generate-symbol))
         (test* (generate-symbol)))
    (bind-methods ((test-expression (test-value)
                     `(,test* ,value* ,test-value)))
      `(bind ((,value* ,value)
              (,test* ,test))
         ,(concatenate
           `(cond)
           (map (method (case)
                  (destructuring-bind (tests #rest then) case
                    (if (== tests else:)
                        case
                        (concatenate
                         `(,(concatenate
                             `(or)
                             (map test-expression tests)))
                         then))))
                cases))))))

(define-function destructure (bindings values body)
  (if (instance? values <symbol>)
      (destructuring-bind (required rest key)
          (analyze-lambda-list bindings)
        (bind ((i (size required)))
          (reduce (method (body binding)
                    (dec! i)
                    (if (instance? binding <symbol>)
                        `(bind ((,binding (element ,values ,i)))
                           ,body)
                        (destructure binding `(element ,values ,i) body)))
                  (wrap-rest/keys body
                                  values
                                  required rest key)
                  (reverse required))))
      ;; ensures values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var body)))))

(define-core-macro destructuring-bind (_ bindings values #rest body)
  (destructure bindings values
               (concatenate `(begin) body)))

(define-core-macro bind-methods (_ bindings #rest body)
  (concatenate
   `(bind ,(map first bindings))
   (map (method (binding)
          (destructuring-bind (name arguments #rest body)
              binding
            `(set! ,name ,(concatenate `(method ,arguments)
                                       body))))
        bindings)
   body))

(define-core-macro inc! (_ object value)
  `(set! ,object (+ ,object ,(or value 1))))

(define-core-macro dec! (_ object value)
  `(set! ,object (- ,object ,(or value 1))))


;; TODO: backend-specific
(define-core-macro call-next-method (_)
  `((%get-property next-method "apply")
    (%native "null")
    (%native "arguments")))

(define-function transform-quoted (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (if (member? (first exp)
                 [(symbol "%comma") (symbol "%backqoute")])
        (second exp)
        (concatenate `(%array)
                     (map transform-quoted
                          exp))))
   ((instance? exp <symbol>)
    `(symbol ,(symbol-name exp)))
   (else:
    exp)))

(define-core-macro %backquote (_ exp)
  (transform-quoted exp))

;; comma is only used as a marker and
;; actually handled in backquote
(define-core-macro %comma (_ value)
  (signal (make <error> message: "comma not inside backquote")))

(define *dot-name-error*
  (make <error>
        message: "unsupported name for call in dot"))

(define-core-macro . (_ value #rest calls)
  (reduce (method (value call)
            (destructuring-bind (name #rest arguments) call
              (concatenate
               `((%get-property ,value
                                ,(select name instance?
                                   ((<string>)
                                    name)
                                   ((<symbol>)
                                    (symbol-name name))
                                   (else:
                                    (signal *dot-name-error*)))))
               arguments)))
          value
          calls))

(define-function function-definer (macro-name definer-name
                                   #key type/existing? record?)
  (method (env function-name arguments #rest body)
    (destructuring-bind (setter? name)
        (if (setter-name? function-name)
            [#t (setter-symbol (second function-name))]
            [#f function-name])
      (unless (or (instance? name <symbol>)
                  setter?)
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "name not <var> or (setter <var>)"))))
      (when (and type/existing?
                 (empty? arguments))
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "method has no arguments"))))
      (destructuring-bind (required rest key)
          (analyze-lambda-list arguments)
        (bind ((required
                (map (method (argument)
                       (if (instance? argument <array>)
                           (first argument)
                           argument))
                     required))
               (method-definition
                (macroexpand-all
                 (concatenate `(method
                                   ,(concatenate
                                     required
                                     (if rest
                                         (concatenate `(#rest) rest)
                                         [])
                                     (if key
                                         (concatenate `(#key) key)
                                         [])))
                              body)
                 env)))
          (when record?
            (set! (get env "module" "functions"
                       (symbol-name name))
                  method-definition))
          ;; result
          `(define ,name
             ,(concatenate
               `(,(symbol definer-name)
                 (%native-name ,(symbol-name name))
                 ,method-definition
                 ,setter?)
               (if type/existing?
                   `(,(bind ((head (first arguments)))
                        (if (and (instance? head <array>)
                                 (> (size head) 1))
                            (second head)
                            (symbol "<object>")))
                     ,name)
                   []))))))))

(for-each ((arguments [["define-function" "%make-function"
                        type/existing?: #f
                        record?: #t]
                       ["define-method" "%make-method"
                        type/existing?: #t]]))
          ()
  (set! (get *core-macros* (first arguments))
        (apply function-definer arguments)))


(define-core-macro define-generic (_ name arguments)
  `(define ,name
     (%make-generic
      (%native-name ,(symbol-name name)))))

(define-core-macro define-class (_ name superclass #rest properties)
  (bind ((object `(%object)))
    (for-each ((property properties))
              ()
      (if (instance? property <array>)
          (begin
           (push-last object (symbol-name (first property)))
           (push-last object `(method ()
                                ,(second property))))
          (begin
           (push-last object (symbol-name property))
           (push-last object #f))))
    `(define ,name
       (%make-class
        ,(unless (empty? superclass)
           (first superclass))
        ,object))))

(define-core-macro define-module (env name #key (import []) (export [])
                                                (compile-time-import [])
                                                (inline []))
  ;; exports
  (set! (get env "module" "exports")
        (map (method (name)
               (if (setter-name? name)
                   (setter-symbol (second name))
                   name))
             export))
  ;; compile-time imports
  (do (method (import)
        (bind ((module-name (symbol-name
                             (if (instance? import <array>)
                                 (first import)
                                 import))))
          (compile-time-import-module
           env module-name
           names: (when (instance? import <array>)
                    (rest import)))))
      compile-time-import)
  ;; inline
  (set! (get env "module" "inline")
        inline)
  ;; imports
  (maybe-begin
   (map (method (import)
          (bind ((module-name (symbol-name
                               (if (instance? import <array>)
                                   (first import)
                                   import))))
            ;; TODO: support only:, except:, rename:, prefix:
            (import-module (get env "module") module-name
                           names: (when (instance? import <array>)
                                    (rest import)))
            (definition-for-import module-name env)))
        import)))

;; NOTE: requires module has been imported
(define-function definition-for-import (module-name env)
  (bind ((import-name (generate-symbol)))
    (set! (get env "import-names" module-name)
          import-name)
    `(define ,import-name
       ((%native "require") ,module-name))))

(define-core-macro define-macro (env name arguments #rest body)
  `(begin
    ,(concatenate `(define-function ,name
                     ,(concatenate `(,(generate-symbol))
                                   arguments))
                  body)
    (set! (%get-property ,name "%macro?") #t)))

(define-core-macro define-symbol-macro (env name arguments #rest body)
  `(begin
    ;; ignore arguments
    ,(concatenate `(define-function ,name ())
                  body)
    (set! (%get-property ,name "%symbol-macro?") #t)))


;; TODO: %try, %throw, block, handler-case
;; TODO: inline make-object
;;       (initialize with string keys, evaluate and set rest)

;;;; lift defines

;; replace defines with top-level %defines
;; and local assignments

(define-function lift-defines (exp env)
  (lift-define exp env identity))

(define-function lift-define (exp env k)
  (if (expression? exp)
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-define
            value env
            (method (lvalue env)
              (lift-define
               body env
               (method (lbody env)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    env)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-define
            e2 env
            (method (le2 env)
              (k `(,m ,e1 ,le2)
                 env)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-define*
            e* env
            (method (le* env)
              (k (concatenate [m] le*)
                 env)))))
        (("define")
         (destructuring-bind (_ var value export?) exp
           (bind ((name (symbol-name var)))
             (if (has? (get env "defined?") name)
                 (k `(%set ,var ,value)
                    env)
                 (begin
                  (set! (get env "defined?" name) #t)
                  `(%begin
                    (%define ,var)
                    ,(k `(%set ,var ,value)
                        env)))))))
        (else:
         (lift-define** exp env k)))
      (k exp env)))

(define-function lift-define* (exp* env k)
  (if (empty? exp*)
      (k [] env)
      (lift-define** exp* env k)))

(define-function lift-define** (exp env k)
  (lift-define
   (first exp) env
   (method (t env)
     (lift-define*
      (rest exp) env
      (method (t* env)
        (k (concatenate [t] t*)
           env))))))



;;;; symbol macros

;; utilities

(define *core-symbol-macros*
  (make-object))

(define-macro define-core-symbol-macro (name #rest definition)
  `(set! (get *core-symbol-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-core-symbol-macro next-method (_)
  `(%next-method %this-method))

;;;; macro expansion


(define-function macro-definition (form env)
  ;; TODO: deep-get
  (select form instance?
    ((<array>)
     (when (empty? form)
       (signal "Empty form"))
     (js:get-property env "macros" (symbol-name (first form))))
    ((<symbol>)
     (js:get-property env "symbol-macros" (symbol-name form)))))

(define-function macroexpand-1 (form env)
  (if-bind (macro (macro-definition form env))
    (apply macro env (if (instance? form <array>)
                         (rest form)
                         form))
    form))

(define-function macroexpand (form env)
  (bind ((done? #f))
    (until done?
      (bind ((expanded (macroexpand-1 form env)))
        (set! done? (== expanded form))
        (set! form expanded)))
    form))

(define-function macroexpand-all (form env)
  (select form instance?
    ((<array>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         (if-bind (expander (special-form-definition form env))
           (apply expander env (rest form))
           (map (rcurry macroexpand-all env)
                form))))
    ((<symbol>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         form))
    (else: form)))



;;;; define free variables

;; TODO: clean up, imported name is symbol
(define-function find-module-for-definition (definition-name env)
  (any? (method (import)
          (destructuring-bind (module-name names) import
            ;; TODO: names symbols?
            (when (member? definition-name names)
              (get *modules* module-name))))
        (get env "module" "imports")))

(define-function find-import-name (definition-name env)
  (if-bind (module (find-module-for-definition
                    definition-name env))
    (get env "import-names" (get module "name"))))

(define-function define-free-variables (exp env)
  (bind ((variables
          (set-subtract!
           (set-subtract!
            (free-variables exp)
            (as-set (map symbol
                         (keys (get env "defined?")))))
           *defined?*)))
    (if (empty? variables)
        exp
        (concatenate
         `(%begin)
         (map (method (variable)
                (bind ((name (symbol-name variable)))
                  (set! (get env "defined?" name) #t)
                  (maybe-begin
                   (concatenate
                    `((%define ,variable))
                    ;; imported?
                    (if-bind (import-name (find-import-name variable env))
                      `((%set ,variable (%get-property ,import-name ,name)))
                      [])))))
              variables)
         [exp]))))


(define-function define-free-variables2 (exp env)
  (bind ((variables (choose
                     (method (variable)
                       (not (has? (get env "definition-names")
                                  (symbol-name variable))))
                     (set-subtract! (free-variables exp)
                                    *defined?*))))
    (if (empty? variables)
        exp
        (concatenate
         `(%begin)
         (map (method (variable)
                (bind ((name (symbol-name variable)))
                  (set! (get env "defined?" name) #t)
                  (maybe-begin
                   (concatenate
                    `((%define ,variable))
                    ;; imported?
                    (if-bind (old-import-name (find-import-name variable env))
                      (bind ((import-name (symbol (get env "new-definition-names"
                                                       (symbol-name old-import-name)))))
                        `((%set ,variable (%get-property ,import-name ,name))))
                      [])))))
              variables)
         [exp]))))

(define-function free-variables (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (bind ((head (first exp))
           (name (and (instance? head <symbol>)
                      (symbol-name head))))
      (select name ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (set-subtract!
            (free-variables body)
            (as-set arguments))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           ;; TODO: make binding available inside value?
           ;; (if so, also change alpha-convert)
           (set-union!
            (set-subtract!
             (free-variables body)
             (as-set [var]))
            (free-variables value))))
        (("%begin")
         ;; %define will only appear in %begin,
         ;; see previous pass lift-defines
         (bind ((definitions []))
           (set-subtract!
            (as-set
             (reduce (method (result e)
                       (concatenate
                        result
                        (if (and (expression? e)
                                 (== (first e)
                                     (symbol "%define")))
                            (begin
                             (push-last definitions (second e))
                             [])
                            (free-variables e))))
                     [] (rest exp)))
            (as-set definitions))))
        (("%set" "%if" "%while"
          "%array" "%object" "%infix"
          "%get-property" "%native-call")
         (as-set (reduce concatenate []
                         (map free-variables
                              (rest exp)))))
        (("%native" "%native-name" "%define")
         (as-set []))
        (else:
         (reduce1 set-union!
                  (map free-variables
                       exp))))))
   ((instance? exp <symbol>)
    (as-set [exp]))
   (else:
    (as-set []))))


;;;; alpha conversion

;; "names" => module name => symbol name => renaming+

(define-function ensure-naming-structure (env variable-module variable-name)
  ;; ensure renaming object for env
  (unless (get env "names" variable-module)
    (set! (get env "names" variable-module)
          (make-object)))
  ;; ensure renaming list for variable
  (bind ((module-renamings (get env "names" variable-module)))
    (unless (get module-renamings variable-name)
      (set! (get module-renamings variable-name)
            [])))
  env)

(define-function rename-variables (variables env)
  (map (method (variable)
         (bind ((variable-module (or (get variable "module") ""))
                (variable-name (symbol-name variable))
                (new-variable (generate-symbol)))
           (ensure-naming-structure
            env variable-module variable-name)
           (push (get env "names"
                      variable-module variable-name)
                 new-variable)
           new-variable))
       variables))

(define-function restore-variables (variables env)
  (for-each ((variable variables))
            ()
    (bind ((variable-module (or (get variable "env")
                                ""))
           (variable-name (symbol-name variable)))
      (pop (get env "names"
                variable-module variable-name)))))

(define *not-found* (make-object))

(define-function find-variable (variable env)
  (bind ((variable-module (or (get variable "module")
                              ""))
         (variable-name (symbol-name variable)))
    (if-bind (renamings (get env "names"
                             variable-module variable-name))
      (first renamings)
      *not-found*)))

(define-function alpha-convert (form env)
  (select form instance?
    ((<array>)
     (select (symbol-name (first form)) ==
       (("%method")
        (destructuring-bind (_ arguments body) form
          (bind ((new-arguments
                  (rename-variables arguments env)))
            (set! (second form)
                  new-arguments)
            (set! (last form)
                  (alpha-convert body env))
            (restore-variables arguments env)
            form)))
       (("%bind")
        (destructuring-bind (_ (var value) body) form
          ;; TODO: make binding available inside value?
          ;; (if so, also change define-free-variables)
          (bind ((new-value (alpha-convert value env)))
            (destructuring-bind (new-var)
                (rename-variables [var] env)
              (bind ((result
                      `(%bind (,new-var ,new-value)
                         ,(alpha-convert body env))))
                (restore-variables [var] env)
                result)))))
       (("%define")
        ;; rename in future expression
        ;; NOTE: modifies env!
        (destructuring-bind (_ variable) form
          (bind ((variable-module (or (get variable "module")
                                      ""))
                 (variable-name (symbol-name variable))
                 (new-variable (generate-symbol)))
            ;; TODO: refactor
            ;; >>>
            (ensure-naming-structure env variable-module variable-name)
            (push-last (get env "names" variable-module variable-name)
                       new-variable)
            ;; register renaming of definition
            (set! (get env "definition-names"
                       (symbol-name new-variable))
                  variable-name)
            (set! (get env "new-definition-names"
                       variable-name)
                  (symbol-name new-variable))
            ;; <<<
            ;; update form
            (set! (second form)
                  new-variable)
            form)))
       (else:
        (map (rcurry alpha-convert env)
             form))))
    ((<symbol>)
     (bind ((value (find-variable form env)))
       (if (== value *not-found*)
           form
           value)))
    (else: form)))

;;;; beta reduction

;; ((L (x y) (+ x y)) a (+ a 1))
;; => ((L (y) (+ a y)) (+ a 1))

;; (define-function substitute-variables (variables new-variables env)
;;   (bind ((env (wrap-object env)))
;;     (for-each ((variable variables)
;;                (new-variable new-variables))
;;               ()
;;       (set! (get env (symbol-name variable))
;;             new-variable))
;;     env))


;;;; TODO: eliminate
;;;; ((L () X)) => X
;;;; (begin 1) => 1

;;(define-function beta-reduce (form env)
;;  (select form instance?
;;    ((<array>)
;;     ;; TODO: bind
;;     (if (and (instance? (first form) <array>)
;;              (== (symbol-name (first (first form))) "%method"))
;;         (destructuring-bind ((_ arguments #rest body) #rest values)
;;             form
;;           ;; TODO: maybe also support constant values (numbers, etc.)
;;           (bind ((variables [])
;;                  (new-variables [])
;;                  (new-arguments [])
;;                  (new-values []))
;;             (for-each ((argument arguments)
;;                        (value values))
;;                 ()
;;               (if (atomic? value)
;;                   (begin
;;                    (push-last variables argument)
;;                    (push-last new-variables value))
;;                   (begin
;;                    (push-last new-arguments argument)
;;                    (push-last new-values value))))
;;             (bind ((env (substitute-variables variables new-variables env)))
;;               (concatenate `(,(concatenate `(%method ,new-arguments)
;;                                            (beta-reduce body env)))
;;                            new-values))))
;;         (map (rcurry beta-reduce env)
;;              form env)))
;;    ((<symbol>)
;;     ... (find-variable form env)
;;        ... form
;;    (else: form)))



;;; inlining

(define-function inline (form env)
  (if (and (instance? form <array>)
           (not (empty? form)))
      (if (instance? (first form) <symbol>)
          (select (symbol-name (first form)) ==
            ;; inline only last
            (("%method" "%set")
             (set! (last form)
                   (inline (last form) env))
             form)
            (("%bind")
             (destructuring-bind (_ binding body) form
               (set! (second binding)
                     (inline (second binding) env))
               (set! (last form)
                     (inline body env))
               form))
            ;; inline all arguments
            (("%begin" "%if" "%while" "%array" "%object"
              "%get-property" "%native-call" "%infix")
             (concatenate [(first form)]
                          (map (rcurry inline env)
                               (rest form))))
            ;; no inlining
            (("%native" "%native-name" "%define")
             form)
            ;; application of function with name
            (else:
             (bind ((name (symbol-name (first form)))
                    (definition-name (or (get env "definition-names" name)
                                         name))
                    (definition
                      ;; local definition?
                      (or (when (inline? (get env "module")
                                         definition-name)
                            (get env "module" "functions"
                                 definition-name))
                          ;; imported definition?
                          (if-bind (module (find-module-for-definition
                                            (symbol definition-name)
                                            env))
                            (when (inline? module definition-name)
                              (get module "functions"
                                   definition-name))))))
               (if definition
                   (inline-definition definition (rest form) env)
                   ;; normal call
                   (map (rcurry inline env)
                        form)))))
          ;; application of expression, can't be inlined
          (map (rcurry inline env)
               form))
      ;; not an array
      form))

(define-function inline? (module definition-name)
  (any? (method (name)
          (== (symbol-name name)
              definition-name))
        (get module "inline")))

(define-function inline-definition (definition values env)
  ;; TODO: rest and keyword parameters?
  ;; inlines definition itself and inlines values before., e.g. (not (not ...))
  (bind ((inlined-definition (inline definition env)))
    (destructuring-bind (_ arguments #rest body) inlined-definition
        (bind ((actual-arguments (map (method (argument)
                                        (if (instance? argument <array>)
                                            (first argument)
                                            argument))
                                      arguments)))
          ;; create initial bindings
          (dotimes (i (size actual-arguments))
            (bind ((argument (element actual-arguments i))
                   (value (element values i))
                   (argument-module (or (get argument "module") ""))
                   (argument-name (symbol-name argument)))
              (ensure-naming-structure
               env argument-module argument-name)
              (push (get env "names" argument-module argument-name)
                    (if value
                        (inline value env)
                        `(%native "undefined")))))
          ;; rename
          (bind ((result (alpha-convert (maybe-begin body) env)))
            (restore-variables actual-arguments env)
            result)))))


;;;; ANF

(define-function atomic? (expression)
  (any? (curry instance? expression)
        [<number> <boolean> <string> <symbol> <keyword>]))

(define-function normalize-term (expression)
  (normalize expression identity))

(define-function normalize (exp k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (k `(%method ,arguments
                 ,(normalize-term body)))))
        (("%begin")
         (destructuring-bind (_ exp1 #rest e*) exp
           (if (empty? e*)
               (normalize exp1 k)
               (normalize
                exp1 (method (aexp1)
                       `(%begin
                         ,aexp1
                         ,(normalize (concatenate
                                      `(%begin) e*)
                                     k)))))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (normalize
            value (method (avalue)
                   `(%bind (,var ,avalue)
                      ,(normalize body k))))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           (normalize-value
            test (method (atest)
                   (k `(%if ,atest
                            ,(normalize-term then)
                            ,(normalize-term else)))))))
        (("%while")
         (destructuring-bind (_ test body) exp
           (k (if (contains-statements? test)
                  `(%while #t
                     (%begin
                      ,(normalize-term
                        `(%if ,test
                              ,(normalize-term body)
                              (%native "break")
                              #f))))
                  `(%while
                    ,(normalize-term test)
                    ,(normalize-term body))))))
        (("%set")
         (destructuring-bind (_ var value) exp
           (normalize-value
            value (method (avalue)
                   (k `(%set ,var ,avalue))))))

        (else:
         (if (contains-statements? exp)
             (normalize-all exp k)
             (k (map normalize-term exp)))))
      (k exp)))

(define-function normalize-value (exp k)
  (if (contains-statements? exp)
      (normalize-name exp k)
      (k (if (instance? exp <array>)
             (map normalize-term exp)
             exp))))

(define-function contains-statements? (exp)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%begin" "%if" "%while" "%bind") #t)
        (("%set")
         (contains-statements? (last exp)))
        (("%method") #f)
        (else:
         (any? contains-statements? exp)))
      #f))

(define-function normalize-name (exp k)
  (normalize
   exp (method (aexp)
         (if (atomic? aexp)
             (k aexp)
             (bind ((t (generate-symbol)))
               `(%bind (,t ,aexp)
                  ,(k t)))))))

(define-function normalize-name* (exp* k)
  (if (empty? exp*)
      (k [])
      (normalize-all exp* k)))

(define-function normalize-all (exp k)
  (normalize-name
   (first exp) (method (t)
                 (normalize-name*
                  (rest exp) (method (t*)
                               (k (concatenate [t] t*)))))))


;;;; statements

;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

;; NOTE: wrap-value, transform-statements and
;; flatten-statements are destructive!
;; => mutation of expressions reduces consing

(define-function wrap-value (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap then and else
         (set! (third exp)
               (wrap-value (third exp) wrapper))
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value #f wrapper)))
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function add-explicit-return (exp)
  (wrap-value exp `(%return)))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment:
;; (%bind ($1 (%if ... (%bind ($2 ...) (foo $2) ...))) (bar $1 baz))
;; => (%bind ($1 #f)
;;      (%begin
;;       (%if ...
;;            (%bind ($2 ...)
;;              (set! $1 (foo $2)))
;;            ...)
;;       (bar $1 baz)))

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind))))


(define-function add-explicit-true (exp)
  `((%native "$T") ,exp))

(define-function transform-statements (exp env)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method")
         (set! (last exp)
               (add-explicit-return
                (transform-statements (last exp)
                                      env)))
         exp)
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (maybe-begin
            (map (rcurry transform-statements env)
                 exps))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (if (statement? value)
               `(%bind (,var #f)
                  (%begin
                   ,(wrap-value
                     (transform-statements value env)
                     `(%set ,var))
                   ,(transform-statements body env)))
               `(%bind (,var
                        ,(transform-statements value env))
                  ,(transform-statements body env)))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           `(%if
             ;; TODO: only if not boolean
             ,(add-explicit-true test)
             ,(transform-statements then env)
             ,(transform-statements else env))))
        (("%while")
         (set! (second exp)
               (add-explicit-true (second exp)))
         (set! (third exp)
               (transform-statements (third exp) env))
         exp)
        (("%set")
         (destructuring-bind (_ name value) exp
           (bind ((value* (transform-statements value env))
                  (definition-name
                    (get env "definition-names"
                         (symbol-name name))))
             ;; check if exported definition
             (if (and definition-name
                      (member? (symbol definition-name)
                               (get env "module" "exports")))
               (begin
                (set! (first exp) (symbol "%begin"))
                (set! (second exp)
                      `(%set ,name ,value*))
                (set! (third exp)
                      `(%set (%get-property (%native "exports")
                                            ,definition-name)
                             ,name)))
               ;; no re-export, leave as is
               (set! (third exp) value*))))
         exp)
        (("%define")
         `(%var (,(last exp) #f)))
        (else:
         (map (rcurry transform-statements env) exp)))
      exp))



;;;; symbol lifting

(define-function lift-symbols (exp env)
  (lift-symbol exp env identity))

(define-function lift-symbol (exp env k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-symbol
            value env
            (method (lvalue env)
              (lift-symbol
               body env
               (method (lbody env)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    env)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-symbol
            e2 env
            (method (le2 env)
              (k `(,m ,e1 ,le2)
                 env)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-symbol*
            e* env
            (method (le* env)
              (k (concatenate [m] le*)
                 env)))))
        ;; TODO: fix, already renamed
        (("symbol")
         (destructuring-bind (_ name) exp
           (lift-value
            name exp "symbol" env k)))
        (else:
         (lift-symbol** exp env k)))
      (select exp instance?
        ((<keyword>)
         (lift-value
          (symbol-name exp) exp "keyword" env k))
        ((<hash-symbol>)
         (lift-value
          (symbol-name exp) exp "hash" env k))
        (else:
         (k exp env)))))

(define-function lift-value (name value type env k)
  (if-bind (t (get env "lifted" type name))
    (k t env)
    (bind ((t (set! (get env "lifted" type name)
                    (generate-symbol))))
      `(%bind (,t ,value)
         ,(k t env)))))

(define-function lift-symbol* (exp* env k)
  (if (empty? exp*)
      (k [] env)
      (lift-symbol** exp* env k)))

(define-function lift-symbol** (exp env k)
  (lift-symbol
   (first exp) env
   (method (t env)
     (lift-symbol*
      (rest exp) env
      (method (t* env)
        (k (concatenate [t] t*)
           env))))))


;;;; flatten-statements

(define-function flatten-begins (exps)
  (reduce1 concatenate
           (map (method (exp)
                  (bind ((flattened (flatten-statements exp)))
                    (if (and (instance? flattened <array>)
                             (not (empty? flattened))
                             (== (first flattened)
                                 (symbol "%begin")))
                        (rest flattened)
                        [flattened])))
                exps)))

(define-function var? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%var"))))

(define-function set? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%set"))))

(define-function method? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%method"))))

(define-function flatten-vars (exps)
  (reduce (method (result exp)
            (bind ((previous (and (not (empty? result))
                                  (last result)))
                   (previous-var? (and previous
                                       (var? previous))))
              (if (and previous-var? (var? exp))
                  ;; add current bindings to previous
                  (begin
                   (do (method (binding)
                         (push-last (last result)
                                    binding))
                       (rest exp))
                   result)
                  ;; add assignment to previous binding?
                  (bind ((merge? (and previous-var? (set? exp)))
                         (binding (and merge? (last (last result))))
                         (name (and merge? (second exp))))
                    (if (== (first binding)
                            name)
                        (begin
                         (set! (second binding)
                               (third exp))
                         result)
                        (concatenate result [exp]))))))
          [] exps))

(define-function flatten-statements (exp)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method" "%while" "%set")
         (set! (last exp)
               (flatten-statements (last exp)))
         exp)
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (maybe-begin
            (flatten-vars
             (flatten-begins exps)))))
        (("%bind")
         (destructuring-bind (_ binding body) exp
           (flatten-statements
            `(%begin
              (%var ,binding)
              ,body))))
        (("%if")
         (set! (third exp)
               (flatten-statements (third exp)))
         (set! (last exp)
               (flatten-statements (last exp)))
         exp)
        (else:
         (map flatten-statements exp)))
      exp))



;;;; compilation to JS

(define *escaped*
  (make-object
   "\"" "\""
   "\\" "\\"
   "\b" "b"
   "\f" "f"
   "\n" "n"
   "\r" "r"
   "\v" "v"
   "\t" "t"))

(define-function fill-zeros (string)
  (concatenate
   (slice "0000" 0 (- 4 (size string)))
   string))

(define-function escape-string (string)
  (join (map (method (char)
               (if-bind (escaped (get *escaped* char))
                 (concatenate "\\" escaped)
                 (bind ((code (char-code char)))
                   (if (< 0x1f code 0x7f)
                       char
                       (concatenate
                        "\\u" (fill-zeros (as-hex-string code)))))))
             (as-array string))
        ""))

(define *reserved*
  ["break" "case" "catch" "continue" "default" "delete" "do" "else"
   "finally" "for" "function" "if" "in" "instanceof" "new" "return"
   "switch" "this" "throw" "try" "typeof" "var" "void" "while"
   "with" "abstract" "boolean" "byte" "char" "class" "const"
   "debugger" "double" "enum" "export" "extends" "final" "float"
   "goto" "implements" "import" "int" "interface" "long" "native"
   "package" "private" "protected" "public" "short" "static" "super"
   "synchronized" "throws" "transient" "volatile" "null" "true" "false"
   "arguments" "object" "number" "string" "array" "let" "yield"])

(define *symbol-escapes*
  (make-object
   "-" "_"
   "_" "__"
   "&" "A"
   "$" "B"
   ":" "C"
   "." "D"
   "=" "E"
   "^" "F"
   ">" "G"
   "#" "H"
   "@" "I"
   "~" "J"
   ;; K: keyword
   "<" "L"
   "%" "M"
   "!" "N"
   ;; O
   "+" "P"
   "?" "Q"
   ;; R: reserved
   "/" "S"
   "*" "T"
   ;; U, V, W, X, Y
   ;; Z: any other
   ))

(define-function escape-symbol-name (name)
  (if (member? name *reserved*)
      (concatenate "R" name)
      (bind ((chars
              (map (method (char)
                     (cond
                      ((has? *symbol-escapes* char)
                       (get *symbol-escapes* char))
                      ((match "\\w" char)
                       char)
                      (else:
                       (concatenate
                        "Z" (as-string (char-code char))))))
                   (as-array name))))
        (join chars ""))))

(define-function valid-identifier? (identifier)
  (and (not (member? identifier *reserved*))
       (match "^\\w+$" identifier)))

(define-function compile-js (exp env)
  (select exp instance?
    ((<array>)
     (if (empty? exp)
         (signal (make <error> message: "empty expression"))
         (compile-js-exp exp env)))
    ((<number>)
     (as-string exp))
    ((<boolean>)
     (if exp "true" "false"))
    ((<string>)
     (concatenate "\"" (escape-string exp) "\""))
    ((<hash-symbol>)
     (concatenate
      "$" (as-uppercase (symbol-name exp))))
    ((<keyword>)
     (concatenate
      "$K(\"" (symbol-name exp)  "\")"))
    ((<symbol>)
     (select exp ==
       (((symbol "%this-method"))
        (compile-js (get env "current-method")
                    env))
       (((symbol "%all-arguments"))
        "arguments")
       (else:
        (if (get exp "generated?")
            (symbol-name exp)
            (escape-symbol-name
             (symbol-name exp))))))
    (else:
     (description exp))))

;; TODO: document as language

(define-function compile-js-exp (exp env)
  (bind ((name (symbol-name (first exp))))
    (select name ==
      (("%native-call")
       (destructuring-bind (_ operator #rest values) exp
         (concatenate
          operator (compile-js-call values env))))
      (("%infix")
       (destructuring-bind (_ operator #rest values) exp
         (concatenate
          "(" (join (map (rcurry compile-js env)
                         values)
                    (concatenate
                     " " operator " "))
          ")")))
      (("%array")
       (destructuring-bind (_ #rest elements) exp
         (concatenate
          "[" (join (map (rcurry compile-js env)
                         elements)
                    ", ")
          "]")))
      (("%object")
       (bind ((key-values (rest exp))
              (entries []))
         (dotimes (i (/ (size key-values) 2))
           (push-last entries
                      (concatenate
                       (bind ((name (element key-values (* i 2))))
                         (if (valid-identifier? name)
                             name
                             (compile-js name env)))
                       ":" (compile-js
                            (element key-values (+ (* i 2) 1))
                            env))))
         (concatenate
          "{" (join entries ",\n") "}")))
      (("%if")
       (destructuring-bind (_ test then else) exp
         (concatenate
          "if (" (compile-js test env) ")\n"
          (compile-js then env)
          ;; optimization: default is false
          (if (and else
                   (not (= else `(%return #f))))
              (concatenate
               "\nelse " (compile-js else env))
              ""))))
      (("%while")
       (destructuring-bind (_ test body) exp
         (concatenate "while (" (compile-js test env) ")\n"
                      (compile-js body env))))
      (("%return")
       (concatenate
        "return " (compile-js (second exp) env)))
      (("%begin")
       (concatenate
        "{" (join (map (rcurry compile-js env)
                       (rest exp))
                  ";\n")
        "}"))
      (("%set")
       (destructuring-bind (_ var value) exp
         (concatenate
          (compile-js var env) " = "
          (compile-js value env))))
      (("%method")
       (destructuring-bind (_ arguments body) exp
         (bind ((name (generate-symbol))
                (previous-method (get env "current-method")))
           (concatenate
            "function " (compile-js name env)
            " (" (join (map (rcurry compile-js env)
                            arguments)
                       ", ")
            ")\n"
            (begin
             (set! (get env "current-method") name)
             (bind ((body* (compile-js body env)))
               (set! (get env "current-method") previous-method)
               (if (and (expression? body)
                        (== (first body) (symbol "%begin")))
                   body*
                   (concatenate "{" body* "}"))))))))
      (("%var")
       (destructuring-bind (_ #rest bindings) exp
         (concatenate
          "var "
          (join (map (method (binding)
                       (destructuring-bind (var value)
                           (if (instance? binding <array>)
                               binding
                               [binding #f])
                         (concatenate
                          (compile-js var env)
                          (if value
                              (concatenate
                                " = " (compile-js value env))
                              ""))))
                     bindings)
                ", "))))
      (("%native")
       (reduce1 concatenate
                (map (method (e)
                       (if (instance? e <symbol>)
                           (symbol-name e)
                           (as-string e)))
                     (rest exp))))
      (("%native-name")
       (concatenate
        "\"" (escape-symbol-name (second exp)) "\""))
      (("%get-property")
       (destructuring-bind (_ object #rest properties) exp
         (concatenate
          (if (instance? object <number>)
              (concatenate "(" (compile-js object env) ")")
              (compile-js object env))
          (reduce (method (result property)
                    (concatenate
                     result
                     (if (and (instance? property <string>)
                              (valid-identifier? property))
                         (concatenate "." property)
                         (concatenate "[" (compile-js property env) "]"))))
                  "" properties))))
      (else:
       (destructuring-bind (function #rest values) exp
         (concatenate
          (bind ((function* (compile-js function env)))
            (if (method? function)
                (concatenate "(" function* ")")
                function*))
          (compile-js-call values env)))))))

(define-function compile-js-call (values env)
  (concatenate
   "(" (join (map (rcurry compile-js env)
                  values)
             ", ")
   ")"))


;;;;

(define-function read-program (source)
  (read (make <string-stream>
              string: (concatenate "(" source "\n)"))))

(define-function compile-expression (exp env)
  (reduce (method (result name/fn)
            (destructuring-bind (name fn) name/fn
;;              (format-out "### %s:\n" name)
              (bind ((result (fn result)))
;;                (format-out "%=\n" result)
                result)))
          exp
          [["source" identity]
           ["macroexpanded"
            (rcurry macroexpand-all env)]
           ["lifted defines"
            (rcurry lift-defines env)]
           ["defined free variables"
            (rcurry define-free-variables env)]
           ["alpha-converted"
            (rcurry alpha-convert env)]
           ["inline"
            (rcurry inline env)]
           ["defined free variables after inline"
            (rcurry define-free-variables2 env)]
           ["ANF"
            normalize-term]
           ["lifted symbols"
            (rcurry lift-symbols env)]
           ["statements"
            (rcurry transform-statements env)]
           ["flattened"
            flatten-statements]
           ["compiled"
            (rcurry compile-js env)]]))

;;;;

(define path (require "path"))
(define fs (require "fs"))
(define vm (require "vm"))

(define-function ensure-directory (directory)
  (bind ((parent (. path ("dirname" directory))))
    (unless (. path ("existsSync" parent))
      (ensure-directory parent))
    (unless (. path ("existsSync" directory))
      (. fs ("mkdirSync" directory)))))

(define-function executable-path (module-name)
  (. path ("resolve" "output"
           (concatenate module-name ".js"))))

(define-function module-path (module-name)
  (. path ("resolve" "output"
           (concatenate module-name ".rm"))))

(define-function source-path (module-name)
  (. path ("resolve" "src"
           (concatenate module-name ".ralph"))))


(define-function recompile? (module-name)
  (bind ((p (executable-path module-name)))
    (or (not (. path ("existsSync" p)))
        (bind ((p2 (source-path module-name)))
          (< (get (. fs ("statSync" p)) "mtime")
             (get (. fs ("statSync" p2)) "mtime"))))))


(define-function compile-time-import-module (env module-name #key names)
  (destructuring-bind (macros symbol-macros)
      (if (== module-name "ralph2/core")
          [*core-macros* *core-symbol-macros*]
          (begin
           ;; ensure latest version is compiled
           (compile-module module-name)
           (bind ((definitions (require module-name))
                  (macros (make-plain-object))
                  (symbol-macros (make-plain-object)))
             (do (method (name)
                   (bind ((definition (get definitions name)))
                     (cond
                      ((get definition "%macro?")
                       (set! (get macros name)
                             definition))
                      ((get definition "%symbol-macro?")
                       (set! (get symbol-macros name)
                             definition)))))
                 (if names
                     (map symbol-name names)
                     (keys definitions)))
             [macros symbol-macros])))
    (chain-object (get env "macros")
                  macros)
    (chain-object (get env "symbol-macros")
                  symbol-macros)))

(define-function import-module (module module-name #key names)
  ;; TODO: open database first
  (bind ((other-module (find-module module-name))
         (names (or names
                    (get other-module "exports"))))
    (push (get module "imports")
          [module-name names])
    other-module))

(define-function find-module (module-name)
  (or (compile-module module-name)
      (get *modules* module-name)
      (read-module module-name)))

(define-function read-module (module-name)
  (bind ((p (module-path module-name)))
    (when (. path ("existsSync" p))
      (apply (curry make <module> name:)
             (read (make <string-stream>
                         string: (read-file p)))))))

(define-function read-file (path)
  (. fs ("readFileSync" path)
     ("toString")))

(define-function open-executable (module-name)
  (bind ((p (executable-path module-name)))
    (ensure-directory (. path ("dirname" p)))
    (. fs ("openSync" p "w"))))

(define-function compile-module (module-name)
  (when (and (not (has? *modules* module-name))
             ;; TODO: (recompile? module-name)
             #t)
    (bind ((module (make <module> name: module-name))
           (env (make <environment> module: module))
           (source (read-file (source-path module-name)))
           (program (read-program source))
           (executable (open-executable module-name)))
      (set! (get *modules* module-name)
            module)
      (compile-time-import-module env "ralph2/core")
      ;; special case core?
      (unless (== module-name "ralph2/core")
        ;; implicitly import and load core
        (import-module module "ralph2/core")
        (push program
              (definition-for-import "ralph2/core" env)))
      ;; compile
      (do (method (expression)
            (. fs ("writeSync" executable
                   (concatenate
                    (compile-expression expression env)
                    "\n"))))
          program)
      (. fs ("closeSync" executable))
      ;; write module
      (. fs ("writeFileSync" (module-path module-name)
             ;; ignore imports for now
             (description [module-name
                           exports: (get module "exports")])))
      module)))

;;;;

(bind ((start (make <date>)))
  (compile-module "ralph2/runtime.test")
  (format-out "%d\n" (- (make <date>) start)))
