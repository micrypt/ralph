
;; TODO: change imports to ralph2 when self-hosting

(define-module ralph2/compiler
  import: (ralph/core ralph/format ralph/regexp ralph/reader ralph/date)
  export: (<environment> macroexpand-1
                         macroexpand
                         macroexpand-all
                         alpha-convert
                         reset-symbol-counter!
                         atomic?
                         normalize-term))

;; TODO: cleanup

;; TODO: define-macro, %macro!
;; TODO: hygienic expansion:
;;       - rename symbols before passing to expander
;;       - rename after expansion
;;       - lift external references
;; TODO: inlining, %inline!
;; TODO: constant propagation, constant folding
;; TODO: dead code elimination
;; TODO: fix form/env naming convention

;; TODO: signal warning in define-free-variables

;; TODO: fix calling behaviour: var x = y.foo; x() VS y.foo()
;;       problematic when normalization binds %get-property
;;       => .bind?

;; NOTE: no symbol expansion after macroexpand-all,
;;       as ANF uses atomic? to decide if expression
;;       has side-effects and needs to be normalized
;;       (influences evaluation order)



;;;; modules

;; holds informations about all modules:
;; name => <module>

(define *modules* (make-object))

;;;; utilities

(define-function expression? (form)
  (and (instance? form <array>)
       (not (empty? form))
       (instance? (first form) <symbol>)))

(define-function setter-symbol (name)
  (symbol (concatenate (symbol-name name) "-setter")))

(define-function setter-name? (name)
  (and (instance? name <array>)
       (== (size name) 2)
       (every? (rcurry instance? <symbol>) name)
       (== (symbol-name (first name)) "setter")))

(define *symbol-count* 0)

(define-function reset-symbol-counter! ()
  (set! *symbol-count* 0))

(define-function generate-symbol ()
  (bind ((name (concatenate "$" (as-string (inc! *symbol-count*))))
         (result (symbol name)))
    (set! (get result "generated?") #t)
    result))

;;;; special forms

;; utilities

(define *special-forms*
  (make-object))

(define-function special-form-definition (form env)
  (get *special-forms* (symbol-name (first form))))

(define-macro define-special-form (name #rest definition)
  `(set! (get *special-forms* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-special-form
  %method (env arguments body)
  `(%method ,arguments
     ,(macroexpand-all body env)))

(define-special-form
  %set (env name value)
  `(%set ,name ,(macroexpand-all value env)))

(define-special-form
  define (env name value)
  `(define ,name ,(macroexpand-all value env)))

(define-special-form
  %bind (env binding body)
  (destructuring-bind (var value) binding
    `(%bind (,var ,(macroexpand-all value env))
       ,(macroexpand-all body env))))

;;;; core macros

;; utilities

(define *core-macros*
  (make-object))

(define-macro define-core-macro (name #rest definition)
  `(set! (get *core-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

(define-function maybe-begin (expressions)
  (select (size expressions) ==
    ((0) #f)
    ((1) (first expressions))
    (else:
     (concatenate `(%begin)
                  expressions))))

;; => [required rest keys]
(define-function analyze-lambda-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function wrap (exp #rest wrappers)
  (reduce (method (result wrapper)
            (wrapper result))
          exp
          wrappers))

(define-function wrap-rest/keys (body all required rest key)
  (bind ((rest? rest)
         (rest (or rest
                   (unless (empty? key)
                     (generate-symbol)))))
    (wrap body
          (method (body)
            (if (empty? key)
                body
                (bind ((key-values
                        (map (method (binding)
                               (if (instance? binding <array>)
                                   binding
                                   [binding #f]))
                             key)))
                  `(bind-properties ,(map first key-values)
                       (%keys ,rest
                              ,(concatenate `(%object)
                                            (reduce1 concatenate
                                                     (map (method (key-value)
                                                            (destructuring-bind (key value)
                                                                key-value
                                                              [(symbol-name key) value]))
                                                          key-values))))
                     ,body))))
          (method (body)
            (if (or rest? (not (empty? key)))
                `(bind ((,rest (%slice ,all ,(size required))))
                   ,body)
                body)))))

;; definitions

(define-core-macro begin (_ #rest expressions)
  (maybe-begin expressions))

(define-core-macro method (_ arguments #rest body)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    `(%method ,required
       ,(wrap-rest/keys
         (maybe-begin body)
         (symbol "%all-arguments")
         required rest key))))


(define-core-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (maybe-begin body)
      (reduce (method (body binding)
                `(%bind
                  ,(if (instance? binding <symbol>)
                       `(,binding #f)
                       binding)
                  ,body))
              (maybe-begin body)
              (reverse bindings))))

(define-core-macro if (_ test then else)
  `(%if ,test ,then ,else))

(define-core-macro set! (_ place #rest rest)
  (if (and (instance? place <array>)
           (not (== (first place)
                    (symbol "%get-property"))))
      (concatenate `(,(setter-symbol (first place)))
                   (rest place)
                   rest)
      `(%set ,place ,(first rest))))


(define-core-macro parallel-set! (_ var value #rest clauses)
  (if (empty? clauses)
      `(set! ,var ,value)
      (bind ((temp (generate-symbol)))
        `(bind ((,temp ,value))
           ,(concatenate `(parallel-set!)
                         clauses)
           (set! ,var ,temp)))))


(define-core-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (maybe-begin then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-core-macro when (_ test #rest body)
  `(if ,test
       ,(maybe-begin body)
       #f))

(define-core-macro unless (_ test #rest body)
  `(if (not ,test)
       ,(maybe-begin body)
       #f))

(define-core-macro and (_ #rest values)
  (select (size values) ==
    ((0) #t)
    ((1) (first values))
    (else: `(when ,(first values)
              ,(concatenate `(and)
                            (rest values))))))

(define-core-macro or (_ #rest values)
  (select (size values) ==
    ((0) #f)
    ((1) (first values))
    (else:
     (bind ((value (generate-symbol)))
       `(bind ((,value ,(first values)))
          (if ,value
              ,value
              ,(concatenate `(or)
                            (rest values))))))))

(define-core-macro if-bind (_ binding then else)
  (destructuring-bind (var value) binding
    (bind ((temp (generate-symbol)))
      `(bind ((,temp ,value))
         (if ,temp
             (bind ((,var ,temp))
               ,then)
             ,else)))))

(define-core-macro while (_ test #rest body)
  `(%while ,test
     ,(maybe-begin body)))

(define-core-macro until (_ test #rest body)
  (concatenate `(while (not ,test))
               body))

(define-core-macro dotimes (_ binding #rest body)
  (bind ((temp (generate-symbol)))
    (destructuring-bind (var count result) binding
      `(bind ((,temp ,count))
         ,(concatenate
           `(for ((,var 0 (+ ,var 1)))
                 ((>= ,var ,temp) ,(or result #f)))
           body)))))

(define-core-macro for (_ clauses end #rest body)
  (bind ((init-clauses [])
         (next-clauses [])
         (vars (map first clauses)))
    (for-each ((clause clauses))
              ()
      ;; init
      (push-last init-clauses
                 (slice clause 0 2))
      ;; next
      (push-last next-clauses
                 (first clause))
      (push-last next-clauses
                 (third clause)))
    `(bind ,init-clauses
       ,(concatenate `(while ,(or (empty? end)
                                  `(not ,(first end)))
                        ,(concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)
                        ,(concatenate `(parallel-set!)
                                      next-clauses)))
       ,(unless (empty? (rest end))
          (concatenate `(begin)
                       (rest end))))))

(define-core-macro for-each (_ clauses end #rest body)
  (bind ((clauses
          (map (method (clause)
                 (concatenate [(generate-symbol)]
                              clause))
               clauses))
         (end? (generate-symbol))
         (values (generate-symbol))
         (result (generate-symbol))
         (body (concatenate
                `(begin
                  ;; rebind variables to create closure
                  ,(bind ((vars (map second clauses)))
                     (concatenate
                      `(,(concatenate `(method ,vars)
                                      ;; actual body
                                      body))
                      vars)))
                ;; update temporary collection bindings
                (map (method (clause)
                       `(set! ,(first clause)
                              (rest ,(first clause))))
                     clauses)
                `((set! ,values
                        ,(concatenate `(%array)
                                      (map first clauses)))))))
    ;; evaluate each collection once
    `(bind ,(concatenate
             (map (method (clause)
                    (destructuring-bind (temp var values) clause
                      [temp values]))
                  clauses)
             `((,end? #f)
               (,result #f)
               (,values ,(concatenate `(%array)
                                      (map first clauses)))))
       ;; check exhaustion
       (until (or ,end? (any? empty? ,values))
         ;; bind each var to next element
         (bind ,(map (method (clause)
                       (destructuring-bind (temp var values) clause
                         [var `(first ,temp)]))
                     clauses)
           ,(if-bind (end-test (first end))
              `(if ,end-test
                   (begin
                    (set! ,result
                          ,(maybe-begin
                            ;; execute all result expressions, returning last; false if none
                            (bind ((results (rest end)))
                              (if (empty? results)
                                  [#f]
                                  results))))
                    (set! ,end? #t))
                   ,body)
              body)))
       ,result)))

(define-core-macro bind-properties (_ properties object #rest body)
  (bind ((object* (generate-symbol)))
    (concatenate
     `(bind ,(concatenate
              `((,object* ,object))
              (map (method (property)
                     `(,property
                       (%get-property ,object*
                                      ,(symbol-name property))))
                   properties)))
     body)))

(define-core-macro select (_ value test #rest cases)
  (bind ((value* (generate-symbol))
         (test* (generate-symbol)))
    (bind-methods ((test-expression (test-value)
                     `(,test* ,value* ,test-value)))
      `(bind ((,value* ,value)
              (,test* ,test))
         ,(concatenate
           `(cond)
           (map (method (case)
                  (destructuring-bind (tests #rest then) case
                    (if (== tests else:)
                        case
                        (concatenate
                         `(,(concatenate
                             `(or)
                             (map test-expression tests)))
                         then))))
                cases))))))

(define-function destructure (bindings values body)
  (if (instance? values <symbol>)
      (destructuring-bind (required rest key)
          (analyze-lambda-list bindings)
        (bind ((i (size required)))
          (reduce (method (body binding)
                    (dec! i)
                    (if (instance? binding <symbol>)
                        `(bind ((,binding (element ,values ,i)))
                           ,body)
                        (destructure binding `(element ,values ,i) body)))
                  (wrap-rest/keys body
                                  values
                                  required rest key)
                  (reverse required))))
      ;; ensures values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var body)))))

(define-core-macro destructuring-bind (_ bindings values #rest body)
  (destructure bindings values
               (concatenate `(begin) body)))

(define-core-macro bind-methods (_ bindings #rest body)
  (concatenate
   `(bind ,(map first bindings))
   (map (method (binding)
          (destructuring-bind (name arguments #rest body)
              binding
            `(set! ,name ,(concatenate `(method ,arguments)
                                       body))))
        bindings)
   body))

(define-core-macro inc! (_ object value)
  `(set! ,object (+ ,object ,(or value 1))))

(define-core-macro dec! (_ object value)
  `(set! ,object (- ,object ,(or value 1))))


;; TODO: backend-specific
(define-core-macro call-next-method (_)
  `((%get-property next-method "apply")
    (%native "null")
    (%native "arguments")))



(define-function transform-quoted (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (if (member? (first exp)
                 [(symbol "%comma") (symbol "%backqoute")])
        (second exp)
        (concatenate `(%array)
                     (map transform-quoted
                          exp))))
   ((instance? exp <symbol>)
    `(symbol ,(symbol-name exp)))
   (else:
    exp)))

(define-core-macro %backquote (_ exp)
  (transform-quoted exp))

;; comma is only used as a marker and
;; actually handled in backquote
(define-core-macro %comma (_ value)
  (signal (make <error> message: "comma not inside backquote")))

(define *dot-name-error*
  (make <error>
        message: "unsupported name for call in dot"))

(define-core-macro . (_ value #rest calls)
  (reduce (method (value call)
            (destructuring-bind (name #rest arguments) call
              (concatenate
               `((%get-property ,value
                                ,(select name instance?
                                   ((<string>)
                                    name)
                                   ((<symbol>)
                                    (symbol-name name))
                                   (else:
                                    (signal *dot-name-error*)))))
               arguments)))
          value
          calls))

(define-function function-definer (macro-name definer-name type/existing?)
  (method (_ function-name arguments #rest body)
    (destructuring-bind (setter? name)
        (if (setter-name? function-name)
            [#t (setter-symbol (second function-name))]
            [#f function-name])
      (unless (or (instance? name <symbol>)
                  setter?)
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "name not <var> or (setter <var>)"))))
      (when (and type/existing?
                 (empty? arguments))
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "method has no arguments"))))
      (destructuring-bind (required rest key)
          (analyze-lambda-list arguments)
        (bind ((required
                (map (method (argument)
                       (if (instance? argument <array>)
                           (first argument)
                           argument))
                     required)))
        `(define ,name
           ,(concatenate
             `(,(symbol definer-name)
               (%native-name ,(symbol-name name))
               ,(concatenate `(method
                                  ,(concatenate
                                    required
                                    (if rest
                                        (concatenate `(#rest) rest)
                                        [])
                                    (if key
                                        (concatenate `(#key) key)
                                        [])))
                             body)
               ,setter?)
             (if type/existing?
                 `(,(bind ((head (first arguments)))
                      (if (and (instance? head <array>)
                               (> (size head) 1))
                          (second head)
                          (symbol "<object>")))
                   ,name)
                 []))))))))

(for-each ((arguments [["define-function" "%make-function" #f]
                       ["define-method" "%make-method" #t]]))
          ()
  (set! (get *core-macros* (first arguments))
        (apply function-definer arguments)))


(define-core-macro define-generic (_ name arguments)
  `(define ,name
     (%make-generic
      (%native-name ,(symbol-name name)))))

(define-core-macro define-class (_ name superclass #rest properties)
  (bind ((object `(%object)))
    (for-each ((property properties))
              ()
      (if (instance? property <array>)
          (begin
           (push-last object (symbol-name (first property)))
           (push-last object `(method ()
                                ,(second property))))
          (begin
           (push-last object (symbol-name property))
           (push-last object #f))))
    `(define ,name
       (%make-class
        ,(unless (empty? superclass)
           (first superclass))
        ,object))))

(define-core-macro define-module (env name #key (import []) (export []))
  (set! (get env "exports")
        (map (method (name)
               (if (setter-name? name)
                   (setter-symbol (second name))
                   name))
             export))
  (maybe-begin
   (map (method (import)
          (bind ((module-name (symbol-name
                               (if (instance? import <array>)
                                   (first import)
                                   import))))
            (import-module
             env module-name
             names: (when (instance? import <array>)
                      (rest import)))
            (import-definition module-name env)))
        import)))

;; NOTE: requires module has been imported
(define-function import-definition (module-name module)
  (bind ((import-name (get module "import-names" module-name)))
    `(define ,import-name
       ((%native "require") ,module-name))))


;; TODO: %try, %throw, block, handler-case
;; TODO: inline make-object
;;       (initialize with string keys, evaluate and set rest)

;;;; lift defines

;; search for all %define and create top-level bindings,
;; replace with assignment to new top-level-binding

(define-function lift-defines (exp module)
  (lift-define exp module identity))

(define-function lift-define (exp module k)
  (if (expression? exp)
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-define
            value module
            (method (lvalue module)
              (lift-define
               body module
               (method (lbody module)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    module)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-define
            e2 module
            (method (le2 module)
              (k `(,m ,e1 ,le2)
                 module)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-define*
            e* module
            (method (le* module)
              (k (concatenate [m] le*)
                 module)))))
        (("define")
         (destructuring-bind (_ var value export?) exp
           (bind ((name (symbol-name var)))
             (if (get module "defined?" name)
                 (k `(%set ,var ,value)
                    module)
                 (begin
                  (set! (get module "defined?" name) #t)
                  `(%begin
                    (%define ,var)
                    ,(k `(%set ,var ,value)
                        module)))))))
        (else:
         (lift-define** exp module k)))
      (k exp module)))

(define-function lift-define* (exp* module k)
  (if (empty? exp*)
      (k [] module)
      (lift-define** exp* module k)))

(define-function lift-define** (exp module k)
  (lift-define
   (first exp) module
   (method (t module)
     (lift-define*
      (rest exp) module
      (method (t* module)
        (k (concatenate [t] t*)
           module))))))



;;;; symbol macros

;; utilities

(define *core-symbol-macros*
  (make-object))

(define-macro define-core-symbol-macro (name #rest definition)
  `(set! (get *core-symbol-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-core-symbol-macro next-method (_)
  `(%next-method %this-method))

;;;; macro expansion

(define-class <module> (<object>)
  name
  (macros (make-plain-object))
  (symbol-macros (make-plain-object))
  (names (make-object))
  (defined? (make-object
             "%all-arguments" #t
             "%this-method" #t))
  (lifted (make-object))
  (exports [])
  (imports [])
  (import-names (make-plain-object)))

(define-function macro-definition (form module)
  ;; TODO: deep-get
  (select form instance?
    ((<array>)
     (when (empty? form)
       (signal "Empty form"))
     (js:get-property module "macros" (symbol-name (first form))))
    ((<symbol>)
     (js:get-property module "symbol-macros" (symbol-name form)))))

(define-function macroexpand-1 (form module)
  (if-bind (macro (macro-definition form module))
    (apply macro module (if (instance? form <array>)
                            (rest form)
                            form))
    form))

(define-function macroexpand (form module)
  (bind ((done? #f))
    (until done?
      (bind ((expanded (macroexpand-1 form module)))
        (set! done? (== expanded form))
        (set! form expanded)))
    form))

(define-function macroexpand-all (form module)
  (select form instance?
    ((<array>)
     (if (macro-definition form module)
         (macroexpand-all (macroexpand form module) module)
         (if-bind (expander (special-form-definition form module))
           (apply expander module (rest form))
           (map (rcurry macroexpand-all module)
                form))))
    ((<symbol>)
     (if (macro-definition form module)
         (macroexpand-all (macroexpand form module) module)
         form))
    (else: form)))



;;;; define free variables

;; TODO: clean up, imported name is symbol
(define-function find-import-name (name module)
  (any? (method (import)
          (destructuring-bind (imported-module names) import
            ;; TODO: names symbols?
            (when (member? name names)
              (get module "import-names"
                   (get imported-module "name")))))
        (get module "imports")))

(define-function define-free-variables (exp module)
  (bind ((variables
          (set-subtract!
           (free-variables exp)
           (as-set (map symbol (keys (get module "defined?")))))))
    (if (empty? variables)
        exp
        (concatenate
         `(%begin)
         (map (method (variable)
                (bind ((name (symbol-name variable)))
                  (set! (get module "defined?" name) #t)
                  (maybe-begin
                   (concatenate
                    `((%define ,variable))
                    (if-bind (import-name (find-import-name variable module))
                      `((%set ,variable (%get-property ,import-name ,name)))
                      [])))))
              variables)
         [exp]))))

(define-function free-variables (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (select (symbol-name (first exp)) ==
      (("%method")
       (destructuring-bind (_ arguments body) exp
         (set-subtract!
          (free-variables body)
          (as-set arguments))))
      (("%bind")
       (destructuring-bind (_ (var value) body) exp
         ;; TODO: make binding available inside value?
         ;; (if so, also change alpha-convert)
         (set-union!
          (set-subtract!
           (free-variables body)
           (as-set [var]))
          (free-variables value))))
      (("%begin")
       ;; %define will only appear in %begin,
       ;; see previous pass lift-defines
       (bind ((definitions []))
         (set-subtract!
          (as-set
           (reduce (method (result e)
                     (concatenate
                      result
                      (if (and (expression? e)
                               (== (first e)
                                   (symbol "%define")))
                          (begin
                           (push-last definitions (second e))
                           [])
                          (free-variables e))))
                   [] (rest exp)))
          (as-set definitions))))
      (("%set" "%if" "%while"
        "%array" "%object"
        "%get-property" "%slice")
       (as-set (reduce concatenate []
                       (map free-variables
                            (rest exp)))))
      (("%native" "%native-name" "%infix" "%unary" )
       (as-set []))
      (else:
       (reduce1 set-union!
                (map free-variables
                     exp)))))
   ((instance? exp <symbol>)
    (as-set [exp]))
   (else:
    (as-set []))))


;;;; alpha conversion

;; "names" => module name => symbol name => renaming+

(define-function ensure-naming-structure (module variable-module variable-name)
  ;; ensure renmaing object for module
  (unless (get module "names" variable-module)
    (set! (get module "names" variable-module)
          (make-object)))
  ;; ensure renaming list for variable
  (unless (get module "names"
               variable-module variable-name)
    (set! (get module "names"
               variable-module variable-name)
          []))
  module)

(define-function rename-variables (variables module)
  (map (method (variable)
         (bind ((variable-module (or (get variable "module")
                                     ""))
                (variable-name (symbol-name variable))
                (new-variable (generate-symbol)))
           (ensure-naming-structure
            module variable-module variable-name)
           (push (get module "names"
                      variable-module variable-name)
                 new-variable)
           new-variable))
       variables))

(define-function restore-variables (variables module)
  (for-each ((variable variables))
            ()
    (bind ((variable-module (or (get variable "module")
                                ""))
           (variable-name (symbol-name variable)))
      (pop (get module "names"
                variable-module variable-name)))))

(define-function find-variable (variable module)
  (bind ((variable-module (or (get variable "module")
                              ""))
         (variable-name (symbol-name variable)))
    (if-bind (renamings (get module "names"
                             variable-module variable-name))
      (first renamings))))

(define-function alpha-convert (form module)
  (select form instance?
    ((<array>)
     (select (symbol-name (first form)) ==
       (("%method")
        (destructuring-bind (_ arguments body) form
          (bind ((new-arguments
                  (rename-variables arguments module)))
            (set! (second form)
                  new-arguments)
            (set! (last form)
                  (alpha-convert body module))
            (restore-variables arguments module)
            form)))
       (("%bind")
        (destructuring-bind (_ (var value) body) form
          ;; TODO: make binding available inside value?
          ;; (if so, also change define-free-variables)
          (bind ((new-value (alpha-convert value module)))
            (destructuring-bind (new-var)
                (rename-variables [var] module)
              (bind ((result
                      `(%bind (,new-var ,new-value)
                         ,(alpha-convert body module))))
                (restore-variables [var] module)
                result)))))
       (("%define")
        ;; rename in future expression
        ;; NOTE: modifies module!
        (destructuring-bind (_ variable) form
          (bind ((variable-module (or (get variable "module")
                                      ""))
                 (variable-name (symbol-name variable))
                 (new-variable (generate-symbol)))
            (ensure-naming-structure
             module variable-module variable-name)
            (push-last (get module "names"
                            variable-module variable-name)
                       new-variable)
            ;; register renaming of definition
            (set! (get module "renaming->definition-name"
                       (symbol-name new-variable))
                  variable-name)
            ;; update form
            (set! (second form)
                  new-variable)
            form)))
       (else:
        (map (rcurry alpha-convert module)
             form))))
    ((<symbol>)
     (or (find-variable form module)
         form))
    (else: form)))

;;;; beta reduction

;; ((L (x y) (+ x y)) a (+ a 1))
;; => ((L (y) (+ a y)) (+ a 1))

;; (define-function substitute-variables (variables new-variables env)
;;   (bind ((env (wrap-object env)))
;;     (for-each ((variable variables)
;;                (new-variable new-variables))
;;               ()
;;       (set! (get env (symbol-name variable))
;;             new-variable))
;;     env))


;;;; TODO: eliminate
;;;; ((L () X)) => X
;;;; (begin 1) => 1

;;(define-function beta-reduce (form env)
;;  (select form instance?
;;    ((<array>)
;;     ;; TODO: bind
;;     (if (and (instance? (first form) <array>)
;;              (== (symbol-name (first (first form))) "%method"))
;;         (destructuring-bind ((_ arguments #rest body) #rest values)
;;             form
;;           ;; TODO: maybe also support constant values (numbers, etc.)
;;           (bind ((variables [])
;;                  (new-variables [])
;;                  (new-arguments [])
;;                  (new-values []))
;;             (for-each ((argument arguments)
;;                        (value values))
;;                 ()
;;               (if (atomic? value)
;;                   (begin
;;                    (push-last variables argument)
;;                    (push-last new-variables value))
;;                   (begin
;;                    (push-last new-arguments argument)
;;                    (push-last new-values value))))
;;             (bind ((env (substitute-variables variables new-variables env)))
;;               (concatenate `(,(concatenate `(%method ,new-arguments)
;;                                            (beta-reduce body env)))
;;                            new-values))))
;;         (map (rcurry beta-reduce env)
;;              form env)))
;;    ((<symbol>)
;;     (or (find-variable form env)
;;         form))
;;    (else: form)))


;;;; ANF

;; TODO: also normalize when function can be inlined?

(define-function atomic? (expression)
  (any? (curry instance? expression)
        [<number> <boolean> <string> <symbol> <keyword>]))

(define-function normalize-term (expression)
  (normalize expression identity))

(define-function normalize (exp k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (k `(%method ,arguments
                 ,(normalize-term body)))))
        (("%begin")
         (destructuring-bind (_ exp1 #rest e*) exp
           (if (empty? e*)
               (normalize exp1 k)
               (normalize
                exp1 (method (aexp1)
                       `(%begin
                         ,aexp1
                         ,(normalize (concatenate
                                      `(%begin) e*)
                                     k)))))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (normalize
            value (method (avalue)
                   `(%bind (,var ,avalue)
                      ,(normalize body k))))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           (normalize-value
            test (method (atest)
                   (k `(%if ,atest
                            ,(normalize-term then)
                            ,(normalize-term else)))))))
        (("%while")
         (destructuring-bind (_ test body) exp
           (k (if (contains-statements? test)
                  `(%while #t
                     (%begin
                      ,(normalize-term
                        `(%if ,test
                              ,(normalize-term body)
                              (%native "break")
                              #f))))
                  `(%while
                    ,(normalize-term test)
                    ,(normalize-term body))))))
        (("%set")
         (destructuring-bind (_ var value) exp
           (normalize-value
            value (method (avalue)
                   (k `(%set ,var ,avalue))))))

        (else:
         (if (contains-statements? exp)
             (normalize-all exp k)
             (k (map normalize-term exp)))))
      (k exp)))

(define-function normalize-value (exp k)
  (if (contains-statements? exp)
      (normalize-name exp k)
      (k (if (instance? exp <array>)
             (map normalize-term exp)
             exp))))

(define-function contains-statements? (exp)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%begin" "%if" "%while" "%bind") #t)
        (("%set")
         (contains-statements? (last exp)))
        (("%method") #f)
        (else:
         (any? contains-statements? exp)))
      #f))

(define-function normalize-name (exp k)
  (normalize
   exp (method (aexp)
         (if (atomic? aexp)
             (k aexp)
             (bind ((t (generate-symbol)))
               `(%bind (,t ,aexp)
                  ,(k t)))))))

(define-function normalize-name* (exp* k)
  (if (empty? exp*)
      (k [])
      (normalize-all exp* k)))

(define-function normalize-all (exp k)
  (normalize-name
   (first exp) (method (t)
                 (normalize-name*
                  (rest exp) (method (t*)
                               (k (concatenate [t] t*)))))))


;;;; statements

;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

;; NOTE: wrap-value, transform-statements and
;; flatten-statements are destructive!
;; => mutation of expressions reduces consing

(define-function wrap-value (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap then and else
         (set! (third exp)
               (wrap-value (third exp) wrapper))
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value #f wrapper)))
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function add-explicit-return (exp)
  (wrap-value exp `(%return)))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment:
;; (%bind ($1 (%if ... (%bind ($2 ...) (foo $2) ...))) (bar $1 baz))
;; => (%bind ($1 #f)
;;      (%begin
;;       (%if ...
;;            (%bind ($2 ...)
;;              (set! $1 (foo $2)))
;;            ...)
;;       (bar $1 baz)))

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind))))


(define-function add-explicit-true (exp)
  `((%native "$T") ,exp))

(define-function transform-statements (exp module)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method")
         (set! (last exp)
               (add-explicit-return
                (transform-statements (last exp)
                                      module)))
         exp)
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (maybe-begin
            (map (rcurry transform-statements module)
                 exps))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (if (statement? value)
               `(%bind (,var #f)
                  (%begin
                   ,(wrap-value
                     (transform-statements value module)
                     `(%set ,var))
                   ,(transform-statements body module)))
               `(%bind (,var
                        ,(transform-statements value module))
                  ,(transform-statements body module)))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           `(%if
             ;; TODO: only if not boolean
             ,(add-explicit-true test)
             ,(transform-statements then module)
             ,(transform-statements else module))))
        (("%while")
         (set! (second exp)
               (add-explicit-true (second exp)))
         (set! (third exp)
               (transform-statements (third exp) module))
         exp)
        (("%set")
         (destructuring-bind (_ name value) exp
           (bind ((value* (transform-statements value module))
                  (definition-name
                    (get module "renaming->definition-name"
                         (symbol-name name))))
             ;; check if exported definition
             (if (and definition-name
                      (member? (symbol definition-name)
                               (get module "exports")))
               (begin
                (set! (first exp) (symbol "%begin"))
                (set! (second exp)
                      `(%set ,name ,value*))
                (set! (third exp)
                      `(%set (%get-property (%native "exports")
                                            ,definition-name)
                             ,name)))
               ;; no re-export, leave as is
               (set! (third exp) value*))))
         exp)
        (("%define")
         `(%var (,(last exp) #f)))
        (else:
         (map (rcurry transform-statements module) exp)))
      exp))



;;;; symbol lifting

(define-function lift-symbols (exp module)
  (lift-symbol exp module identity))

(define-function lift-symbol (exp module k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-symbol
            value module
            (method (lvalue module)
              (lift-symbol
               body module
               (method (lbody module)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    module)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-symbol
            e2 module
            (method (le2 module)
              (k `(,m ,e1 ,le2)
                 module)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-symbol*
            e* module
            (method (le* module)
              (k (concatenate [m] le*)
                 module)))))
        ;; TODO: fix, already renamed
        (("symbol")
         (destructuring-bind (_ name) exp
           (lift-value
            name exp "symbol" module k)))
        (else:
         (lift-symbol** exp module k)))
      (select exp instance?
        ((<keyword>)
         (lift-value
          (symbol-name exp) exp "keyword" module k))
        ((<hash-symbol>)
         (lift-value
          (symbol-name exp) exp "hash" module k))
        (else:
         (k exp module)))))

(define-function lift-value (name value type module k)
  (if-bind (t (get module "lifted" type name))
    (k t module)
    (bind ((t (set! (get module "lifted" type name)
                    (generate-symbol))))
      `(%bind (,t ,value)
         ,(k t module)))))

(define-function lift-symbol* (exp* module k)
  (if (empty? exp*)
      (k [] module)
      (lift-symbol** exp* module k)))

(define-function lift-symbol** (exp module k)
  (lift-symbol
   (first exp) module
   (method (t module)
     (lift-symbol*
      (rest exp) module
      (method (t* module)
        (k (concatenate [t] t*)
           module))))))


;;;; flatten-statements

(define-function flatten-begins (exps)
  (reduce1 concatenate
           (map (method (exp)
                  (bind ((flattened (flatten-statements exp)))
                    (if (and (instance? flattened <array>)
                             (not (empty? flattened))
                             (== (first flattened)
                                 (symbol "%begin")))
                        (rest flattened)
                        [flattened])))
                exps)))

(define-function var? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%var"))))

(define-function set? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%set"))))

(define-function method? (exp)
  (and (expression? exp)
       (== (first exp)
           (symbol "%method"))))

(define-function flatten-vars (exps)
  (reduce (method (result exp)
            (bind ((previous (and (not (empty? result))
                                  (last result)))
                   (previous-var? (and previous
                                       (var? previous))))
              (if (and previous-var? (var? exp))
                  ;; add current bindings to previous
                  (begin
                   (do (method (binding)
                         (push-last (last result)
                                    binding))
                       (rest exp))
                   result)
                  ;; add assignment to previous binding?
                  (bind ((merge? (and previous-var? (set? exp)))
                         (binding (and merge? (last (last result))))
                         (name (and merge? (second exp))))
                    (if (== (first binding)
                            name)
                        (begin
                         (set! (second binding)
                               (third exp))
                         result)
                        (concatenate result [exp]))))))
          [] exps))

(define-function flatten-statements (exp)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method" "%while" "%set")
         (set! (last exp)
               (flatten-statements (last exp)))
         exp)
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (maybe-begin
            (flatten-vars
             (flatten-begins exps)))))
        (("%bind")
         (destructuring-bind (_ binding body) exp
           (flatten-statements
            `(%begin
              (%var ,binding)
              ,body))))
        (("%if")
         (set! (third exp)
               (flatten-statements (third exp)))
         (set! (last exp)
               (flatten-statements (last exp)))
         exp)
        (else:
         (map flatten-statements exp)))
      exp))



;;;; compilation to JS

(define *escaped*
  (make-object
   "\"" "\""
   "\\" "\\"
   "\b" "b"
   "\f" "f"
   "\n" "n"
   "\r" "r"
   "\v" "v"
   "\t" "t"))

(define-function fill-zeros (string)
  (concatenate
   (slice "0000" 0 (- 4 (size string)))
   string))

(define-function escape-string (string)
  (join (map (method (char)
               (if-bind (escaped (get *escaped* char))
                 (concatenate "\\" escaped)
                 (bind ((code (char-code char)))
                   (if (< 0x1f code 0x7f)
                       char
                       (concatenate
                        "\\u" (fill-zeros (as-hex-string code)))))))
             (as-array string))
        ""))

(define *reserved*
  ["break" "case" "catch" "continue" "default" "delete" "do" "else"
   "finally" "for" "function" "if" "in" "instanceof" "new" "return"
   "switch" "this" "throw" "try" "typeof" "var" "void" "while"
   "with" "abstract" "boolean" "byte" "char" "class" "const"
   "debugger" "double" "enum" "export" "extends" "final" "float"
   "goto" "implements" "import" "int" "interface" "long" "native"
   "package" "private" "protected" "public" "short" "static" "super"
   "synchronized" "throws" "transient" "volatile" "null" "true" "false"
   "arguments" "object" "number" "string" "array" "let" "yield"])

(define *symbol-escapes*
  (make-object
   "-" "_"
   "_" "__"
   "&" "A"
   "$" "B"
   ":" "C"
   "." "D"
   "=" "E"
   "^" "F"
   ">" "G"
   "#" "H"
   "@" "I"
   "~" "J"
   ;; K: keyword
   "<" "L"
   "%" "M"
   "!" "N"
   ;; O
   "+" "P"
   "?" "Q"
   ;; R: reserved
   "/" "S"
   "*" "T"
   ;; U, V, W, X, Y
   ;; Z: any other
   ))

(define-function escape-symbol-name (name)
  (if (member? name *reserved*)
      (concatenate "R" name)
      (bind ((chars
              (map (method (char)
                     (cond
                      ((has? *symbol-escapes* char)
                       (get *symbol-escapes* char))
                      ((match "\\w" char)
                       char)
                      (else:
                       (concatenate
                        "Z" (as-string (char-code char))))))
                   (as-array name))))
        (join chars ""))))

(define-function valid-identifier? (identifier)
  (and (not (member? identifier *reserved*))
       (match "^\\w+$" identifier)))

(define-function compile-js (exp module)
  (select exp instance?
    ((<array>)
     (if (empty? exp)
         (signal (make <error> message: "empty expression"))
         (compile-js-exp exp module)))
    ((<number>)
     (as-string exp))
    ((<boolean>)
     (if exp "true" "false"))
    ((<string>)
     (concatenate "\"" (escape-string exp) "\""))
    ((<hash-symbol>)
     (concatenate
      "$" (as-uppercase (symbol-name exp))))
    ((<keyword>)
     (concatenate
      "$K(\"" (symbol-name exp)  "\")"))
    ((<symbol>)
     (select exp ==
       (((symbol "%this-method"))
        (compile-js (get module "current-method")
                    module))
       (((symbol "%all-arguments"))
        "arguments")
       (else:
        (if (get exp "generated?")
            (symbol-name exp)
            (escape-symbol-name
             (symbol-name exp))))))
    (else:
     (description exp))))

;; TODO: document as language

(define-function compile-js-exp (exp module)
  (bind ((name (symbol-name (first exp))))
    (select name ==
      (("%unary")
       (destructuring-bind (_ operator value) exp
         (concatenate
          "(" operator " "
          (compile-js value module) ")")))
      (("%infix")
       (destructuring-bind (_ operator #rest values) exp
         (concatenate
          "(" (join (map (rcurry compile-js module)
                         values)
                    (concatenate
                     " " operator " "))
          ")")))
      (("%array")
       (destructuring-bind (_ #rest elements) exp
         (concatenate
          "[" (join (map (rcurry compile-js module)
                         elements)
                    ", ")
          "]")))
      (("%object")
       (bind ((key-values (rest exp))
              (entries []))
         (dotimes (i (/ (size key-values) 2))
           (push-last entries
                      (concatenate
                       (bind ((name (element key-values (* i 2))))
                         (if (valid-identifier? name)
                             name
                             (compile-js name module)))
                       ":" (compile-js
                            (element key-values (+ (* i 2) 1))
                            module))))
         (concatenate
          "{" (join entries ",\n") "}")))
      (("%if")
       (destructuring-bind (_ test then else) exp
         (concatenate
          "if (" (compile-js test module) ")\n"
          (compile-js then module)
          ;; optimization: default is false
          (if (and else
                   (not (= else `(%return #f))))
              (concatenate
               "\nelse " (compile-js else module))
              ""))))
      (("%while")
       (destructuring-bind (_ test body) exp
         (concatenate "while (" (compile-js test module) ")\n"
                      (compile-js body module))))
      (("%return")
       (concatenate
        "return " (compile-js (second exp) module)))
      (("%begin")
       (concatenate
        "{" (join (map (rcurry compile-js module)
                       (rest exp))
                  ";\n")
        "}"))
      (("%set")
       (destructuring-bind (_ var value) exp
         (concatenate
          (compile-js var module) " = "
          (compile-js value module))))
      (("%method")
       (destructuring-bind (_ arguments body) exp
         (bind ((name (generate-symbol))
                (previous-method (get module "current-method")))
           (concatenate
            "function " (compile-js name module)
            " (" (join (map (rcurry compile-js module)
                            arguments)
                       ", ")
            ")\n"
            (begin
             (set! (get module "current-method") name)
             (bind ((body* (compile-js body module)))
               (set! (get module "current-method") previous-method)
               (if (and (expression? body)
                        (== (first body) (symbol "%begin")))
                   body*
                   (concatenate "{" body* "}"))))))))
      (("%var")
       (destructuring-bind (_ #rest bindings) exp
         (concatenate
          "var "
          (join (map (method (binding)
                       (destructuring-bind (var value)
                           (if (instance? binding <array>)
                               binding
                               [binding #f])
                         (concatenate
                          (compile-js var module)
                          (if value
                              (concatenate
                                " = " (compile-js value module))
                              ""))))
                     bindings)
                ", "))))
      (("%native")
       (reduce1 concatenate
                (map (method (e)
                       (if (instance? e <symbol>)
                           (symbol-name e)
                           (as-string e)))
                     (rest exp))))
      (("%native-name")
       (concatenate
        "\"" (escape-symbol-name (second exp)) "\""))
      (("%get-property")
       (destructuring-bind (_ object #rest properties) exp
         (concatenate
          (if (instance? object <number>)
              (concatenate "(" (compile-js object module) ")")
              (compile-js object module))
          (reduce (method (result property)
                    (concatenate
                     result
                     (if (and (instance? property <string>)
                              (valid-identifier? property))
                         (concatenate "." property)
                         (concatenate "[" (compile-js property module) "]"))))
                  "" properties))))
      (("%slice")
       (concatenate
        "$SL.call"
        "(" (join (map (rcurry compile-js module)
                       (rest exp))
                  ", ")
        ")"))
      (else:
       (destructuring-bind (head #rest tail) exp
         (concatenate
          (bind ((head* (compile-js head module)))
            (if (method? head)
                (concatenate "(" head* ")")
                head*))
          "(" (join (map (rcurry compile-js module)
                         tail)
                    ", ")
          ")"))))))


;;;;

(define-function read-program (source)
  (read (make <string-stream>
              string: (concatenate "(" source "\n)"))))

(define-function compile-expression (exp module)
  (reduce (method (result name/fn)
            (destructuring-bind (name fn) name/fn
              (format-out "### %s:\n" name)
              (bind ((result (fn result)))
                (format-out "%=\n" result)
                result)))
          exp
          [["source" identity]
           ["macroexpanded"
            (rcurry macroexpand-all module)]
           ["lifted defines"
            (rcurry lift-defines module)]
           ["defined free variables"
            (rcurry define-free-variables module)]
           ["alpha-converted"
            (rcurry alpha-convert module)]
           ["ANF"
            normalize-term]
           ["lifted symbols"
            (rcurry lift-symbols module)]
           ["statements"
            (rcurry transform-statements module)]
           ["flattened"
            flatten-statements]
           ["compiled"
            (rcurry compile-js module)]]))

;;;;

(define path (require "path"))
(define fs (require "fs"))
(define vm (require "vm"))

(define-function ensure-directory (directory)
  (bind ((parent (. path ("dirname" directory))))
    (unless (. path ("existsSync" parent))
      (ensure-directory parent))
    (unless (. path ("existsSync" directory))
      (. fs ("mkdirSync" directory)))))

(define-function executable-path (module-name)
  (. path ("resolve" "output"
           (concatenate module-name ".js"))))

(define-function source-path (module-name)
  (. path ("resolve" "src"
           (concatenate module-name ".ralph"))))


; (define-function recompile? (module-name)
;   (bind ((p (executable-path module-name)))
;     (or (not (. path ("existsSync" p)))
;         (bind ((p2 (source-path module-name)))
;           (< (get (. fs ("statSync" p)) "mtime")
;              (get (. fs ("statSync" p2)) "mtime"))))))


(define-function compile-time-import-module (module module-name)
  (if (== module-name "ralph2/core")
      (begin
       (chain-object (get module "macros")
                     *core-macros*)
       (chain-object (get module "symbol-macros")
                     *core-symbol-macros*))
      (bind ((other-module (find-module module-name))
             (definitions (require module-name)))
        (bind-properties (symbol-macros macros) other-module
          (chain-object (get module "macros")
                        (as-object (reduce1 concatenate
                                            (map (method (macro)
                                                   [macro (get required macro)])
                                                 macros))))
          (chain-object (get module "symbol-macros")
                        (as-object (reduce1 concatenate
                                            (map (method (macro)
                                                    [macro (get required macro)])
                                                 symbol-macros))))))))

(define-function import-module (module module-name #key names)
  ;; TODO: open database first
  (bind ((other-module (find-module module-name))
         (names (or names (get other-module "exports")))
         (import-name (generate-symbol)))
    (set! (get module "import-names" module-name)
          import-name)
    (push (get module "imports")
          [other-module names])
    other-module))

(define-function find-module (module-name)
  (or (compile-module module-name)
      (get *modules* module-name)))

(define-function read-file (path)
  (. fs ("readFileSync" path)
     ("toString")))

(define-function open-executable (module-name)
  (bind ((p (executable-path module-name)))
    (ensure-directory (. path ("dirname" p)))
    (. fs ("openSync" p "w"))))

(define-function compile-module (module-name)
  ; TODO: if recompile?
  (unless (has? *modules* module-name)
    (bind ((module (make <module> name: module-name))
           (source (read-file (source-path module-name)))
           (program (read-program source))
           (executable (open-executable module-name)))
      (set! (get *modules* module-name)
            module)
      (compile-time-import-module module "ralph2/core")
      ;; special case core?
      (unless (== module-name "ralph2/core")
        ;; implicitly import and load core
        (import-module module "ralph2/core")
        (push program
              (import-definition "ralph2/core" module)))
      ;; compile
      (do (method (expression)
            (. fs ("writeSync" executable
                   (concatenate
                    (compile-expression expression module)
                    "\n"))))
          program)
      (. fs ("closeSync" executable))
      module)))

;;;;

(bind ((start (make <date>)))
  (compile-module "ralph2/runtime.test")
  (format-out "%d\n" (- (make <date>) start)))
