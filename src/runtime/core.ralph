
(define-module core
  export: (%define %export %get-definition %define-getter %define-setter
           (js:identifier "_s") (js:identifier "_k")
           (js:identifier "_key") (js:identifier "_rest")
           keyword keyword? symbol symbol-name
           <object> <string> <number> <boolean> <array> <function>
           <symbol> <hash-symbol> <keyword> <non-local-exit> <error>
           not true? signal
           *environment*
           %define-class %make-generic %alias-type %recompute-slots
           %non-local-exit? %make-non-local-exit-function
           get %set
           %inherit make initialize type instance? superclass
           as-string as-array as-number
           apply reduce reduce1 map do repeatedly
           any? every? member? choose-by find-key
           complement curry rcurry
           position join trim replace
           as-lowercase as-uppercase
           make-array make-object
           element first second third last rest concatenate
           size empty? but-last copy-sequence slice
           replace-subsequence replace-subsequence!
           reverse reverse! sort sort! remove remove!
           push push-last pop pop-last
           keys values
           = == > < >= <=
           + - * /
           inc dec
           description
           identity
           min max abs round floor expt sqrt cos sin atan2 as-radiant mod
           extend! as-property-list as-object))

;;;; define

(js:function %export (exports name value)
  (set! (js:get-property exports name) value))

(js:function %define (module exports name value)
  (begin
    (set! (js:get-property module name) value)
    (js:if (js:>= ((js:get-property module "%exports" "indexOf") name) 0)
           (%export exports name value)
           #f)))


;; manual export necessary
(%export exports (js:escape %define) %define)
(%export exports (js:escape %export) %export)

(define %get-property
  (js:function js:null (object name)
    (js:return (js:and object
                       (has? object name)
                       (js:get-property object name)))))

(define %get-definition
  (js:function js:null (module name)
    (js:return (js:and (js:defined (js:get-property module name))
                       (js:get-property module name)))))

(define %make-function
  (js:function js:null (name function)
    (js:return (js:new (js:identifier "Function")))))

;;;; boolean primitives

(define true?
  (js:function js:null (value)
    (js:return
     (js:and (js:not (js:=== value js:null))
             (js:not (js:=== value js:undefined))
             (js:not (js:=== value #f))))))

(define not
  (js:function js:null (value)
    (js:return (js:not (true? value)))))

;; class

(define %define-class
  (js:function js:null (module exports name superclass slots)
    (bind ((class (js:function js:null ())))
      (%define module exports name class)
      (set! (js:get-property class "%name")
            name)
      (js:if superclass
             (%inherit class superclass))
      (set! (js:get-property class "%own-slots")
            (map first slots))
      (js:var defaults (make-object))
      (set! (js:get-property class "%slot-defaults")
            defaults)
      (do (method (slot)
            (set! (js:get-property defaults (first slot))
                  (second slot)))
          slots)
      (%recompute-slots class))))

;;;; getter

(define %define-getter
  (js:function js:null (module exports name function type-name)
    (bind ((getter (%get-definition module name))
           (generic? (when getter
                       (%get-property getter "%generic")))
           ;; define new getter and return (possibly) existing setter
           (setter (if generic?
                       (bind ((type (%actual-type (%get-definition module type-name)))
                              (prototype (js:get-property type "prototype"))
                              (existing-getter (%get-property prototype name)))
                         (set! (js:get-property prototype name) function)
                         (%get-property existing-getter "%setter"))
                       (begin
                        (%define module exports name function)
                        (%get-property getter "%setter")))))
      (set! (js:get-property function "%name") name)
      (set! (js:get-property function "displayName") name)
      ;; re-define setter if it was existing
      (when setter
        (set! (js:get-property function "%setter") setter)))))

;;;; setter

(define %define-setter
  (js:function js:null (module exports name function type-name)
    (bind ((getter (%get-definition module name))
           (generic? (when getter
                       (%get-property getter "%generic"))))
      (set! (js:get-property function "%name") name)
      (set! (js:get-property function "displayName")
            (js:+ "(setter " name ")"))
      (if generic?
          (bind ((type (%actual-type (%get-definition module type-name)))
                 (prototype (js:get-property type "prototype"))
                 (getter (or (%get-property prototype name)
                             ;; create temporary getter
                             (bind ((temp (%make-function)))
                               (set! (js:get-property prototype name)
                                     temp)
                               temp))))
            (set! (js:get-property getter "%setter") function))
          (begin
           (unless (%get-definition module name)
             ;; creare temporary getter
             (%define module exports name (%make-function)))
           (set! (js:get-property (%get-definition module name) "%setter")
                 function))))))

(define-function %set ((function <function>) #rest arguments)
  (bind ((generic? (%get-property function "%generic"))
         (name (%get-property function "%name"))
         (getter (if generic?
                     (bind ((type (%actual-type (type (first arguments))))
                            (prototype (js:get-property type "prototype"))
                            (getter (%get-property prototype name)))
                       getter)
                     function))
         (setter (%get-property getter "%setter")))
    (apply setter arguments)))

;;;; objects

(define-function make (type #rest arguments)
  (js:var type (%actual-type type))
  (js:var object (js:new type))
  (js:var defaults (js:get-property type "%slot-defaults"))
  (do (method (name)
        (set! (js:get-property object name)
              (js:get-property defaults name)))
      (keys defaults))
  (apply initialize object arguments)
  object)

(define-function %inherit (class superclass)
  (set! (js:get-property class "prototype" "__proto__")
        (js:get-property superclass "prototype"))
  (set! (js:get-property class "prototype" "__super__")
        superclass)
  class)

(define-function superclass (class)
  (js:get-property class "prototype" "__super__"))

(define %actual-type
  (js:function js:null (type)
    (js:return (js:or (%get-property type "%js-type") type))))

(define-function %recompute-slots (class)
  (js:var slots (js:get-property class "%own-slots"))
  (js:var super class)
  (js:while (set! super (superclass super))
      (set! slots
            (%concat slots (js:or (js:get-property super "%own-slots") []))))
  (set! (js:get-property class "%slots")
        slots))

;;;; keywords

(define %keywords (make-object))

(define <keyword> (%make-function))

(define-function keyword? (keyword)
  (instance? keyword <keyword>))

(%define *module* exports "_k"
  (js:function js:null (name)
    (begin
      (js:var keyword js:null)
      (js:set name ((js:get-property name "toLowerCase")
                    name))
      (js:return
       (if (has? %keywords name)
           (js:get-property %keywords name)
           (begin
            (set! keyword (js:new <keyword>))
            (set! (js:get-property keyword "name") name)
            (set! (js:get-property %keywords name) keyword)
            keyword))))))

(define keyword (js:identifier "_k"))

;;;; non-local exit

(define <non-local-exit>
  (js:function js:null (name value)
    (begin
     (set! (js:get-property js:this "name") name)
     (set! (js:get-property js:this "value") value)
     (js:return js:this))))

(define-function %non-local-exit? (condition)
  (instance? condition <non-local-exit>))

;; TODO: replace with proper initialization method
(define-function %make-non-local-exit-function (name)
  (method (value)
    ;; TODO: use signal and proper make call
    (js:throw (js:new <non-local-exit>
                      name value))))

(define-function as-string (object)
  ((js:get-property object "toString")))

(define-function as-number (object)
  ((js:identifier "Number") object))

(define-function as-array (arguments skip)
  ((js:get-property [] "slice" "call")
   arguments (js:or skip 0)))

(define-function has? (object property)
  ((js:get-property object "hasOwnProperty") property))

(define-function get (object #rest keys)
  (js:var result)
  (js:while (not (empty? keys))
    (js:var key (first keys))
    (if (has? object key)
        (begin
         (set! result (js:get-property object key))
         (set! object result)
         (set! keys (rest keys)))
        (js:return #f)))
  result)

(define-function (setter get) (object #rest properties/value)
  (if (js:<= (size properties/value) 2)
      (set! (js:get-property object (first properties/value))
            (second properties/value))
      (bind ((property (first properties/value))
             (object2 (if (has? object property)
                          (get object property)
                          (bind ((new (make-object)))
                            (set! (js:get-property object property) new)
                            new))))
        (apply %set get object2
               (rest properties/value)))))

;;;;

(define *environment*
  (cond
   ((js:defined window) "browser")
   ((js:defined process) "nodejs")
   (otherwise: "commonjs")))

;;;;

(define-function size ((array <array>))
  (js:get-property array "length"))

(define-function slice (array start end)
  ;; workaround for ringo: slice(undefined, undefined) -> undefined
  (js:if (js:defined end)
         ((js:get-property array "slice") start end)
         ((js:get-property array "slice") start)))

(define-function copy-sequence ((array <array>)
                                #key (start 0) (end (size array)))
  (slice array start end))

(define-function push-last ((array <array>) new-value)
  ((js:get-property array "push") new-value)
  array)

(define-function inc ((number <number>))
  (js:+ number 1))

(define-function dec ((number <number>))
  (js:- number 1))

(define-function + ((number <number>) #rest more-numbers)
  (reduce (method (number1 number2)
            (js:+ number1 number2))
          number more-numbers))

(define-function - ((number <number>) #rest more-numbers)
  (if (empty? more-numbers)
      (js:negative number)
      (reduce (method (number1 number2)
                (js:- number1 number2))
              number more-numbers)))

(define-function * ((number1 <number>) (number2 <number>)
                    #rest more-numbers)
  (reduce1 (method (number1 number2)
             (js:* number1 number2))
           (%concat [number1 number2] more-numbers)))

(define-function / ((number1 <number>) (number2 <number>)
                    #rest more-numbers)
  (reduce1 (method (number1 number2)
             (js:/ number1 number2))
           (%concat [number1 number2] more-numbers)))

(define-function keys (object)
  (js:var keys [])
  (if (instance? object (js:identifier "Array"))
      (for ((i 0 (inc i)))
           ((>= i (size object)) keys)
        (push-last keys i))
      (begin
       (js:for-in (key object)
         (js:if (has? object key)
           (push-last keys key)))
       keys)))

(define-function values (object)
  (js:var values [])
  (js:for-in (key object)
    (js:if (has? object key)
      (push-last values (js:get-property object key))))
  values)

(define-function make-array (#rest elements)
  elements)

(define-function push ((array <array>) new-value)
  ((js:get-property array "unshift") new-value)
  array)

(define-function pop ((array <array>))
  ((js:get-property array "shift")))

(define-function pop-last ((array <array>))
  ((js:get-property array "pop")))

(define-function add! ((array <array>) new-value)
  (push array new-value))

(define-function %concat (array1 array2 )
  ((js:get-property array1 "concat") array2))

(define-function reverse! ((array <array>))
  ((js:get-property array "reverse")))

(define-function reverse ((array <array>))
  (reverse! (slice array)))

(define-function sort! ((array <array>) #key (test <))
  ((js:get-property array "sort") test))

(define-function sort ((array <array>) #key (test <))
  (sort! (slice array) test: test))

(define-function element ((array <array>) key #key default)
  (or (js:get-property array key) default))

(define-function (setter element) ((array <array>) key new-value)
  (set! (js:get-property array key) new-value))

(define-function empty? ((array <array>))
  (js:== (size array) 0))

;; the functions passed to map and reduce are
;; wraped in additional method, as the JS version
;; also additionally passes the index and
;; the traversed array - might clash when
;; using curry/rcurry

(define-function map ((function <function>) (array <array>))
  ((js:get-property array "map")
   (method (element)
     (function element))))

(define-function do ((function <function>) (array <array>))
  ((js:get-property array "forEach")
   (method (element)
     (function element))))

(define-function reduce1 ((function <function>) (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))))

(define-function reduce ((function <function>) initial-value (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))
   initial-value))

(define-function every? ((function <function>) (array <array>))
  ((js:get-property array "every")
   (method (element)
     (true? (function element)))))

(define-function choose ((function <function>) (array <array>))
  ((js:get-property array "filter")
   (method (element)
     (true? (function element)))))

(define %not-found (make-object))

(define-function find-key ((array <array>) (predicate <function>)
                           #key (skip 0) failure from-end?)
  (bind ((keys (keys array))
         (satisfying-keys
          (choose (method (index)
                    (true? (predicate (element array index))))
                  (if from-end?
                      (reverse keys)
                      keys))))
    (or (element satisfying-keys skip)
        failure)))

(define-function position ((array <array>) element)
  (js:var position ((js:get-property array "indexOf") element))
  (js:if (js:> position -1) position #f))

(define-function any? ((function <function>) (array <array>))
  (js:var match #f)
  (js:var found?
          ((js:get-property array "some")
           (method (element)
             (js:var result (function element))
             (set! match result)
             result)))
  (js:if found? match #f))

(define-function member? (value (array <array>))
  (any? (method (other-value)
                (== value other-value))
        array))

(define-function choose-by ((predicate <function>)
                            (test-array <array>)
                            (value-array <array>))
  (bind ((test-keys (choose (method (test-key)
                              (predicate (element test-array test-key)))
                            (keys test-array))))
    (map (curry element value-array)
         test-array)))

(define-function first ((array <array>))
  (element array 0))

(define-function second ((array <array>))
  (element array 1))

(define-function third ((array <array>))
  (element array 2))

(define-function last ((array <array>))
  (element array (dec (size array))))

(define-function rest ((array <array>))
  (slice array 1))

(define-function but-last ((array <array>) n)
  (slice array 0 (js:* (js:or n 1) -1)))

(define-function replace-subsequence ((target-array <array>) (insert-array <array>)
                                      #key (start 0) (end (size target-array)))
  (concatenate (slice target-array 0 start)
               insert-array
               (slice target-array end)))

(define-function replace-subsequence! ((target-array <array>) (insert-array <array>)
                                       #key (start 0) end)
  ((js:get-property [] "splice" "apply")
   target-array (%concat [start (js:- (or end start) start)]
                         insert-array))
  target-array)

;;;; string

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable

(define-function as-uppercase ((string <string>))
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  ((js:get-property string "toLowerCase")))

;; TODO: generic interpose, interleave
(define-function join ((array <array>) (string <string>))
  ((js:get-property array "join") string))

(define-function trim ((string <string>))
  ((js:get-property string "trim")))

(define-function replace ((string <string>) pattern replacement)
  ((js:get-property string "replace")
   pattern replacement))

;;;; functional

(define-function apply ((function <function>) #rest arguments)
  ((js:get-property function "apply") js:null
   (%concat (but-last arguments)
            (last arguments))))

(define-function curry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate curried-args args))))

(define-function rcurry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate args curried-args))))

(define-function always (value)
  (method (#rest args)
    value))

(define-function complement ((function <function>))
  (method (#rest arguments)
    (not (apply function arguments))))

;;;; reflection primitives

(define-function type (object)
  (if (or (js:=== object js:undefined)
          (js:=== object js:null))
      <boolean>
      ;; Object.getPrototypeOf on primitives only works in FireFox:
      ;; ((js:get-property "Object" "getPrototypeOf") object))
      (bind ((type (and object (js:get-property object "constructor"))))
        (or (%get-property type "%ralph-type")
            type))))

(define-function instance? (object type)
  (if object
      (bind ((type (%actual-type type)))
        (js:or
         ;; primitive
         (%has-constructor? object type)
         ;; object
         ((js:get-property type "prototype"
                           "isPrototypeOf")
          object)))
      (js:or (js:=== type <boolean>)
             (js:=== type (js:identifier "Boolean")))))

(define-function check-type (value type)
  (unless (instance? value type)
    ;; TODO: throw condition
    (error "check-type failed")))

(define-class <object> ())
(define-class <string> ())
(define-class <number> ())
(define-class <array> ())
(define-class <boolean> ())
(define-class <function> ())

(define-function %alias-type (ralph-type javascript-type)
  (set! (js:get-property ralph-type "%js-type") javascript-type)
  (set! (js:get-property javascript-type "%ralph-type") ralph-type))

(%alias-type <object> (js:identifier "Object"))
(%alias-type <string> (js:identifier "String"))
(%alias-type <number> (js:identifier "Number"))
(%alias-type <array> (js:identifier "Array"))
(%alias-type <boolean> (js:identifier "Boolean"))
(%alias-type <function> (js:identifier "Function"))

;; generic

(define-function %make-generic (function-name)
  (js:var dispatcher (method (#rest arguments)
                       (js:var object (first arguments))
                       (js:var methods [])
                       (js:if (has? (js:get-property object "constructor" "prototype")
                                    function-name)
                              (push-last methods
                                         (js:get-property object "constructor"
                                                          "prototype" function-name)))
                       (js:var proto object)
                       (js:while (set! proto (js:get-property proto "__proto__"))
                         (js:if (has? proto function-name)
                                (push-last methods
                                           (js:get-property proto function-name))))
                       (js:for (((i 0)
                                 (js:< i (js:get-property methods "length"))
                                 (js:+ i 1)))
                         (set! (js:get-property methods i "%next-method")
                               (js:get-property methods (js:+ i 1))))
                       (js:if (js:get-property methods "length")
                              ((js:get-property (js:get-property methods 0) "apply")
                               object arguments)
                              #f)))
  (set! (js:get-property dispatcher "%generic") #t)
  (set! (js:get-property dispatcher "%name") function-name)
  dispatcher)

(define-generic initialize (object #rest))

(define-function initialize ((object <object>) #rest arguments)
  (js:var slots (js:get-property (type object) "%slots"))
  (js:if slots
         (js:for (((i 0)
                   (js:< i (js:get-property arguments "length"))
                   (js:+ i 2)))
           (js:var key (js:get-property arguments i "name"))
           (js:if (js:>= ((js:get-property slots "indexOf") key) 0)
                  (set! (js:get-property object key)
                        (js:get-property arguments (js:+ i 1)))))))

;; error

(define-class <error> ()
  message)

(%alias-type <error> (js:identifier "Error"))

;;

(define-generic concatenate (first #rest more))

(define-function concatenate ((first-string <string>) #rest more-strings)
  (reduce (method (current next)
            (js:+ current next))
          first-string
          more-strings))

(define-function concatenate ((first-array <array>) #rest more-arrays)
  (reduce %concat first-array more-arrays))

;;

(define-generic description (object))

(define-function description ((number <number>))
  (js:+ "" number))

(define-function description ((string <string>))
  (js:var escaped ((js:get-property string "replace")
                   "\"" "\\\"" "g"))
  (js:+ "\"" escaped "\""))

(define-function description ((array <array>))
  (js:+ "(" (join (map description array) " ") ")"))

(define-function description ((value <boolean>))
  (if value "#t" "#f"))

;;

(define-function signal ((error <error>))
  (js:throw error))

;;;; comparison

(define-generic binary= (object1 object2))
(define-generic binary< (object1 object2))

(define-function binary= (object1 object2)
  (js:and (js:=== (type object1)
                  (type object2))
          (js:== object1 object2)))

(define-function binary< (object1 object2)
  (js:and (js:=== (type object1)
                  (type object2))
          (js:< object1 object2)))

(define-function compare ((function <function>) object1 object2 more-objects)
  (js:var object object1)
  (js:var remaining (%concat [object2] more-objects))
  (js:while (not (empty? remaining))
    (js:var next (first remaining))
    (js:if (not (function object next))
      (js:return #f))
    (set! object next)
    (set! remaining (rest remaining)))
  #t)

(define-function = (object1 object2 #rest more-objects)
  (compare binary= object1 object2 more-objects))

(define-function == (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (js:=== object1 object2))
           object1 object2 more-objects))

(define-function < (object1 object2 #rest more-objects)
  (compare binary< object1 object2 more-objects))

(define-function <= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (and object1
                  object2
                  (or (binary< object1 object2)
                      (binary= object1 object2))))
           object1 object2 more-objects))

(define-function > (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
              (and object1
                   object2
                   (not (binary< object1 object2))
                   (not (binary= object1 object2))))
           object1 object2 more-objects))

(define-function >= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (and object1
                  object2
                  (or (not (binary< object1 object2))
                      (binary= object1 object2))))
           object1 object2 more-objects))

(define-function binary= ((array1 <array>) (array2 <array>))
  (and (= (size array1)
          (size array2))
       (block (return)
         (dotimes (i (size array1))
           (unless (= (get array1 i)
                      (get array2 i))
             (return #f)))
         #t)))

(define-function make-object (#rest key-vals)
  (bind ((object (make-object)))
    (for ((i 0 (+ i 2)))
         ((>= i (size key-vals)) object)
      (set! (get object (get key-vals i))
            (get key-vals (inc i))))))

;; symbols

(define-class <hash-symbol> ()
    name)

(%define *module* exports "_key"
         (make <hash-symbol> name: "key"))

(%define *module* exports "_rest"
         (make <hash-symbol> name: "rest"))


(define-class <symbol> ()
    name)

(define %symbols (make-object))

(define-function symbol (name)
  (bind ((name (as-lowercase name)))
    (or (get %symbols name)
        (set! (get %symbols name)
              (make <symbol> name: name)))))
(%define *module* exports "_s" symbol)

(define-function symbol-name (symbol)
  (get symbol "name"))

(define-function description ((symbol <symbol>))
  (get symbol "name"))

(define-function description ((keyword <keyword>))
  (concatenate (symbol-name keyword) ":"))

(define-function description ((symbol <hash-symbol>))
  (concatenate "#" (symbol-name symbol)))

(define-function identity (value)
  value)

(define-function repeatedly ((function <function>) (count <integer>))
  (bind ((result []))
    (dotimes (i count result)
      (push-last result (function)))))

(define-function min ((x <number>) #rest more)
  (bind ((result x))
    (do (method (other)
          (when (< other result)
            (set! result other)))
        more)
    result))

(define-function max ((x <number>) #rest more)
  (bind ((result x))
    (do (method (other)
          (when (> other result)
            (set! result other)))
        more)
    result))

(define-function abs (number)
  ((js:get-property "Math" "abs") number))

(define-function round (number)
  ((js:get-property "Math" "round") number))

(define-function floor (number)
  ((js:get-property "Math" "floor") number))

(define-function sin (number)
  ((js:get-property "Math" "sin") number))

(define-function cos (number)
  ((js:get-property "Math" "cos") number))

(define-function atan2 (x y)
  ((js:get-property "Math" "atan2") x y))

(define-function expt (base power)
  ((js:get-property "Math" "pow") base power))

(define-function sqrt (number)
  ((js:get-property "Math" "sqrt") number))

(define-function mod (number1 number2)
  (js:% number1 number2))

(define-function as-radiant (number)
  (js:* number (js:/ (js:get-property "Math" "PI") 180)))

(define-function remove! ((array <array>) value)
  (js:var key (find-key array (curry = value)))
  (when key
    ((js:get-property array "splice") key 1))
  array)

(define-function remove ((array <array>) value)
  (remove! (slice array) value))

(define-function extend! ((object1 <object>) (object2 <object>))
  (do (method (key)
        (set! (get object1 key)
              (get object2 key)))
      (keys object2))
  object1)

(define-function as-property-list (object #key keywords?)
  (js:var result [])
  (do (method (key)
        (push-last result
                   (if keywords?
                       (keyword (as-string key))
                       key))
        (push-last result (get object key)))
      (keys object))
  result)

(define-function as-object (property-list)
  (bind ((list (copy-sequence property-list))
         (result (make-object)))
    (until (empty? list)
      (bind ((key (pop list))
             (value (pop list)))
        (set! (get result
                   (if (instance? key <keyword>)
                       (symbol-name key)
                       (as-string key)))
              value)))
    result))