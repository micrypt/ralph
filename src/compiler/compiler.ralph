(define-module compiler
    import: (runtime/core runtime/format runtime/regexp
             compiler/reader)
    export: (compile macroexpand transform-asynchronous))

(define S symbol)

(define-function prepend-return (forms)
  (concatenate
   (but-last forms)
   (make-array
    (bind ((tail (last forms)))
      (if (= (first tail)
             (S "js:return"))
          (last forms)
          `(js:return ,tail))))))

(define-function argument-names (arguments)
  (map (method (argument)
         (if (instance? argument <array>)
             (first argument)
             argument))
       arguments))

(define-function required-arguments (arguments)
  (bind ((length (size arguments)))
    (bind-methods ((position (hash-symbol)
                     (find-key arguments (curry = hash-symbol)
                               failure: length)))
      (slice arguments 0
             (apply min length
                    (map position [#key #rest]))))))

(define-function function-declaration (name arguments body)
  (bind-methods ((position (symbol)
                  (find-key arguments (curry = symbol))))
    (bind ((required (required-arguments arguments))
           (body (if (and (> (size body) 1)
                          (instance? (first body) <string>))
                     ;; strip documentation
                     (slice body 1)
                     body))
           (rest-position (position #rest))
           (key-position (position #key))
           (rest/key-code []))
      ;; key
      (when (or rest-position
                key-position)
        (bind ((rest-var (if rest-position
                             (element arguments
                                      (inc rest-position))
                             (generate-symbol))))
          (push-last rest/key-code
                     `(js:var ,rest-var
                              (as-array js:arguments
                                        ,(size required))))
          (when key-position
            ;; check #rest and #key are in order
            (when (and rest-position
                       (< key-position rest-position))
              (signal (make <error>
                            message: "#key should appear after #rest")))
            (destructuring-bind (key-var value-var index-var)
                (repeatedly generate-symbol 3)
              (bind ((setter-code `(select ,key-var js:==)))
                (do (method (key)
                      (destructuring-bind (name default)
                          (if (instance? key <array>)
                              key
                              [key #f])
                        (push-last rest/key-code
                                   `(js:var ,name ,default))
                        (push-last setter-code
                                   `((,(keyword (symbol-name name)))
                                     (js:set ,name ,value-var)))))
                    (slice arguments (inc key-position)))
                (push-last rest/key-code
                           `(js:for (((,index-var 0)
                                      (js:< ,index-var
                                            (js:get-property ,rest-var "length"))
                                      (js:+ ,index-var 2)))
                                    (js:var ,key-var
                                            (js:get-property ,rest-var ,index-var))
                                    (js:var ,value-var
                                            (js:get-property ,rest-var
                                                             (js:+ ,index-var 1)))
                                    (when (keyword? ,key-var)
                                      ,setter-code))))))))
      ;; function
      `(js:function ,(or name (S "js:null"))
                    ,(argument-names required)
                    ,(concatenate `(begin)
                                  rest/key-code
                                  ;; body
                                  (prepend-return body))))))


(define *macros*
    (make-object
     "define-macro"
     (method (name arguments #rest body)
       (bind ((compiled (compile
                         (concatenate `(method ,arguments)
                                      body))))
         (set! (get *macros* (symbol-name name))
               (eval compiled)))
       #f)
     "make-array"
     (method (#rest elements)
       (concatenate `(js:array)
                    elements))
     "slice"
     (method (array start end)
       (concatenate `((js:get-property ,array "slice") ,start)
                    (if end `(,end) `())))
     "rest"
     (method (array)
       `((js:get-property ,array "slice") 1))
     "as-array"
     (method (arguments skip)
       `((js:get-property "Array" "prototype" "slice" "call")
         ,arguments ,(or skip 0)))
     "size"
     (method (object)
       `(js:get-property ,object "length"))
     "has?"
     (method (object property)
       `((js:get-property ,object "hasOwnProperty")
         ,property))
     "%has-constructor?"
     (method (object constructor)
       `(js:=== (js:get-property ,object "constructor")
                ,constructor))
     "%backquote"
     (method (form)
       (bind-methods ((transform (form)
                        (cond
                          ((and (instance? form <array>)
                                (not (empty? form)))
                           (if (= (first form)
                                  (S "%comma"))
                               (second form)
                               (concatenate `(make-array)
                                            (map transform
                                                 form))))
                          ((instance? form <symbol>)
                           `(symbol ,(symbol-name form)))
                          (else:
                           form))))
         (transform form)))
;; TODO:
;;     "%comma"
;;     (method (value)
;;       (signal (make <error> message: "comma not inside backquote")))
     "%parallel-set"
     (method (#rest clauses)
       (bind ((temp-clauses [])
              (set-clauses []))
         (if (> (size clauses) 2)
             (begin
              (for ((i 0 (+ i 2)))
                   ((>= i (size clauses)))
               (bind ((temp (generate-symbol)))
                  (push-last temp-clauses
                             `(js:var ,temp ,(element clauses (inc i))))
                  (push-last set-clauses
                             `(js:set ,(element clauses i) ,temp))))
              (concatenate `(begin)
                           temp-clauses
                           set-clauses))
             (concatenate `(js:set)
                          clauses))))
     "define"
     (method (name value)
       (concatenate `(%define *module* exports
                              (js:escape ,name))
                    (if value `(,value) `())))
     "if"
     (method (test then else)
       `(js:if (true? ,test)
               ,then
               ,else))
     "when"
     (method (test #rest body)
       `(if ,test
            ,(concatenate `(begin) body)
            #f))
     "unless"
     (method (test #rest body)
       `(if (not ,test)
            ,(concatenate `(begin) body)
            #f))
     "bind"
     (method (bindings #rest body)
       (destructuring-bind ((var value) #rest other) bindings
         (concatenate
          `(,(concatenate `(js:function js:null (,var))
                          `(,(if (empty? other)
                                 (concatenate `(begin)
                                              (prepend-return body))
                                 (concatenate `(js:return
                                                ,(concatenate
                                                  `(bind ,other)
                                                  body)))))))
          (if value `(,value) `()))))
     "if-bind"
     (method (binding then else)
       (destructuring-bind (var value) binding
         (bind ((temp (generate-symbol)))
           `(bind ((,temp ,value))
              (if ,temp
                  (bind ((,var ,temp))
                    ,then)
                  ,else)))))
     "set!"
     (method (expression value)
       (if (and (instance? expression <array>)
                (not (= (first expression)
                        (S "js:get-property"))))
           (concatenate `(%set)
                        expression
                        `(,value))
           `(js:set ,expression ,value)))
     "while"
     (method (test #rest body)
       `((js:function js:null ()
           ,(concatenate
             `(begin)
             `(,(concatenate `(js:while ,test)
                             body)
                (js:return #f))))))
     "until"
     (method (test #rest body)
       (concatenate `(while (not ,test))
                    body))
     "define-generic"
     (method (name arguments)
       `(define ,name
          (%make-generic (js:escape ,name))))
     "and"
     (method (#rest expressions)
       (or (empty? expressions)
           `(when ,(concatenate `(js:and)
                                (map (method (expression)
                                       `(true? ,expression))
                                     (but-last expressions)))
              ,(last expressions))))
     "or"
     (method (#rest expressions)
       (and (not (empty? expressions))
            (bind ((variables [])
                   (clauses (map (method (expression)
                                   (bind ((temp (generate-symbol)))
                                     (push-last variables
                                                `(js:var ,temp))
                                     `((begin
                                        (set! ,temp ,expression)
                                        (true? ,temp))
                                       ,temp)))
                                 expressions)))
                  `((js:function js:null ()
                      ,(concatenate `(begin)
                                    variables
                                    `((js:return
                                        ,(concatenate `(cond)
                                                      clauses)))))))))
     "define-function"
     (method (name arguments #rest body)
       (destructuring-bind (setter? name)
           (if (and (instance? name <array>)
                    (= (size name) 2)
                    (first name)
                    (= (first name) (S "setter")))
               [#t (second name)]
               [#f name])
         (when (not (or (instance? name <symbol>)
                        setter?))
           (signal (make <error> message:
                         "define-function: name => symbol or (setter name)")))
         (bind ((type (if (empty? arguments)
                          (S "js:null")
                          (bind ((head (first arguments)))
                            (if (and (instance? head <array>)
                                     (> (size head) 1))
                                `(js:escape ,(second head))
                                "Object")))))
           `(,(if setter?
                  (S "%define-setter")
                  (S "%define-getter"))
              *module*
              exports
              (js:escape ,name)
              ,(function-declaration
                `(js:identifier "__method__")
                arguments body)
              ,type))))
     "inc!"
     (method (object value)
       `(set! ,object
              (js:+ ,object ,(or value 1))))
     "dotimes"
     (method (binding #rest body)
       (destructuring-bind (var count result) binding
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) (or result #f)))
                      body)))
     "for"
     (method (clauses end #rest body)
       (bind ((init-clauses [])
              (next-clauses []))
         (do (method (clause)
               (push-last init-clauses
                          (slice clause 0 2))
               (push-last next-clauses
                          (first clause))
               (push-last next-clauses
                          (third clause)))
             clauses)
         `(bind ,init-clauses
            ,(concatenate `(while (not ,(first end)))
                          body
                          `(,(concatenate `(%parallel-set)
                                          next-clauses)))
            ,(if (empty? (rest end))
                 #f
                 (second end)))))
     "method"
     (method (arguments #rest body)
       (function-declaration (S "js:null")
                             arguments body))
     "cond"
     (method (#rest cases)
       (if (empty? cases)
           #f
           (destructuring-bind (test #rest then) (first cases)
             (bind ((then (concatenate `(begin) then)))
               (if (= test else:)
                   then
                   `(if ,test
                        ,then
                        ,(concatenate `(cond)
                                      (rest cases))))))))
     "select"
     (method (value test #rest cases)
        (bind-methods ((test-expression (test-value)
                         `(,test ,value ,test-value)))
          (concatenate `(cond)
                       (map (method (case)
                              (destructuring-bind (tests #rest then) case
                                (if (= tests else:)
                                    case
                                    (concatenate
                                     `(,(concatenate `(or)
                                                     (map test-expression tests)))
                                     then))))
                            cases))))
     "handler-case"
     (method (body #rest conditions)
       (bind ((condition-var (generate-symbol)))
         `((js:function js:null ()
             (begin
               (js:try
                (js:return ,body)
                ,condition-var
                ,(concatenate
                  `(cond)
                  (map (method (condition)
                         (destructuring-bind ((type #rest arguments) #rest body)
                             condition
                           (concatenate `((instance? ,condition-var ,type))
                                        (destructuring-bind (#key condition)
                                            arguments
                                          (if condition
                                              `((js:var ,condition ,condition-var))
                                              `()))
                                        (prepend-return body))))
                       conditions))))))))
     "define-class"
     (method (class superclass #rest slots)
       (concatenate `(begin
                      (%define-class
                       *module* exports
                       (js:escape ,class)
                       ,(first superclass)
                       ,(concatenate `(make-array)
                                     (map (method (slot)
                                            (concatenate
                                             `(make-array)
                                             (if (instance? slot <array>)
                                                 [(symbol-name (first slot))
                                                  (second slot)]
                                                 [(symbol-name slot) #f])))
                                          slots))))
                    (if (empty? slots)
                        `()
                        `(,(bind ((rest (generate-symbol)))
                             (concatenate `(define-function initialize
                                             ,(concatenate `((object ,class) #rest ,rest #key) slots))
                                          (map (method (slot)
                                                 `(set! (js:get-property object
                                                                         ,(symbol-name slot))
                                                        ,slot))
                                             (argument-names slots))
                                          `((apply next-method object ,rest))))))))
     "define-module"
     (method (name #key (import `()) (export `()))
       (bind ((property (generate-symbol)))
         (concatenate `(begin
                        (js:var *module* js:this)
                        (js:set (js:get-property *module* "%exports")
                                ,(concatenate `(js:array)
                                              (map (method (name)
                                                     (if (instance? name <symbol>)
                                                         (escape-symbol name)
                                                         (write name)))
                                                   export))))
                      (map (method (name)
                             (bind ((module (generate-symbol)))
                               `(begin
                                 (js:var ,module (require ,(symbol-name name)))
                                 (js:for-in (,property ,module)
                                   (js:if ((js:get-property ,module "hasOwnProperty")
                                           ,property)
                                          (js:set (js:get-property *module* ,property)
                                                  (js:get-property ,module ,property)))))))
                           import))))
     "block"
     (method (argument #rest body)
        (destructuring-bind ((name)) argument
          (if name
              (bind ((condition (generate-symbol)))
                `(js:try
                  (js:return
                   ,(concatenate `(bind ((,name (%make-non-local-exit-function
                                                 ,(symbol-name name)))))
                                 body))
                  ,condition
                  (if (and (%non-local-exit? ,condition)
                           (js:=== (js:get-property ,condition "name")
                                   ,(symbol-name name)))
                      (js:return (js:get-property ,condition "value"))
                      (js:throw ,condition))))
              (concatenate `(begin) body))))
     "dotimes"
     (method (var/count/result #rest body)
       (destructuring-bind (var count result)
           var/count/result
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) ,(or result #f)))
                      body)))
     "bind-methods"
     (method (bindings #rest body)
        (concatenate `(bind
                       ,(map (method (binding)
                               (destructuring-bind (name arguments #rest body)
                                   binding
                               `(,name ,(function-declaration
                                         name arguments body))))
                             bindings))
                     body))
     "destructuring-bind"
     (method (pattern value #rest body)
       (bind ((target))
         (bind-methods ((destructure (pattern value)
                          (bind ((nested [])
                                 (inner
                                  `(method ,(map (method (var)
                                                   (if (instance? var <array>)
                                                       (bind ((temp (generate-symbol)))
                                                         (push-last nested
                                                                    `(,var ,temp))
                                                         temp)
                                                       var))
                                                 pattern)))
                                 (wrapper `(apply ,inner ,value)))
                            (set! target inner)
                            (do (method (n)
                                  (bind ((sub-wrapper (apply destructure n)))
                                    (push-last inner sub-wrapper)
                                    (set! inner (second sub-wrapper))))
                                nested)
                            wrapper)))
         (bind ((wrapping (destructure pattern value)))
           (replace-subsequence! target body start: (size target))
           wrapping))))
     "bind-properties"
     (method (properties object #rest body)
       (bind ((object* (generate-symbol)))
         `((js:function js:null (,object*)
            ,(concatenate `(begin)
                          (map (method (property)
                                 `(js:var ,property
                                          (js:get-property ,object*
                                                           ,(symbol-name property))))
                               properties)
                          (prepend-return body)))
          ,object)))))

(define *symbol-macros*
  (make-object
   "this-method" (js:identifier "__method__")
   "next-method" `(js:get-property  (js:identifier "__method__") "%next-method")))

(define *special-forms*
    (make-object
     "make-object" 0
     "js:array" 0
     "js:defined" 0
     "js:delete" 0
     "js:negative" 0
     "js:not" 0
     "begin" 0
     "js:if" 0
     "js:throw" 0
     "js:return" 0
     "js:while" 0
     "js:new" 1
     "js:var" 1
     "js:set" 1
     "js:for-in" 1
     "js:function" 2
     "js:escape" #f
     "js:identifier" #f
     "js:get-property" #f
     "js:for"
     (method (clauses #rest body)
       (concatenate
        `(js:for
          ,(map (method (clause)
                  (destructuring-bind ((var value) #rest rest) clause
                    (concatenate
                     [[var (macroexpand value)]]
                     (map macroexpand rest))))
                clauses))
        (macroexpand body)))
     "js:try"
     (method (body var catch finally)
       `(js:try
         ,(macroexpand body)
         ,var
         ,(macroexpand catch)
         ,(macroexpand finally)))))

(define *infix*
    (make-object
     "js:and" "&&"
     "js:or" "||"
     "js:+" "+"
     "js:-" "-"
     "js:*" "*"
     "js:/" "/"
     "js:>" ">"
     "js:<" "<"
     "js:>=" ">="
     "js:<=" "<="
     "js:==" "=="
     "js:===" "==="
     "js:instanceof" "instanceof"
     "js:&" "&"
     "js:|" "|"))

(define *symbols*
    (make-object
     "js:null" "null"
     "js:this" "this"
     "js:undefined" "undefined"
     "js:arguments" "arguments"))

(define *symbol-escapes*
    (make-object
     "-" "_M_"
     "+" "_PL_"
     "!" "_B_"
     "?" "_W_"
     "%" "_PE_"
     "#" "_H_"
     "@" "_A_"
     "*" "_ST_"
     "/" "_SL_"
     "=" "_E_"
     ":" "_C_"
     "<" "_LT_"
     ">" "_GT_"
     "_" "__"
     "[" "_SO_"
     "]" "_SC_"
     "{" "_BO_"
     "}" "_BC_"))

(define *reserved*
    (make-array
     "break" "case" "catch" "continue" "default" "delete" "do" "else"
     "finally" "for" "function" "if" "in" "instanceof" "new" "return"
     "switch" "this" "throw" "try" "typeof" "var" "void" "while"
     "with" "abstract" "boolean" "byte" "char" "class" "const"
     "debugger" "double" "enum" "export" "extends" "final" "float"
     "goto" "implements" "import" "int" "interface" "long" "native"
     "package" "private" "protected" "public" "short" "static" "super"
     "synchronized" "throws" "transient" "volatile" "null" "true" "false"
     "arguments" "object" "number" "string" "array"))

(define *symbol-count* 0)

(define-function generate-symbol ()
  (bind ((symbol (make <symbol> name:
                       (concatenate "_" (as-string *symbol-count*)))))
    (inc! *symbol-count*)
    (set! (get symbol "generated") #t)
    symbol))

(define *hyphen-pattern*
    (make <regexp>
          pattern: "-(.)"
          global?: #t))

(define-function escape (name)
  (join (map (method (char)
               (if-bind (replacement (get *symbol-escapes* char))
                 replacement
                 char))
             (as-array
              (replace name *hyphen-pattern*
                       (method (match)
                         (as-uppercase (second match)))))) ""))

(define-function escape-symbol (symbol)
  (bind ((name (symbol-name symbol)))
    (cond
      ((has? symbol "generated")
       name)
      ((member? name *reserved*)
       (concatenate "_" name))
      ((and (= (first name) "<")
            (= (last name) ">")
            (> (size name) 2))
       (concatenate "_CL_"
                    (escape (but-last (rest name)))))
      ((and (= (first name) "*")
            (= (last name) "*")
            (> (size name) 2))
       (as-uppercase
        (escape (but-last (rest name)))))
      (else:
       (escape name)))))

(define-function wrap-block (code)
  (concatenate
   "(function(){\n" code "\n})()"))

(define-function write-body (body)
  (write-statements
   (concatenate `(begin) body)))

(define *property-pattern*
    (make <regexp>
          pattern: "^[a-z_]+[a-z0-9]*$"
          ignore-case?: #t))

(define *writers*
    (make-object
     "js:negative"
     (method (_ object)
       (concatenate
        "(- " (write object) ")"))
     "js:not"
     (method (_ expression)
       (concatenate
        "!" (write expression)))
     "begin"
     (method (statements? #rest forms)
       (cond
         (statements?
          (join (map write-statements
                     forms)
                ";\n"))
         ((> (size forms) 1)
          (concatenate
           "(" (join (map write forms) ", ") ")"))
         (else:
          (write (first forms)))))
     "js:if"
     (method (statements? test then else)
       (if statements?
           (concatenate
            "if (" (write test) ") {\n"
            (write-statements then)
            "\n}"
            (if else
                (concatenate
                 " else {\n" (write-statements else) "\n}")
                ""))
           (concatenate
            "(" (write test)
            " ? " (write then)
            " : " (write else)
            ")")))
     "js:array"
     (method (_ #rest elements)
       (concatenate
        "[" (join (map write elements) ", ") "]"))
     "js:defined"
     (method (_ expression)
       (concatenate
        "(typeof (" (write expression) ") != 'undefined')"))
     "js:delete"
     (method (_ expression)
       (concatenate "(delete (" (write expression) "))"))
     "js:try"
     (method (statements? body condition catch finally)
       (bind ((result
               (concatenate
                "try {\n"
                (write-statements body)
                "\n}"
                (if catch
                    (concatenate
                     " catch (" (write condition) ") {\n"
                     (write-statements catch) "\n}")
                    "")
                (if finally
                    (concatenate
                     " finally {\n"
                     (write-statements finally)
                     "\n}")
                  ""))))
         (if statements?
             result
             (wrap-block result))))
     "js:for-in"
     (method (statements? variable/expression #rest body)
        (destructuring-bind (variable expression) variable/expression
          (bind ((result
                  (concatenate
                   "for (var " (write variable)
                   " in " (write expression) ") {\n"
                   (write-body body) "\n}")))
            (if statements?
                result
                (wrap-block result)))))
     "js:for"
     (method (statements? clauses #rest body)
       (bind ((inits [])
              (tests [])
              (nexts []))
         (do (method (clause)
               (destructuring-bind ((var value) test next) clause
                 (bind ((set (S "js:set")))
                   (push-last inits (write [set var value]))
                   (push-last tests (write test))
                   (push-last nexts (write [set var next])))))
             clauses)
         (bind ((result
                 (concatenate
                  "for (var "
                  (join (map (method (parts)
                               (join parts ", "))
                             [inits tests nexts])
                        "; ")
                  ") {\n" (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result)))))
     "js:while"
     (method (statements? test #rest body)
       (bind ((result
               (concatenate
                "while (" (write test) ") {\n"
                (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result))))
     "js:identifier"
     (method (_ identifier)
       (as-string identifier))
     "js:get-property"
     (method (_ object #rest elements)
       (concatenate
        (if (instance? object <string>)
            object
            (write object))
        (apply concatenate
               (map (method (element)
                      (if (and (instance? element <string>)
                               (match *property-pattern* element))
                          (concatenate "." element)
                          (concatenate "[" (write element) "]")))
                    elements))))
     "js:new"
     (method (_ name #rest arguments)
       (concatenate
        "new " (write name)
        " (" (join (map write arguments) ", ") ")"))
     "js:var"
     (method (_ name value)
       (concatenate
        "var " (write name)
        (if (and value
                 (not (= value (S "js:undefined"))))
            (concatenate " = " (write value))
            "")))
     "js:set"
     (method (_ name value)
       (concatenate (write name) " = " (write value)))
     "js:return"
     (method (_ body)
       (concatenate "return " (write body)))
     "js:function"
     (method (_ name arguments body)
       (concatenate
        "function "
        (if (and name
                 (not (= name (S "js:null"))))
            (concatenate (if (instance? name <array>)
                             (write name)
                           (escape-symbol name))
                           " ")
            "")
        "(" (join (map write arguments) ", ") ") {"
        (if body
            (concatenate "\n" (write-statements body) "\n")
            "")
        "}"))
     "js:escape"
     (method (_ symbol)
       (write (escape-symbol symbol)))
     "js:throw"
     (method (statements? error)
       (bind ((result (concatenate "throw " (write error))))
             (if statements?
                 result
                 (wrap-block result))))
     "make-object"
     (method (_ #rest key-values)
       (bind ((entries []))
         (for ((i 0 (+ i 2)))
              ((>= i (size key-values)))
           (push-last entries
                      (concatenate
                       (write (element key-values i)) ":"
                       (write (element key-values (+ i 1))))))
         (concatenate "{" (join entries ",\n") "}")))))

(define-function compile (form #key statements?)
  (write (macroexpand form)
         statements?: statements?))

(define-function macroexpand (form)
  (select form instance?
    ((<array>)
     ;; apply macros
     (while (and (instance? form <array>)
                 (instance? (first form) <symbol>)
                 (has? *macros* (symbol-name (first form))))
       (bind ((macro (get *macros* (symbol-name (first form)))))
         (set! form (apply macro (rest form)))))
     ;; still array?
     (if (instance? form <array>)
         (bind ((head (first form)))
           ;; special?
           (if (and (instance? head <symbol>)
                    (has? *special-forms*
                          (symbol-name head)))
               (bind ((expander (get *special-forms*
                                     (symbol-name head))))
                 (select expander instance?
                   ((<number>)
                    (concatenate
                     ;; skip n arguments, macroexpand rest
                     (slice form 0 (inc expander))
                     (map macroexpand (slice form (inc expander)))))
                   ((<function>)
                    ;; custom expander
                    (apply expander (rest form)))
                   (else:
                    ;; form mustn't be expanded
                    form)))
             ;; not special
             (map macroexpand form)))
         ;; not an array
         (macroexpand form)))
    ((<symbol>)
     ;; symbol-macro?
     (if-bind (symbol-macro (get *symbol-macros*
                                 (symbol-name form)))
       (macroexpand symbol-macro)
       form))
    (else: form)))

(define-function write (form #key statements?)
  (select form instance?
    ;; array?
    ((<array>)
     (bind ((head (first form))
            (head-name (symbol-name head))
            (tail (rest form)))
       (cond
         ;; infix?
         ((and (instance? head <symbol>)
               (has? *infix* head-name))
          (bind ((infix (get *infix* head-name))
                 (inside (join (map write tail)
                               (concatenate " " infix " "))))
            (concatenate "(" inside ")")))
         ;; writer?
         ((and (instance? head <symbol>)
               (has? *writers* head-name))
          (apply (get *writers* head-name)
                 statements?
                 tail))
         ;; anonymous function call?
         ((and (instance? head <array>)
               (instance? (first head) <symbol>)
               (= (symbol-name (first head))
                  "js:function"))
          (concatenate "(" (write head) ")"
                       "(" (join (map write tail) ", ") ")"))
         (head
          (concatenate
           (write head)
           "(" (join (map write tail) ", ") ")"))
         (else:
          "[]"))))
    ((<symbol>)
     (if-bind (symbol (get *symbols* (symbol-name form)))
       symbol
       (escape-symbol form)))
    ((<hash-symbol>)
     (concatenate "_" (symbol-name form)))
    ((<keyword>)
     (concatenate "_k('" (symbol-name form) "')"))
    ((<boolean>)
     (if form "true" "false"))
    ((<string>)
     (concatenate "\"" form "\""))
    (else:
     (description form))))

(define write-statements
    (rcurry write statements?: #t))

(define-function transform-asynchronous (form)
  (bind ((modules []))
    (bind-methods ((walk (current parent)
                     (bind ((proceed? (instance? current <array>)))
                       (when (and proceed?
                                  (== (size current) 3))
                         (destructuring-bind (var variable-name value) current
                           (when (== var (S "js:var"))
                             (destructuring-bind (require module-name) value
                               (when (== require (S "require"))
                                 (push-last modules [variable-name module-name])
                                 (bind ((index (position parent current)))
                                   (replace-subsequence! parent []
                                                         start: index
                                                         end: (inc index)))
                                 (set! proceed? #f))))))
                       (when proceed?
                         (do (method (form)
                               (walk form current))
                             (rest current))))))
    (walk form)
    (do (method (binding)
          (destructuring-bind (variable module) binding
              (set! form
                    `(require ,module
                              (js:function js:null (,variable)
                                 ,form)))))
        modules)
    form)))

