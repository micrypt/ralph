(define-module compiler
    import: (runtime/core runtime/format runtime/regexp
             compiler/reader)
    export: (compile macroexpand transform-asynchronous))

(define S symbol)


(define *type-name->constructor-name*
  (make-object
   "<string>" "String"
   "<number>" "Number"
   "<boolean>" "Boolean"))

(define-function prepend-return (forms)
  (concatenate
   (but-last forms)
   (make-array
    (bind ((tail (last forms)))
      (if (== (first tail)
              (S "js:return"))
          (last forms)
          `(js:return ,tail))))))

(define-function argument-names (arguments)
  (map (method (argument)
         (if (instance? argument <array>)
             (first argument)
             argument))
       arguments))

(define-function required-arguments (arguments)
  (bind ((length (size arguments)))
    (bind-methods ((position (hash-symbol)
                     (find-key arguments (curry = hash-symbol)
                               failure: length)))
      (slice arguments 0
             (apply min length
                    (map position [#key #rest]))))))

(define-function function-declaration (name arguments body)
  (bind-methods ((position (symbol)
                  (find-key arguments (curry = symbol))))
    (bind ((required (required-arguments arguments))
           (body (if (and (> (size body) 1)
                          (instance? (first body) <string>))
                     ;; strip documentation
                     (slice body 1)
                     body))
           (rest-position (position #rest))
           (key-position (position #key))
           (rest/key-code []))
      ;; key
      (when (or rest-position
                key-position)
        (bind ((rest-var (if rest-position
                             (element arguments
                                      (inc rest-position))
                             (generate-symbol))))
          (push-last rest/key-code
                     `(js:var ,rest-var
                              (as-array js:arguments
                                        ,(size required))))
          (when key-position
            ;; check #rest and #key are in order
            (when (and rest-position
                       (< key-position rest-position))
              (signal (make <error>
                            message: "#key should appear after #rest")))
            (destructuring-bind (key-var value-var index-var)
                (repeatedly generate-symbol 3)
              (bind ((setter-code `(select ,key-var js:==)))
                (do (method (key)
                      (destructuring-bind (name default)
                          (if (instance? key <array>)
                              key
                              [key #f])
                        (push-last rest/key-code
                                   `(js:var ,name ,default))
                        (push-last setter-code
                                   `((,(keyword (symbol-name name)))
                                     (js:set ,name ,value-var)))))
                    (slice arguments (inc key-position)))
                (push-last rest/key-code
                           `(js:for (((,index-var 0)
                                      (js:< ,index-var
                                            (js:get-property ,rest-var "length"))
                                      (js:+ ,index-var 2)))
                                    (js:var ,key-var
                                            (js:get-property ,rest-var ,index-var))
                                    (js:var ,value-var
                                            (js:get-property ,rest-var
                                                             (js:+ ,index-var 1)))
                                    (when (keyword? ,key-var)
                                      ,setter-code))))))))
      ;; function
      `(js:function ,(or name (S "js:null"))
                    ,(argument-names required)
                    ,(concatenate `(begin)
                                  rest/key-code
                                  ;; body
                                  (prepend-return body))))))

(define-function display-name (name arguments #key setter?)
  (concatenate
   "(" (if setter?
           (concatenate "(setter " (symbol-name name) ")")
           (symbol-name name))
   (bind ((specializers? #t))
       (join (map (method (argument)
                    (when (or (== argument #key)
                              (== argument #rest))
                      (set! specializers? #f))
                    (if specializers?
                        (concatenate
                         " " (if (instance? argument <array>)
                                 (symbol-name (second argument))
                                 "<object>"))
                        ""))
                  arguments)
             ""))
   ")"))


(define *macros*
    (make-object
     "define-macro"
     (method (name arguments #rest body)
       (bind ((compiled (compile
                         (concatenate `(method ,arguments)
                                      body))))
         (set! (get *macros* (symbol-name name))
               (eval (concatenate "(" compiled ")"))))
       #f)
     "%has-constructor?"
     (method (object constructor)
       `(js:=== (js:get-property ,object "constructor")
                ,constructor))
     "%backquote"
     (method (form)
       (bind-methods ((transform (form)
                        (cond
                          ((and (instance? form <array>)
                                (not (empty? form)))
                           (if (== (first form)
                                   (S "%comma"))
                               (second form)
                               (concatenate `(make-array)
                                            (map transform
                                                 form))))
                          ((instance? form <symbol>)
                           `(symbol ,(symbol-name form)))
                          (else:
                           form))))
         (transform form)))
;; TODO:
;;     "%comma"
;;     (method (value)
;;       (signal (make <error> message: "comma not inside backquote")))
     "%parallel-set"
     (method (#rest clauses)
       (bind ((temp-clauses [])
              (set-clauses []))
         (if (> (size clauses) 2)
             (begin
              (for ((i 0 (+ i 2)))
                   ((>= i (size clauses)))
               (bind ((temp (generate-symbol)))
                  (push-last temp-clauses
                             `(js:var ,temp ,(element clauses (inc i))))
                  (push-last set-clauses
                             `(js:set ,(element clauses i) ,temp))))
              (concatenate `(begin)
                           temp-clauses
                           set-clauses))
             (concatenate `(js:set)
                          clauses))))
     "define"
     (method (name value)
       (concatenate `(%define *module* exports
                              (js:escape ,name))
                    (if value `(,value) `())))
     "if"
     (method (test then else)
       `(js:if (true? ,test)
               ,then
               ,else))
     "when"
     (method (test #rest body)
       `(if ,test
            ,(concatenate `(begin) body)
            #f))
     "unless"
     (method (test #rest body)
       `(if (not ,test)
            ,(concatenate `(begin) body)
            #f))
     "bind"
     (method (bindings #rest body)
       (bind ((vars (map first bindings)))
           (concatenate
            `((js:function js:null ,vars
                           ,(concatenate `(begin)
                                         (map (method (binding)
                                                (destructuring-bind (var value)
                                                    binding
                                                  `(js:set ,var ,value)))
                                              bindings)
                                         (prepend-return body))))
            (map (method (binding)
                   (destructuring-bind (var value) binding
                     `(js:and (js:defined ,var) ,var)))
                 bindings))))
     "if-bind"
     (method (binding then else)
       (destructuring-bind (var value) binding
         (bind ((temp (generate-symbol)))
           `(bind ((,temp ,value))
              (if ,temp
                  (bind ((,var ,temp))
                    ,then)
                  ,else)))))
     "set!"
     (method (expression #rest value-rest)
       (if (instance? expression <array>)
           (cond
            ((== (first expression)
                 (S "js:get-property"))
             `(js:set ,expression
                      ,(first value-rest)))
            ((and (== (first expression)
                      (S "get"))
                  (== (size expression) 3))
             `(js:set ,(concatenate `(js:get-property)
                                    (rest expression))
                      ,(first value-rest)))
            (else:
             (concatenate `(%set)
                          expression
                          value-rest)))
           `(js:set ,expression ,(first value-rest))))
     "get"
     (method (object #rest keys)
       (if (== (size keys) 1)
           `(%get-property ,object ,(first keys))
           (concatenate `(js:call get ,object)
                        keys)))
     "while"
     (method (test #rest body)
       `((js:function js:null ()
           ,(concatenate
             `(begin)
             `(,(concatenate `(js:while (true? ,test))
                             body)
                (js:return #f))))))
     "until"
     (method (test #rest body)
       (concatenate `(while (not ,test))
                    body))
     "define-generic"
     (method (name arguments)
       `(define ,name
          (%make-generic (js:escape ,name)
                         ,(display-name name arguments))))
     "not"
     (method (value)
       `(js:not (true? ,value)))
     "true?"
     (method (value)
       (if (and (instance? value <array>)
                (any? (curry == (first value))
                      [(S "not") (S "js:not")]))
           value
           `(js:call true? ,value)))
     "and"
     (method (#rest expressions)
       (or (empty? expressions)
           `(js:if ,(concatenate `(js:and)
                                 (map (method (expression)
                                        `(true? ,expression))
                                      (but-last expressions)))
                   ,(last expressions)
                   #f)))
     "or"
     (method (#rest expressions)
       (bind ((temp (generate-symbol)))
         (bind-methods ((test (expressions)
                          (if (empty? expressions)
                              #f
                              `(begin
                                (set! ,temp ,(first expressions))
                                (js:if (true? ,temp)
                                       (js:return ,temp)
                                       ,(test (rest expressions)))))))
           `((js:function js:null (,temp)
               ,(test expressions))))))
     "define-function"
     (method (name arguments #rest body)
       (destructuring-bind (setter? name)
           (if (and (instance? name <array>)
                    (== (size name) 2)
                    (first name)
                    (== (first name) (S "setter")))
               [#t (second name)]
               [#f name])
         (when (not (or (instance? name <symbol>)
                        setter?))
           (signal (make <error> message:
                         "define-function: name => symbol or (setter name)")))
         (bind ((type (if (empty? arguments)
                          "null"
                          (bind ((head (first arguments)))
                            (if (and (instance? head <array>)
                                     (> (size head) 1))
                                (escape-symbol (second head))
                                "Object")))))
           `(,(if setter?
                  (S "%define-setter")
                  (S "%define-getter"))
             *module*
             exports
             (js:escape ,name)
             ,(function-declaration
               `(js:inline "__method__")
               arguments body)
             (js:inline ,type)
             ,(display-name name arguments setter?: setter?)))))
     "inc"
     (method (object)
       `(js:+ ,object 1))
     "dec"
     (method (object)
       `(js:- ,object 1))
     "dotimes"
     (method (binding #rest body)
       (destructuring-bind (var count result) binding
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) (or result #f)))
                      body)))
     "for"
     (method (clauses end #rest body)
       (bind ((init-clauses [])
              (next-clauses []))
         (do (method (clause)
               (push-last init-clauses
                          (slice clause 0 2))
               (push-last next-clauses
                          (first clause))
               (push-last next-clauses
                          (third clause)))
             clauses)
         `(bind ,init-clauses
            ,(concatenate `(while (not ,(first end)))
                          body
                          `(,(concatenate `(%parallel-set)
                                          next-clauses)))
            ,(if (empty? (rest end))
                 #f
                 (concatenate `(begin)
                              (rest end))))))
     "method"
     (method (arguments #rest body)
       (function-declaration (S "js:null")
                             arguments body))
     "cond"
     (method (#rest cases)
       (if (empty? cases)
           #f
           (destructuring-bind (test #rest then) (first cases)
             (bind ((then (concatenate `(begin) then)))
               (if (== test else:)
                   then
                   `(if ,test
                        ,then
                        ,(concatenate `(cond)
                                      (rest cases))))))))
     "select"
     (method (value test #rest cases)
       (bind ((value-var (generate-symbol))
              (infix? (and (instance? test <symbol>)
                           (has? *infix* (symbol-name test))))
              (test-var (if infix?
                            test
                            (generate-symbol))))
         (bind-methods ((test-expression (test-value)
                          `(,test-var ,value-var ,test-value)))
           `((js:function js:null ()
               ,(concatenate `(begin
                               (js:var ,value-var ,value))
                             (if infix? `() `((js:var ,test-var ,test)))
                             `((js:return
                                ,(concatenate
                                  `(cond)
                                  (map (method (case)
                                         (destructuring-bind (tests #rest then) case
                                           (if (== tests else:)
                                               case
                                               (concatenate
                                                `(,(concatenate
                                                    `(or)
                                                    (map test-expression tests)))
                                                then))))
                                       cases))))))))))
     "handler-case"
     (method (body #rest conditions)
       (bind ((condition-var (generate-symbol)))
         `((js:function js:null ()
             (begin
               (js:try
                (js:return ,body)
                ,condition-var
                ,(concatenate
                  `(cond)
                  (map (method (condition)
                         (destructuring-bind ((type #rest arguments) #rest body)
                             condition
                           (concatenate `((instance? ,condition-var ,type))
                                        (destructuring-bind (#key condition)
                                            arguments
                                          (if condition
                                              `((js:var ,condition ,condition-var))
                                              `()))
                                        (prepend-return body))))
                       conditions))))))))
     "define-class"
     (method (class superclass #rest slots)
       `(%define-class
         *module* exports
         (js:escape ,class)
         ,(first superclass)
         ,(bind ((object `(make-object)))
            (do (method (slot)
                  (if (instance? slot <array>)
                      (begin
                       (push-last object (symbol-name (first slot)))
                       (push-last object `(method ()
                                            ,(second slot))))
                      (begin
                       (push-last object (symbol-name slot))
                       (push-last object #f))))
                slots)
            object)))
     "define-module"
     (method (name #key (import `()) (export `()))
       (bind ((property (generate-symbol))
              (module (generate-symbol))
              (i (generate-symbol))
              (modules []))
         (concatenate `(begin
                        (js:var *module*
                                (js:if (js:defined (js:inline "GLOBAL"))
                                       (js:inline "GLOBAL")
                                       js:this)))
                      (map (method (name)
                             (bind ((module (generate-symbol)))
                                 (push-last modules module)
                                 `(js:var ,module (require ,(symbol-name name)))))
                           import)
                      (if (empty? modules)
                          `()
                          `((js:for (((,i 0)
                                      (js:< ,i ,(size modules))
                                      (js:+ ,i 1)))
                              (js:var ,module (js:get-property ,(concatenate `(js:array) modules) ,i))
                              (js:for-in (,property ,module)
                                (js:if ((js:get-property ,module "hasOwnProperty")
                                        ,property)
                                       (js:set (js:get-property *module* ,property)
                                               (js:get-property ,module ,property)))))))
                      `((js:set (js:get-property *module* "%exports")
                                ,(concatenate `(js:array)
                                              (map (method (name)
                                                     (if (instance? name <symbol>)
                                                         (escape-symbol name)
                                                         (write name)))
                                                   export)))))))
     "block"
     (method (argument #rest body)
        (destructuring-bind ((name)) argument
          (if name
              (bind ((condition (generate-symbol)))
                `(js:try
                  (js:return
                   ,(concatenate `(bind ((,name (%make-non-local-exit-function
                                                 ,(symbol-name name)))))
                                 body))
                  ,condition
                  (if (and (%non-local-exit? ,condition)
                           (js:=== (js:get-property ,condition "name")
                                   ,(symbol-name name)))
                      (js:return (js:get-property ,condition "value"))
                      (js:throw ,condition))))
              (concatenate `(begin) body))))
     "dotimes"
     (method (var/count/result #rest body)
       (destructuring-bind (var count result)
           var/count/result
         (concatenate `(for ((,var 0 (js:+ ,var 1)))
                            ((js:>= ,var ,count) ,(or result #f)))
                      body)))
     "for-each"
     (method (clauses end #rest body)
       (bind ((temporaries (map (method (clause)
                                  (concatenate [(generate-symbol)]
                                               clause))
                                clauses))
              (bindings (generate-symbol)))
       `((js:function js:null ()
           ,(concatenate `(begin)
                         (map (method (clause)
                                `(js:var ,(first clause)))
                              clauses)
                         (map (method (temporary)
                                `(js:var ,(first temporary)
                                         ,(third temporary)))
                              temporaries)
                         `((js:var ,bindings
                                   ,(concatenate `(js:array)
                                                 (map first temporaries)))
                           ,(concatenate
                             `(js:while #t
                                (js:if (any? empty? ,bindings)
                                       (js:return #f)))
                             (map (method (temporary)
                                    `(set! ,(second temporary)
                                           (first ,(first temporary))))
                                  temporaries)
                             `((js:if ,(first end)
                                      (js:return
                                       ,(if (empty? (rest end))
                                            #f
                                            (concatenate `(begin)
                                                         (rest end))))
                                      ,(concatenate `(begin)
                                                    body)))
                             (map (method (temporary)
                                    `(set! ,(first temporary)
                                           (rest ,(first temporary))))
                                  temporaries))))))))
     "bind-methods"
     (method (bindings #rest body)
        (concatenate `(bind
                       ,(map (method (binding)
                               (destructuring-bind (name arguments #rest body)
                                   binding
                               `(,name ,(function-declaration
                                         name arguments body))))
                             bindings))
                     body))
     "destructuring-bind"
     (method (pattern value #rest body)
       (bind ((target))
         (bind-methods ((destructure (pattern value)
                          (bind ((nested [])
                                 (inner
                                  `(method ,(map (method (var)
                                                   (if (instance? var <array>)
                                                       (bind ((temp (generate-symbol)))
                                                         (push-last nested
                                                                    `(,var ,temp))
                                                         temp)
                                                       var))
                                                 pattern)))
                                 (wrapper `(apply ,inner ,value)))
                            (set! target inner)
                            (do (method (n)
                                  (bind ((sub-wrapper (apply destructure n)))
                                    (push-last inner sub-wrapper)
                                    (set! inner (second sub-wrapper))))
                                nested)
                            wrapper)))
         (bind ((wrapping (destructure pattern value)))
           (replace-subsequence! target body start: (size target))
           wrapping))))
     "bind-properties"
     (method (properties object #rest body)
       (bind ((object* (generate-symbol)))
         `((js:function js:null (,object*)
            ,(concatenate `(begin)
                          (map (method (property)
                                 `(js:var ,property
                                          (js:get-property ,object*
                                                           ,(symbol-name property))))
                               properties)
                          (prepend-return body)))
           ,object)))
     ;; optimizations / "inlining"
     "instance?"
     (method (object type)
       (select type ==
         (((S "<array>"))
          `((js:inline "Array.isArray") ,object))
         (((S "<string>")
           (S "<number>")
           (S "<boolean>"))
          `(%has-constructor? ,object
            (js:inline ,(get *type-name->constructor-name*
                                 (symbol-name type)))))
         (else:
          `(js:call instance? ,object ,type))))
     "make-array"
     (method (#rest elements)
       (concatenate `(js:array)
                    elements))
     "slice"
     (method (array start end)
       (concatenate `((js:get-property ,array "slice"))
                    (if start `(,start) `())
                    (if end `(,end) `())))
     "rest"
     (method (array)
       `(slice ,array 1))
     "as-array"
     (method (arguments skip)
       `((js:get-property [] "slice" "call")
         ,arguments ,(js:or skip 0)))
     "size"
     (method (object)
       `(js:get-property ,object "length"))
     "has?"
     (method (object property)
       `((js:get-property ,object "hasOwnProperty")
         ,property))
     "but-last"
     (method (array n)
       (bind ((n (or n 1)))
         `(slice ,array 0 ,(if (instance? n <number>)
                               (* n -1)
                               `(js:* ,n -1)))))
     "push-last"
     (method (array value)
       `(begin
         ((js:get-property ,array "push") ,value)
         ,array))
     "push"
     (method (array value)
       `(begin
         ((js:get-property ,array "unshift") ,value)
         ,array))
     "pop"
     (method (array)
       `((js:get-property ,array "shift")))
     "pop-last"
     (method (array)
       `((js:get-property ,array "pop")))
     "reverse!"
     (method (array)
       `((js:get-property ,array "reverse")))
     "as-string"
     (method (object)
       `((js:get-property ,object "toString")))
     "as-number"
     (method (object)
       `((js:inline "Number") ,object))
     "%concat"
     (method (array1 array2)
       `((js:get-property ,array1 "concat") ,array2))
     "=="
     (method (#rest arguments)
       (concatenate
        (if (== (size arguments) 2)
            `(js:===)
            `(js:call ==))
        arguments))))

(do (method (comparison)
      (set! (get *macros* comparison)
            (method (#rest arguments)
              (concatenate
               (if (== (size arguments) 2)
                   `(,(S (concatenate "binary" comparison)))
                   `(js:call ,(S comparison)))
               arguments))))
    ["=" "<" ">" "<=" ">="])

(do (method (op)
      (set! (get *macros* op)
            (method (#rest arguments)
              (concatenate
               `(,(S (concatenate "js:" op)))
               arguments))))
    ["-" "+" "*" "/"])


(do (method (name/op)
      (destructuring-bind (name op) name/op
        (set! (get *macros* name)
              (method (object value)
                (if (or (not (instance? object <array>))
                        (and (instance? object <array>)
                             (or (== (first object)
                                     (S "js:get-property"))
                                 (and (== (first object)
                                          (S "get"))
                                      (== (size object) 3)))))
                    `(,(S (concatenate "js:" op "="))
                      ,(if (and (instance? object <array>)
                                (== (first object)
                                    (S "get")))
                           (concatenate `(js:get-property)
                                        (rest object))
                           object)
                      ,(or value 1))
                    `(set! ,object
                           (,(S (concatenate "js:" op))
                            ,object ,(or value 1))))))))
     [["inc!" "+"]
      ["dec!" "-"]])

(define *symbol-macros*
  (make-object
   "this-method" `(js:inline "__method__")
   "next-method" `(%next-method this-method)))

(define *special-forms*
    (make-object
     "make-object" 0
     "js:array" 0
     "js:defined" 0
     "js:delete" 0
     "js:negative" 0
     "js:not" 0
     "begin" 0
     "js:if" 0
     "js:throw" 0
     "js:return" 0
     "js:while" 0
     "js:new" 1
     "js:var" 1
     "js:set" 0
     "js:for-in" 1
     "js:function" 2
     "js:escape" #f
     "js:inline" #f
     "js:get-property" 0
     "js:for"
     (method (clauses #rest body)
       (concatenate
        `(js:for
          ,(map (method (clause)
                  (destructuring-bind ((var value) #rest rest) clause
                    (concatenate
                     [[var (macroexpand value)]]
                     (map macroexpand rest))))
                clauses))
        (macroexpand body)))
     "js:try"
     (method (body var catch finally)
       `(js:try
         ,(macroexpand body)
         ,var
         ,(macroexpand catch)
         ,(macroexpand finally)))))

(define *unary*
    (make-object
     "js:-" "-"))

(define *infix*
    (make-object
     "js:and" "&&"
     "js:or" "||"
     "js:+" "+"
     "js:+=" "+="
     "js:-" "-"
     "js:-=" "-="
     "js:*" "*"
     "js:/" "/"
     "js:%" "%"
     "js:>" ">"
     "js:<" "<"
     "js:>=" ">="
     "js:<=" "<="
     "js:==" "=="
     "js:===" "==="
     "js:instanceof" "instanceof"
     "js:&" "&"
     "js:|" "|"))

(define *symbols*
    (make-object
     "js:null" "null"
     "js:this" "this"
     "js:undefined" "undefined"
     "js:arguments" "arguments"
     "js:typeof" "typeof"))

(define *symbol-escapes*
    (make-object
     "-" "_M_"
     "+" "_PL_"
     "!" "_B_"
     "?" "_W_"
     "%" "_PE_"
     "#" "_H_"
     "@" "_A_"
     "*" "_ST_"
     "/" "_SL_"
     "=" "_E_"
     ":" "_C_"
     "<" "_LT_"
     ">" "_GT_"
     "_" "__"
     "[" "_SO_"
     "]" "_SC_"
     "{" "_BO_"
     "}" "_BC_"))

(define *reserved*
    (make-array
     "break" "case" "catch" "continue" "default" "delete" "do" "else"
     "finally" "for" "function" "if" "in" "instanceof" "new" "return"
     "switch" "this" "throw" "try" "typeof" "var" "void" "while"
     "with" "abstract" "boolean" "byte" "char" "class" "const"
     "debugger" "double" "enum" "export" "extends" "final" "float"
     "goto" "implements" "import" "int" "interface" "long" "native"
     "package" "private" "protected" "public" "short" "static" "super"
     "synchronized" "throws" "transient" "volatile" "null" "true" "false"
     "arguments" "object" "number" "string" "array"))

(define *symbol-count* 0)

(define-function generate-symbol ()
  (bind ((symbol (make <symbol> name:
                       (concatenate "_" (as-string *symbol-count*)))))
    (inc! *symbol-count*)
    (set! (get symbol "generated") #t)
    symbol))

(define *hyphen-pattern*
    (make <regexp>
          pattern: "-(.)"
          global?: #t))

(define-function escape (name)
  (join (map (method (char)
               (if-bind (replacement (get *symbol-escapes* char))
                 replacement
                 char))
             (as-array
              (replace name *hyphen-pattern*
                       (method (match)
                         (as-uppercase (second match)))))) ""))

(define-function escape-symbol (symbol)
  (bind ((name (symbol-name symbol)))
    (cond
      ((has? symbol "generated")
       name)
      ((member? name *reserved*)
       (concatenate "_" name))
      ((and (== (first name) "<")
            (== (last name) ">")
            (> (size name) 2))
       (concatenate "_CL_"
                    (escape (but-last (rest name)))))
      ((and (== (first name) "*")
            (== (last name) "*")
            (> (size name) 2))
       (as-uppercase
        (escape (but-last (rest name)))))
      (else:
       (escape name)))))

(define-function wrap-block (code)
  (concatenate
   "(function(){\n" code "\n})()"))

(define-function write-body (body)
  (write-statements
   (concatenate `(begin) body)))

(define *property-pattern*
    (make <regexp>
          pattern: "^[a-z_]+[a-z0-9]*$"
          ignore-case?: #t))

(define *writers*
  (make-object
   "js:call"
   (method (_ head #rest tail)
     (concatenate
      ;; anonymous function call?
      (if (and (instance? head <array>)
               (instance? (first head) <symbol>)
               (== (first head)
                   (S "js:function")))
          (concatenate "(" (write head) ")")
          (write head))
      "(" (join (map write tail) ", ") ")"))
     "js:negative"
     (method (_ object)
       (concatenate
        "(- " (write object) ")"))
     "js:not"
     (method (_ expression)
       (concatenate
        "!" (write expression)))
     "begin"
     (method (statements? #rest forms)
       (cond
         (statements?
          (join (map write-statements
                     forms)
                ";\n"))
         ((> (size forms) 1)
          (concatenate
           "(" (join (map write forms) ", ") ")"))
         (else:
          (write (first forms)))))
     "js:if"
     (method (statements? test then else)
       (if statements?
           (concatenate
            "if (" (write test) ") {\n"
            (write-statements then)
            "\n}"
            (if else
                (concatenate
                 " else {\n" (write-statements else) "\n}")
                ""))
           (concatenate
            "(" (write test)
            " ? " (write then)
            " : " (write else)
            ")")))
     "js:array"
     (method (_ #rest elements)
       (concatenate
        "[" (join (map write elements) ", ") "]"))
     "js:defined"
     (method (_ expression)
       (concatenate
        "(typeof (" (write expression) ") !== 'undefined')"))
     "js:delete"
     (method (_ expression)
       (concatenate "(delete (" (write expression) "))"))
     "js:try"
     (method (statements? body condition catch finally)
       (bind ((result
               (concatenate
                "try {\n"
                (write-statements body)
                "\n}"
                (if catch
                    (concatenate
                     " catch (" (write condition) ") {\n"
                     (write-statements catch) "\n}")
                    "")
                (if finally
                    (concatenate
                     " finally {\n"
                     (write-statements finally)
                     "\n}")
                  ""))))
         (if statements?
             result
             (wrap-block result))))
     "js:for-in"
     (method (statements? variable/expression #rest body)
        (destructuring-bind (variable expression) variable/expression
          (bind ((result
                  (concatenate
                   "for (var " (write variable)
                   " in " (write expression) ") {\n"
                   (write-body body) "\n}")))
            (if statements?
                result
                (wrap-block result)))))
     "js:for"
     (method (statements? clauses #rest body)
       (bind ((inits [])
              (tests [])
              (nexts []))
         (do (method (clause)
               (destructuring-bind ((var value) test next) clause
                 (bind ((set (S "js:set")))
                   (push-last inits (write [set var value]))
                   (push-last tests (write test))
                   (push-last nexts (write [set var next])))))
             clauses)
         (bind ((result
                 (concatenate
                  "for (var "
                  (join (map (method (parts)
                               (join parts ", "))
                             [inits tests nexts])
                        "; ")
                  ") {\n" (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result)))))
     "js:while"
     (method (statements? test #rest body)
       (bind ((result
               (concatenate
                "while (" (write test) ") {\n"
                (write-body body) "\n}")))
         (if statements?
             result
             (wrap-block result))))
     "js:inline"
     (method (_ identifier)
       (as-string identifier))
     "js:get-property"
     (method (_ object #rest elements)
       (concatenate
        (if (instance? object <number>)
            (concatenate "(" (write object) ")")
            (write object))
        (apply concatenate
               (map (method (element)
                      (if (and (instance? element <string>)
                               (match *property-pattern* element))
                          (concatenate "." element)
                          (concatenate "[" (write element) "]")))
                    elements))))
     "js:new"
     (method (_ name #rest arguments)
       (concatenate
        "new " (write name)
        " (" (join (map write arguments) ", ") ")"))
     "js:var"
     (method (_ name value)
       (concatenate
        "var " (write name)
        (if (and value
                 (not (== value (S "js:undefined"))))
            (concatenate " = " (write value))
            "")))
     "js:set"
     (method (_ name value)
       (concatenate (write name) " = " (write value)))
     "js:return"
     (method (_ body)
       (concatenate "return " (write body)))
     "js:function"
     (method (_ name arguments body)
       (concatenate
        "function "
        (if (and name
                 (not (== name (S "js:null"))))
            (if (instance? name <array>)
                (write name)
                (escape-symbol name))
            (concatenate (escape-symbol (generate-symbol))
                         "__lambda"))
        " (" (join (map write arguments) ", ") ") {"
        (if body
            (concatenate "\n" (write-statements body) "\n")
            "")
        "}"))
     "js:escape"
     (method (_ symbol)
       (write (escape-symbol symbol)))
     "js:throw"
     (method (statements? error)
       (bind ((result (concatenate "throw " (write error))))
             (if statements?
                 result
                 (wrap-block result))))
     "make-object"
     (method (_ #rest key-values)
       (bind ((entries []))
         (for ((i 0 (+ i 2)))
              ((>= i (size key-values)))
           (push-last entries
                      (concatenate
                       (write (element key-values i)) ":"
                       (write (element key-values (+ i 1))))))
         (concatenate "{" (join entries ",\n") "}")))))

(define-function compile (form #key statements?)
  (write (macroexpand form)
         statements?: statements?))

(define-function macroexpand (form)
  (select form instance?
    ((<array>)
     ;; apply macros
     (while (and (instance? form <array>)
                 (instance? (first form) <symbol>)
                 (has? *macros* (symbol-name (first form))))
       (bind ((macro (get *macros* (symbol-name (first form)))))
         (set! form (apply macro (rest form)))))
     ;; still array?
     (if (instance? form <array>)
         (bind ((head (first form)))
           ;; special?
           (if (and (instance? head <symbol>)
                    (has? *special-forms*
                          (symbol-name head)))
               (bind ((expander (get *special-forms*
                                     (symbol-name head))))
                 (select expander instance?
                   ((<number>)
                    (concatenate
                     ;; skip n arguments, macroexpand rest
                     (slice form 0 (inc expander))
                     (map macroexpand (slice form (inc expander)))))
                   ((<function>)
                    ;; custom expander
                    (apply expander (rest form)))
                   (else:
                    ;; form mustn't be expanded
                    form)))
             ;; not special
             (map macroexpand form)))
         ;; not an array
         (macroexpand form)))
    ((<symbol>)
     ;; symbol-macro?
     (if-bind (symbol-macro (get *symbol-macros*
                                 (symbol-name form)))
       (macroexpand symbol-macro)
       form))
    (else: form)))

(define-function write (form #key statements?)
  (select form instance?
    ;; array?
    ((<array>)
     (bind ((head (first form))
            (head-name (symbol-name head))
            (tail (rest form)))
       (cond
         ;; unary?
         ((and (instance? head <symbol>)
               (has? *unary* head-name)
               (== (size form) 2))
          (concatenate "(" (get *unary* head-name) " "
                       (write (second form)) ")"))
         ;; infix?
         ((and (instance? head <symbol>)
               (has? *infix* head-name))
          (bind ((infix (get *infix* head-name))
                 (inside (join (map write tail)
                               (concatenate " " infix " "))))
              (concatenate "(" inside ")")))
         ;; writer?
         ((and (instance? head <symbol>)
               (has? *writers* head-name))
          (apply (get *writers* head-name)
                 statements?
                 tail))
         (head
          (apply (get *writers* "js:call")
                 statements? head tail))
         (else:
          "[]"))))
    ((<symbol>)
     (if-bind (symbol (get *symbols* (symbol-name form)))
       symbol
       (escape-symbol form)))
    ((<hash-symbol>)
     (concatenate "_" (symbol-name form)))
    ((<keyword>)
     (concatenate "_k('" (symbol-name form) "')"))
    ((<boolean>)
     (if form "true" "false"))
    ((<string>)
     (concatenate "\"" form "\""))
    (else:
     (description form))))

(define write-statements
    (rcurry write statements?: #t))

(define-function transform-asynchronous (form)
  (bind ((modules []))
    (bind-methods ((walk (current parent)
                     (bind ((proceed? (instance? current <array>)))
                       (when (and proceed?
                                  (== (size current) 3))
                         (destructuring-bind (var variable-name value) current
                           (when (== var (S "js:var"))
                             (destructuring-bind (require module-name) value
                               (when (== require (S "require"))
                                 (push-last modules [variable-name module-name])
                                 (bind ((index (position parent current)))
                                   (replace-subsequence! parent []
                                                         start: index
                                                         end: (inc index)))
                                 (set! proceed? #f))))))
                       (when proceed?
                         (do (method (form)
                               (walk form current))
                             (rest current))))))
    (walk form)
    (do (method (binding)
          (destructuring-bind (variable module) binding
              (set! form
                    `(require ,module
                              (js:function js:null (,variable)
                                 ,form)))))
        modules)
    form)))

