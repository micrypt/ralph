(define-module ralph/reader
    import: (ralph/core ralph/stream ralph/regexp)
    export: (read))

(define *number-patterns*
    (map (curry make <regexp> ignore-case?: #t pattern:)
         ["^[+-]?0x[0-9a-f]+"
          "^[+-]?0[0-7]+"
          "^[+-]?\\d+\\.?\\d*(?:e-?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?"]))

(define-function make-atom (value)
  (select value ==
    (("#t") (make-boolean #t))
    (("#f") (make-boolean #f))
    (("#key") #key)
    (("#rest") #rest)
    (else:
     (if-bind (number (any? (rcurry match value)
                            *number-patterns*))
       (make-number (first number))
       (if (== (last value) ":")
           (keyword (but-last value))
           (symbol value))))))

(define-function read-string ((stream <stream>))
  (bind ((result (make <string-stream>))
         (char (stream-read-element stream)))
    (while (not (== char "\""))
      (when (stream-at-end? stream)
        (signal "missing end of string"))
      (stream-write result
                    (if (== char "\\")
                        (select (stream-read-element stream) ==
                          (("\"") "\"")
                          (("\\") "\\")
                          (("b") "\b")
                          (("f") "\f")
                          (("n") "\n")
                          (("r") "\r")
                          (("t") "\t")
                          (("v") "\v")
                          (("u")
                           (code-char
                            (parse-integer (stream-read stream 4)
                                           radix: 16)))
                          (else:
                           (signal "bad escape sequence")))
                        char))
      (set! char (stream-read-element stream)))
    (make-string (stream-contents result))))

(define *whitespace* ["\n" "\r" " " "\t"
                      ;; Vertical Tab, Form Feed, No-break space, Byte Order Mark
                      "\u000B" "\u000C" "\u00A0" "\uFEFF"])
(define *atom-end* (concatenate *whitespace*
                                ["(" ")" "[" "]" "\"" ";" "`" ","]))
(define *wrapper-symbols* ["%backquote" "%comma"])

(define-function read ((stream <stream>) #key (eof-error? #t) eof-value)
  (bind ((stack [[]])
         (atom #f)
         (ends []))
    (bind-methods ((add-to-stack! (value)
                     (push-last (last stack)
                                value)
                     (when (member? (symbol-name (first (last stack)))
                                    *wrapper-symbols*)
                       (add-last!)))
                   (add-last! ()
                     (bind ((value (pop-last stack)))
                       (add-to-stack! value)))
                   (add-atom! ()
                     (add-to-stack! (make-atom atom))))
      (while (not (stream-at-end? stream))
        (bind ((char (stream-read-element stream)))
          (if atom
              (if (member? char *atom-end*)
                  (begin
                   (add-atom!)
                   (stream-unread-element stream)
                   (set! atom #f))
                  (set! atom (concatenate atom char)))
              (select char ==
                ((";")
                 (stream-read-through stream "\n"))
                (("`")
                 (push-last stack [(symbol "%backquote")]))
                ((",")
                 (push-last stack [(symbol "%comma")]))
                (("(")
                 (push-last ends ")")
                 (push-last stack []))
                (("[")
                 (push-last ends "]")
                 (push-last stack `(js:array)))
                (((last ends))
                 (pop-last ends)
                 (add-last!))
                ((")" "]")
                 (signal (format-to-string "too many closings: %=" char)))
                (("\"")
                 (add-to-stack! (read-string stream)))
                (else:
                 (unless (member? char *whitespace*)
                   (set! atom char)))))))
      (if (empty? ends)
          (begin
           (when atom
             (add-atom!))
           (bind ((value (first (last stack))))
             (or value
                 (if eof-error?
                     (signal "no object")
                     eof-value))))
          (signal (format-to-string "missing closings: %=" ends))))))
