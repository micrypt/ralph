(define-module ralph/compiler2
  import: (ralph/core ralph/format ralph/regexp ralph/reader)
  export: (<environment> macroexpand-1
                         macroexpand
                         macroexpand-all
                         alpha-convert
;;                         beta-reduce
                         reset-symbol-counter!
                         atomic?
                         normalize-term))

;; - everything is an expression, transform to statements after ANF easy
;; - instead of trying to use JS statements (while, try, etc.) as expressions,
;;   by wrapping them in lambdas, allways generate statements (while, but also if, etc.)
;;   (e.g. instead of "return x ? (x = 3, 1) : 2"
;;         => "var t1; if (x) { x = 3; t1 = 1 } else { t1 = 2 }; return t1")
;; - closures are expensive, try to only generate them when necessary

;; Questions:
;; - beta reduction?! what about explicit closures, e.g. loops
;; - top-level defines: alpha-convert? normalize to bind?
;; - explicit imports? would solve global scope problem

;; Languages
;;
;; L1: source
;; <prog> ::= <dec>*
;; <dec> ::= (define <var> <exp>)
;;        |  (define-function <var> <lambda-list> <exp>*)
;;        |  (define-function (setter <var>) <lambda-list> <exp>*)
;;        |  (define-generic <var> <lambda-list>)
;;        |  (define-method <var> <typed-lambda-list> <exp>*)
;;        |  (define-method (setter <var>) <typed-lambda-list> <exp>*)
;;        |  <exp>
;;
;; <lambda-list> ::= (<var>* <rest-key>)
;;
;; <typed-lambda-list> ::= ([(<var> <exp>)] <var>* <rest-key>)
;;                      |  <lambda-list>
;;
;; <nested-lambda-list> ::= ({<nested-lambda-list> | <var>}* <rest-key>)
;;
;; <rest-key> ::= [#rest <var>] [#key <var> | (<var> <exp>)]
;;
;; <exp> ::= (bind ((<var> <exp>)*) <exp>*)
;;        |  (begin <exp>*)
;;        |  (if <exp> <exp> <exp>)
;;        |  (if-bind (<var> <exp>) <exp> <exp>)
;;        |  (when <exp> <exp>*)
;;        |  (unless <exp> <exp>*)
;;        |  (set! <var> <exp>)
;;        |  (set! <exp> <exp>*)
;;        |  (parallel-set! {<var> <exp>}*)
;;        |  (method <lambda-list> <exp>*)
;;        |  (and <exp>*)
;;        |  (or <exp>*)
;;        |  (while <exp> <exp>*)
;;        |  (dotimes (<var> <exp> <exp>) <exp>*)
;;        |  (until <exp> <exp>*)
;;        |  (bind-properties (<var>*) <exp> <exp>*)
;;        |  (destructuring-bind <nested-lambda-list> <exp> <exp>*)
;;        |  <number>
;;        |  <boolean>
;;        |  <string>
;;        |  <var>
;;
;; L2: expanded top-level defines
;; <prog> ::= <dec>*
;; <dec> ::= (define <var> <L1.exp>)
;;        |  <L1.exp>
;;
;; L3: macroexpanded
;; <prog> ::= <dec>*
;; <dec> ::= (%define <var> <exp>)
;;        |  <exp>
;;
;; <exp> ::= (%bind (<var> <exp>) <exp>)
;;        |  (%begin <exp>+)
;;        |  (%if <exp> <exp> <exp>)
;;        |  (%set <var> <exp>)
;;        |  (%method (<var>*) <exp>)
;;        |  (%while <exp> <exp>)
;;        |  (%array <exp>*)
;;        |  (%object {<string> <exp>}*)
;;        |  <number>
;;        |  <boolean>
;;        |  <string>
;;        |  <var>

;; - alpha-converted
;;   (ANF algorithm assumes unique naming of variables:
;;    "We assume the front-end uniquely renames all variables [...]")
;; - in ANF
;; - beta-reduced
;; - TODO: constant folding
;; - TODO: unreachable code elimination
;; - TODO: dead-code elimination
;;         check all but last expressions in body:
;;         side-effect free? no function call, constant or symbol
;; - lift and reuse symbols and keywords
;; - in statement form (with explicit returns)
;; - TODO: transform bind to single js:var, flatten variable to nearest special form
;; - TODO: optimize else when if uses explicit returns (always ok?):
;;         (%if ... (return .1.) (return .2.))
;;         => (%begin (%if ... (return .1.) #f) (return .2.))
;; - TODO: JS' return has false value as default:
;;         (%return #f) => (js:return)

;; JS back-end transformations:
;;   %make-function <ralph-name-string> => %make-function <js-name-string>
;;   ...


;;;; utilities

(define-function expression? (form)
  (and (instance? form <array>)
       (not (empty? form))
       (instance? (first form) <symbol>)))

(define-function setter-symbol (function-symbol)
  (symbol (concatenate "%%set-" (symbol-name function-symbol))))

(define-function setter-name? (name)
  (and (instance? name <array>)
       (== (size name) 2)
       (every? (rcurry instance? <symbol>))
       (== (symbol-name (first name)) "setter")))

(define *symbol-count* 0)

(define-function reset-symbol-counter! ()
  (set! *symbol-count* 0))

(define-function generate-symbol ()
  (symbol (concatenate "%_" (as-string (inc! *symbol-count*)))))

;;;; special forms

;; utilities

(define *special-forms*
  (make-object))

(define-function special-form-definition (form env)
  (get *special-forms* (symbol-name (first form))))

(define-macro define-special-form (name #rest definition)
  `(set! (get *special-forms* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-special-form
  %method (env arguments body)
  `(%method ,arguments
     ,(macroexpand-all body env)))

(define-special-form
  %set (env name value)
  `(%set ,name ,(macroexpand-all value env)))

(define-special-form
  %define (env name value)
  `(%define ,name ,(macroexpand-all value env)))

(define-special-form
  %bind (env binding body)
  (destructuring-bind (var value) binding
    `(%bind (,var ,(macroexpand-all value env))
       ,(macroexpand-all body env))))


;;;; macros

;; utilities

(define *default-macros*
  (make-object))

(define-macro define-default-macro (name #rest definition)
  `(set! (get *default-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

(define-function maybe-begin (expressions)
  (select (size expressions) ==
    ((0) #f)
    ((1) (first expressions))
    (else:
     (concatenate `(%begin)
                  expressions))))

;; => [required rest keys]
(define-function analyze-lambda-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function wrap (exp #rest wrappers)
  (reduce (method (result wrapper)
            (wrapper result))
          exp
          wrappers))

(define-function wrap-rest/keys (body all required rest key)
  (bind ((rest? rest)
         (rest (or rest
                   (unless (empty? key)
                     (generate-symbol)))))
    (wrap body
          (method (body)
            (if (empty? key)
                body
                (bind ((key-values
                        (reduce1 concatenate
                                 (map (method (binding)
                                        (destructuring-bind (var value)
                                            binding
                                          [(symbol-name var) value]))
                                      key))))
                  `(bind-properties ,(map first key)
                       (%keys ,rest ,(concatenate `(%object)
                                                  key-values))
                     ,body))))
          (method (body)
            (if (or rest? (not (empty? key)))
                `(bind ((,rest (slice ,all ,(size required))))
                   ,body)
                body)))))

;; definitions

(define-default-macro begin (_ #rest expressions)
  (maybe-begin expressions))

(define-default-macro method (_ arguments #rest body)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    `(%method ,required
       ,(wrap-rest/keys
         (maybe-begin body)
         (symbol "%all-arguments")
         required rest key))))


(define-default-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (concatenate `(begin) body)
      (destructuring-bind (var value) (first bindings)
        `(%bind (,var ,value)
           ,(concatenate `(bind ,(rest bindings))
                         body)))))

(define-default-macro if (_ test then else)
  `(%if ,test ,then ,else))



(define-default-macro define (_ name value)
  `(%define ,name ,value))

(define-default-macro set! (_ place #rest rest)
  (if (instance? place <array>)
      (concatenate `(,(setter-symbol (first place)))
                   (rest place)
                   rest)
      `(%set ,place ,(first rest))))


(define-default-macro parallel-set! (_ var value #rest clauses)
  (if (empty? clauses)
      `(set! ,var ,value)
      (bind ((temp (generate-symbol)))
        `(bind ((,temp ,value))
           ,(concatenate `(parallel-set!)
                         clauses)
           (set! ,var ,temp)))))


(define-default-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (concatenate `(begin) then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-default-macro when (_ condition #rest body)
  `(if ,condition
       ,(concatenate `(begin)
                     body)
       #f))

(define-default-macro and (_ #rest values)
  (select (size values) ==
    ((0) #t)
    ((1) (first values))
    (else: `(when ,(first values)
              ,(concatenate `(and)
                            (rest values))))))

(define-default-macro or (_ #rest values)
  (select (size values) ==
    ((0) #f)
    ((1) (first values))
    (else:
     (bind ((value (generate-symbol)))
       `(bind ((,value ,(first values)))
          (if ,value
              ,value
              ,(concatenate `(or)
                            (rest values))))))))

(define-default-macro if-bind (_ binding then else)
  (destructuring-bind (var value) binding
    (bind ((temp (generate-symbol)))
      `(bind ((,temp ,value))
         (if ,temp
             (bind ((,var ,temp))
               ,then)
             ,else)))))

(define-default-macro while (_ test #rest body)
  `(%while ,test
     ,(maybe-begin body)))

(define-default-macro until (_ test #rest body)
  (concatenate `(while (not ,test))
               body))

(define-default-macro dotimes (_ binding #rest body)
  (bind ((temp (generate-symbol)))
    (destructuring-bind (var count result) binding
      `(bind ((,temp ,count))
         ,(concatenate
           `(for ((,var 0 (+ ,var 1)))
                 ((>= ,var ,temp) ,(or result #f)))
           body)))))

(define-default-macro for (_ clauses end #rest body)
  (bind ((init-clauses [])
         (next-clauses [])
         (vars (map first clauses)))
    (for-each ((clause clauses))
              ()
      ;; init
      (push-last init-clauses
                 (slice clause 0 2))
      ;; next
      (push-last next-clauses
                 (first clause))
      (push-last next-clauses
                 (third clause)))
    `(bind ,init-clauses
       ,(concatenate `(while (not ,(first end))
                        ,(concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)
                        ,(concatenate `(parallel-set!)
                                      next-clauses)))
       ,(unless (empty? (rest end))
          (concatenate `(begin)
                       (rest end))))))

(define-default-macro for-each (_ clauses end #rest body)
  (destructuring-bind (end-test #rest results) end
    (bind ((clauses (map (method (clause)
                           (concatenate [(generate-symbol)]
                                        clause))
                         clauses))
           (end? (generate-symbol))
           (values (generate-symbol)))
      (concatenate
       ;; evaluate each collection once
       `(bind ,(concatenate
                (map (method (clause)
                       (destructuring-bind (temp var values) clause
                         [temp values]))
                     clauses)
                `((,end? #f)
                  (,values ,(concatenate `(%array)
                                         (map first clauses)))))
          ;; check exhaustion
          (until (or ,end?
                     (any? empty? ,values))
            ;; bind each var to next element
            (bind ,(map (method (clause)
                          (destructuring-bind (temp var values) clause
                            [var `(first ,temp)]))
                        clauses)
              (if ,end-test
                  (set! ,end? #t)
                  ,(concatenate
                    `(begin
                      ;; rebind variables to create closure
                      ,(bind ((vars (map second clauses)))
                         (concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)))
                    ;; update temporary collection bindings
                    (map (method (clause)
                           `(set! ,(first clause)
                                  (rest ,(first clause))))
                         clauses))))))
       ;; execute all result expressions, returning last; false if none
       (if (empty? results)
           [#f]
           results)))))

(define-default-macro bind-properties (_ properties object #rest body)
  (bind ((object* (generate-symbol)))
    (concatenate
     `(bind ,(concatenate
              `((,object* ,object))
              (map (method (property)
                     `(,property
                       (%get-property ,object*
                                      ,(symbol-name property))))
                   properties)))
     body)))

(define-default-macro select (_ value test #rest cases)
  (bind ((value* (generate-symbol))
         (test* (generate-symbol)))
    (bind-methods ((test-expression (test-value)
                     `(,test* ,value* ,test-value)))
      `(bind ((,value* ,value)
              (,test* ,test))
         ,(concatenate
           `(cond)
           (map (method (case)
                  (destructuring-bind (tests #rest then) case
                    (if (== tests else:)
                        case
                        (concatenate
                         `(,(concatenate
                             `(or)
                             (map test-expression tests)))
                         then))))
                cases))))))

(define-function destructure (bindings values body)
  (if (instance? values <symbol>)
      (destructuring-bind (required rest key)
          (analyze-lambda-list bindings)
        (bind ((i (size required)))
          (reduce (method (body binding)
                    (dec! i)
                    (if (instance? binding <symbol>)
                        `(bind ((,binding (nth ,values ,i)))
                           ,body)
                        (destructure binding `(nth ,values ,i) body)))
                  (wrap-rest/keys body
                                  values
                                  required rest key)
                  (reverse required))))
      ;; ensures values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var body)))))

(define-default-macro destructuring-bind (_ bindings values #rest body)
  (destructure bindings values
               (concatenate `(begin) body)))

(define-default-macro bind-methods (_ bindings #rest body)
  (concatenate
   `(bind ,(map (method (binding)
                  (destructuring-bind (name arguments #rest body)
                      binding
                    `(,name (concatenate `(method arguments)
                                         body))))
                bindings))
   body))

(define-default-macro inc! (_ object value)
  `(set! ,object (+ ,object ,(or value 1))))

(define-default-macro dec! (_ object value)
  `(set! ,object (- ,object ,(or value 1))))

(define-function transform-quoted (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (if (member? (first exp)
                 [(symbol "%comma") (symbol "%backqoute")])
        (second exp)
        (concatenate `(%array)
                     (map transform-quoted
                          exp))))
   ((instance? exp <symbol>)
    `(symbol ,(symbol-name exp)))
   (else:
    exp)))

(define-default-macro %backquote (_ exp)
  (transform-quoted exp))

;; comma is only used as a marker and
;; actually handled in backquote
(define-default-macro %comma (_ value)
  (signal (make <error> message: "comma not inside backquote")))


;; TODO: %try, %throw, block, handler-case

;;;; macro expansion

(define-class <environment> (<object>)
  (macros *default-macros*))

(define-function macro-definition (form env)
  (get env "macros" (symbol-name (first form))))

(define-function macroexpand-1 (form env)
  (if-bind (macro (and (expression? form)
                       (macro-definition form env)))
    (apply macro env (rest form))
    form))

(define-function macroexpand (form env)
  (bind ((expanded (macroexpand-1 form env)))
    (if (== expanded form)
        form
        (macroexpand expanded env))))

(define-function macroexpand-all (form env)
  (select form instance?
    ((<array>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         (if-bind (expander (special-form-definition form env))
           (apply expander env (rest form))
           (map (rcurry macroexpand-all env)
                form))))
    ;; TODO: symbol macro ((<symbol>) )
    (else: form)))

;;;; alpha conversion

(define-function rename-variables (variables env)
  (bind ((env (wrap-object env)))
    [(map (method (variable)
            (set! (get env (symbol-name variable))
                  (generate-symbol)))
          variables)
     env]))

(define-function find-variable (variable env)
  ;; TODO: use find-property, signal error if not found
  (js:get-property env (symbol-name variable)))

(define-function alpha-convert (form env)
  (select form instance?
    ((<array>)
     (select (symbol-name (first form)) ==
       (("%method")
        (destructuring-bind (_ arguments body) form
          (destructuring-bind (new-arguments env*)
              (rename-variables arguments env)
            `(%method ,new-arguments
               ,(alpha-convert body env*)))))
       (("%bind")
        (destructuring-bind (_ (var value) body) form
          (destructuring-bind ((new-var) env*)
              (rename-variables [var] env)
            ;; NOTE: binding is available inside value!
            `(%bind (,new-var ,(alpha-convert value env*))
               ,(alpha-convert body env*)))))
       (else:
        (map (rcurry alpha-convert env)
             form))))
    ((<symbol>)
     (or (find-variable form env)
         form))
    (else: form)))

;;;; beta reduction

;; ((L (x y) (+ x y)) a (+ a 1))
;; => ((L (y) (+ a y)) (+ a 1))

(define-function substitute-variables (variables new-variables env)
  (bind ((env (wrap-object env)))
    (for-each ((variable variables)
               (new-variable new-variables))
              ()
      (set! (get env (symbol-name variable))
            new-variable))
    env))


;;;; TODO: eliminate
;;;; ((L () X)) => X
;;;; (begin 1) => 1

;;(define-function beta-reduce (form env)
;;  (select form instance?
;;    ((<array>)
;;     ;; TODO: bind
;;     (if (and (instance? (first form) <array>)
;;              (== (symbol-name (first (first form))) "%method"))
;;         (destructuring-bind ((_ arguments #rest body) #rest values)
;;             form
;;           ;; TODO: maybe also support constant values (numbers, etc.)
;;           (bind ((variables [])
;;                  (new-variables [])
;;                  (new-arguments [])
;;                  (new-values []))
;;             (for-each ((argument arguments)
;;                        (value values))
;;                 ()
;;               (if (atomic? value)
;;                   (begin
;;                    (push-last variables argument)
;;                    (push-last new-variables value))
;;                   (begin
;;                    (push-last new-arguments argument)
;;                    (push-last new-values value))))
;;             (bind ((env (substitute-variables variables new-variables env)))
;;               (concatenate `(,(concatenate `(%method ,new-arguments)
;;                                            (beta-reduce body env)))
;;                            new-values))))
;;         (map (rcurry beta-reduce env)
;;              form env)))
;;    ((<symbol>)
;;     (or (find-variable form env)
;;         form))
;;    (else: form)))


;; ANF
;; * see:
;;   - "The Essence of Compiling with Continuations"
;;     Flanagan, Sabry, Duba, Felleisen
;;   - "A-Normalization: Why and How"
;;     Matt Might (http://matt.might.net/articles/a-normalization/)
;; * modified:
;,   - support for %while
;;   - create less bindings for expressions involving
;;     no control-flow (see pure-expression?)
;;     => reduces JS variable bindings (5-20% performance hit)


(define-function atomic? (expression)
  (any? (curry instance? expression)
        [<number> <boolean> <string> <symbol>
                  ;; TODO: aren't keywords symbols?
                  <keyword>]))

(define-function normalize-term (expression)
  (normalize expression identity))

(define-function normalize (exp k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (k `(%method ,arguments
                 ,(normalize-term body)))))
        (("%begin")
         (destructuring-bind (_ exp1 #rest e*) exp
           (if (empty? e*)
               (normalize exp1 k)
               (normalize
                exp1 (method (aexp1)
                       `(%begin
                         ,aexp1
                         ,(normalize (concatenate
                                      `(%begin) e*)
                                     k)))))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (normalize
            value (method (avalue)
                   `(%bind (,var ,avalue)
                      ,(normalize body k))))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           (normalize-name
            test (method (atest)
                   (k `(%if ,atest
                            ,(normalize-term then)
                            ,(normalize-term else)))))))
        (("%while")
         (destructuring-bind (_ test body) exp
           (k `(%while ,(normalize-term test)
                       ,(normalize-term body)))))
        (("%set")
         (destructuring-bind (_ var value) exp
           (normalize-name
            value (method (avalue)
                    ;; binding helps in later passes
                    ;; (sinking, dead code elimination):
                    ;; values are always symbols,
                    ;; no check for assignment
                    (bind ((result (generate-symbol)))
                      `(%bind (,result (%set ,var ,avalue))
                         ,(k result)))))))

        (else:
         (if (pure-expression? exp)
             (k exp)
             (normalize-all exp k))))
      (k exp)))

(define-function pure-expression? (exp)
  (if (instance? exp <array>)
      (not (or (member? (first exp)
                        `(%method %set %begin %if %while %bind))
               (not (every? pure-expression?
                            (rest exp)))))
      #t))

(define-function normalize-name (exp k)
  (normalize
   exp (method (aexp)
         (if (atomic? aexp)
             (k aexp)
             (bind ((t (generate-symbol)))
               `(%bind (,t ,aexp)
                 ,(k t)))))))

(define-function normalize-name* (exp* k)
  (if (empty? exp*)
      (k [])
      (normalize-all exp* k)))

(define-function normalize-all (exp k)
  (normalize-name
   (first exp) (method (t)
                 (normalize-name*
                  (rest exp) (method (t*)
                               (k (concatenate [t] t*)))))))


;;;; top-level expansion

(define-function function-definer (macro-name definer-name type?)
  (method (_ function-name arguments #rest body)
    (destructuring-bind (setter? name)
        (if (setter-name? function-name)
            [#t (setter-symbol (second function-name))]
            [#f function-name])
      (when (not (or (instance? name <symbol>)
                     setter?))
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "name not <var> or (setter <var>)"))))
      (bind ((arguments (map (method (argument)
                               (if (instance? argument <array>)
                                   (first argument)
                                   argument))
                             arguments)))
        `(define ,name
           (,(symbol definer-name)
            ,(symbol-name name)
            ,(concatenate `(method ,arguments)
                          body)
            ,setter?
            ,(when (and type?
                        (not (empty? arguments)))
               (bind ((head (first arguments)))
                 (if (and (instance? head <array>)
                          (> (size head) 1))
                     (second head)
                     (symbol "<object>"))))))))))

(define *top-level-macros*
  (make-object
   "define-generic"
   (method (_ name arguments)
     `(define ,name
        (%make-generic ,(symbol-name name))))))

(define *top-level-environment*
  (make <environment> macros: *top-level-macros*))

;; TODO: define-module, define-class

(for-each ((arguments [["define-function" "%make-function" #f]
                       ["define-method" "%make-method" #t]]))
          ()
  (set! (get *top-level-macros* (first arguments))
        (apply function-definer arguments)))

(define-function macroexpand-program (declarations)
  (map (rcurry macroexpand *top-level-environment*)
       declarations))


;;;; statements

;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

(define-function wrap-value (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%begin")
         (destructuring-bind (_ #rest e*) exp
           (concatenate `(%begin)
                        (but-last e*)
                        `(,(wrap-value
                            (last e*) wrapper)))))
        (("%bind")
         (destructuring-bind (_ binding body) exp
           `(%bind ,binding ,(wrap-value body wrapper))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           ;; TODO: don't sink if both else and then
           ;;       are atomic? or function calls
           ;;       i.e., no %begin, %bind, etc.
           `(%if ,test
                 ,(wrap-value then wrapper)
                 ,(wrap-value else wrapper))))
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value #f wrapper)))
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))

(define-function add-explicit-return (exp)
  (wrap-value exp `(%return)))

;; in JS backend, after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment:
;; (%bind (%_1 (%if ... (%bind (%_2 ...) (foo %_2) ...))) (bar %_1 baz))
;; => (%bind (%_1 #f)
;;      (%begin
;;       (%if ...
;;            (%bind (%_2 ...)
;;              (set! %_1 (foo %_2)))
;;            ...)
;;       (bar %_1 baz)))

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind))))

(define-function transform-statements (exp)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           `(%method ,arguments
              ,(add-explicit-return (transform-statements body)))))
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (concatenate `(%begin)
                        (map transform-statements
                             exps))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (if (statement? value)
               `(%bind (,var #f)
                  (%begin
                   ,(wrap-value (transform-statements value)
                                `(%set ,var))
                   ,(transform-statements body)))
               `(%bind (,var ,value)
                  ,(transform-statements body)))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           `(%if ,test
                 ,(transform-statements then)
                 ,(transform-statements else))))
        (("%while")
         (destructuring-bind (_ test body) exp
           `(%while ,test
                    ,(transform-statements body))))
        (("%set")
         (destructuring-bind (_ var value) exp
           (if (statement? value)
               (wrap-value (transform-statements value)
                           `(%set ,var))
               `(%set (,var ,value)))))
        (else:
         exp))
      exp))

;;;; symbol lifting

;; TODO: keywords, hash-symbols

(define-function lift-symbols (exp)
  (lift-symbol exp (make-object) identity))

(define-function lift-all (exp mapping k)
  (lift-symbol
   (first exp) mapping
   (method (t mapping)
     (lift-symbol*
      (rest exp) mapping
      (method (t* mapping)
        (k (concatenate [t] t*)
           mapping))))))

(define-function lift-symbol (exp mapping k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-symbol
            value mapping
            (method (lvalue mapping)
              (lift-symbol
               body mapping
               (method (lbody mapping)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    mapping)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-symbol
            e2 mapping
            (method (le2 mapping)
              (k `(,m ,e1 ,le2)
                 mapping)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-symbol*
            e* mapping
            (method (le* mapping)
              (k (concatenate `(,m) le*)
                 mapping)))))
        (("symbol")
          (destructuring-bind (_ name) exp
            (if-bind (t (get mapping name))
              (k t mapping)
              (bind ((t (set! (get mapping name)
                              (generate-symbol))))
                `(%bind (,t ,exp)
                        ,(k t mapping))))))
        (else:
         (lift-all exp mapping k)))
      (k exp mapping)))

(define-function lift-symbol* (exp* mapping k)
  (if (empty? exp*)
      (k [] mapping)
      (lift-all exp* mapping k)))
