(define-module ralph/compiler2
  import: (ralph/core ralph/format ralph/regexp ralph/reader)
  export: (<environment> macroexpand-1
                         macroexpand
                         macroexpand-all
                         alpha-convert
                         reset-symbol-counter!
                         atomic?
                         normalize-term))

;; TODO: refactor lift-defines and lift-symbols: define-lift-pass

;; TODO: symbol => %symbol
;; TODO: %primitive-...


;; TODO: generate-symbol => pass env
;; TODO: use one environment for all passes (?!)


;;;; utilities

(define-function expression? (form)
  (and (instance? form <array>)
       (not (empty? form))
       (instance? (first form) <symbol>)))

(define-function setter-symbol (function-symbol)
  (symbol (concatenate (symbol-name function-symbol) "-setter")))

(define-function setter-name? (name)
  (and (instance? name <array>)
       (== (size name) 2)
       (every? (rcurry instance? <symbol>))
       (== (symbol-name (first name)) "setter")))

(define *symbol-count* 0)

(define-function reset-symbol-counter! ()
  (set! *symbol-count* 0))

(define-function generate-symbol ()
  (bind ((name (concatenate "$" (as-string (inc! *symbol-count*))))
         (result (symbol name)))
    (set! (get result "generated?") #t)
    result))

;;;; special forms

;; utilities

(define *special-forms*
  (make-object))

(define-function special-form-definition (form env)
  (get *special-forms* (symbol-name (first form))))

(define-macro define-special-form (name #rest definition)
  `(set! (get *special-forms* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-special-form
  %method (env arguments body)
  `(%method ,arguments
     ,(macroexpand-all body env)))

(define-special-form
  %set (env name value)
  `(%set ,name ,(macroexpand-all value env)))

(define-special-form
  %define (env name value)
  `(%define ,name ,(macroexpand-all value env)))

(define-special-form
  %bind (env binding body)
  (destructuring-bind (var value) binding
    `(%bind (,var ,(macroexpand-all value env))
       ,(macroexpand-all body env))))

;;;; macros

;; utilities

(define *default-macros*
  (make-object))

(define-macro define-default-macro (name #rest definition)
  `(set! (get *default-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

(define-function maybe-begin (expressions)
  (select (size expressions) ==
    ((0) #f)
    ((1) (first expressions))
    (else:
     (concatenate `(%begin)
                  expressions))))

;; => [required rest keys]
(define-function analyze-lambda-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function wrap (exp #rest wrappers)
  (reduce (method (result wrapper)
            (wrapper result))
          exp
          wrappers))

(define-function wrap-rest/keys (body all required rest key)
  (bind ((rest? rest)
         (rest (or rest
                   (unless (empty? key)
                     (generate-symbol)))))
    (wrap body
          (method (body)
            (if (empty? key)
                body
                (bind ((key-values
                        (map (method (binding)
                               (if (instance? binding <array>)
                                   binding
                                   [binding #f]))
                             key)))
                  `(bind-properties ,(map first key-values)
                       (%keys ,rest
                              ,(concatenate `(%object)
                                            (reduce1 concatenate
                                                     (map (method (key-value)
                                                            (destructuring-bind (key value)
                                                                key-value
                                                              [(symbol-name key) value]))
                                                          key-values))))
                     ,body))))
          (method (body)
            (if (or rest? (not (empty? key)))
                `(bind ((,rest (%slice ,all ,(size required))))
                   ,body)
                body)))))

;; definitions

(define-default-macro begin (_ #rest expressions)
  (maybe-begin expressions))

(define-default-macro method (_ arguments #rest body)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    `(%method ,required
       ,(wrap-rest/keys
         (maybe-begin body)
         (symbol "%all-arguments")
         required rest key))))


(define-default-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (maybe-begin body)
      (reduce (method (body binding)
                `(%bind
                  ,(if (instance? binding <symbol>)
                       `(,binding #f)
                       binding)
                  ,body))
              (maybe-begin body)
              (reverse bindings))))

(define-default-macro if (_ test then else)
  `(%if ,test ,then ,else))

(define-default-macro set! (_ place #rest rest)
  (if (instance? place <array>)
      (concatenate `(,(setter-symbol (first place)))
                   (rest place)
                   rest)
      `(%set ,place ,(first rest))))


(define-default-macro parallel-set! (_ var value #rest clauses)
  (if (empty? clauses)
      `(set! ,var ,value)
      (bind ((temp (generate-symbol)))
        `(bind ((,temp ,value))
           ,(concatenate `(parallel-set!)
                         clauses)
           (set! ,var ,temp)))))


(define-default-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (maybe-begin then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-default-macro when (_ test #rest body)
  `(if ,test
       ,(maybe-begin body)
       #f))

(define-default-macro unless (_ test #rest body)
  `(if (%not ,test)
       ,(maybe-begin body)
       #f))

(define-default-macro and (_ #rest values)
  (select (size values) ==
    ((0) #t)
    ((1) (first values))
    (else: `(when ,(first values)
              ,(concatenate `(and)
                            (rest values))))))

(define-default-macro or (_ #rest values)
  (select (size values) ==
    ((0) #f)
    ((1) (first values))
    (else:
     (bind ((value (generate-symbol)))
       `(bind ((,value ,(first values)))
          (if ,value
              ,value
              ,(concatenate `(or)
                            (rest values))))))))

(define-default-macro if-bind (_ binding then else)
  (destructuring-bind (var value) binding
    (bind ((temp (generate-symbol)))
      `(bind ((,temp ,value))
         (if ,temp
             (bind ((,var ,temp))
               ,then)
             ,else)))))

(define-default-macro while (_ test #rest body)
  `(%while ,test
     ,(maybe-begin body)))

(define-default-macro until (_ test #rest body)
  (concatenate `(while (%not ,test))
               body))

(define-default-macro dotimes (_ binding #rest body)
  (bind ((temp (generate-symbol)))
    (destructuring-bind (var count result) binding
      `(bind ((,temp ,count))
         ,(concatenate
           `(for ((,var 0 (+ ,var 1)))
                 ((>= ,var ,temp) ,(or result #f)))
           body)))))

(define-default-macro for (_ clauses end #rest body)
  (bind ((init-clauses [])
         (next-clauses [])
         (vars (map first clauses)))
    (for-each ((clause clauses))
              ()
      ;; init
      (push-last init-clauses
                 (slice clause 0 2))
      ;; next
      (push-last next-clauses
                 (first clause))
      (push-last next-clauses
                 (third clause)))
    `(bind ,init-clauses
       ,(concatenate `(while (%not ,(first end))
                        ,(concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)
                        ,(concatenate `(parallel-set!)
                                      next-clauses)))
       ,(unless (empty? (rest end))
          (concatenate `(begin)
                       (rest end))))))

(define-default-macro for-each (_ clauses end #rest body)
  (destructuring-bind (end-test #rest results) end
    (bind ((clauses (map (method (clause)
                           (concatenate [(generate-symbol)]
                                        clause))
                         clauses))
           (end? (generate-symbol))
           (values (generate-symbol)))
      (concatenate
       ;; evaluate each collection once
       `(bind ,(concatenate
                (map (method (clause)
                       (destructuring-bind (temp var values) clause
                         [temp values]))
                     clauses)
                `((,end? #f)
                  (,values ,(concatenate `(%array)
                                         (map first clauses)))))
          ;; check exhaustion
          (until (or ,end?
                     (%any? %empty? ,values))
            ;; bind each var to next element
            (bind ,(map (method (clause)
                          (destructuring-bind (temp var values) clause
                            [var `(%first ,temp)]))
                        clauses)
              (if ,end-test
                  (set! ,end? #t)
                  ,(concatenate
                    `(begin
                      ;; rebind variables to create closure
                      ,(bind ((vars (map second clauses)))
                         (concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)))
                    ;; update temporary collection bindings
                    (map (method (clause)
                           `(set! ,(first clause)
                                  (%rest ,(first clause))))
                         clauses))))))
       ;; execute all result expressions, returning last; false if none
       (if (empty? results)
           [#f]
           results)))))

(define-default-macro bind-properties (_ properties object #rest body)
  (bind ((object* (generate-symbol)))
    (concatenate
     `(bind ,(concatenate
              `((,object* ,object))
              (map (method (property)
                     `(,property
                       (%get-property ,object*
                                      ,(symbol-name property))))
                   properties)))
     body)))

(define-default-macro select (_ value test #rest cases)
  (bind ((value* (generate-symbol))
         (test* (generate-symbol)))
    (bind-methods ((test-expression (test-value)
                     `(,test* ,value* ,test-value)))
      `(bind ((,value* ,value)
              (,test* ,test))
         ,(concatenate
           `(cond)
           (map (method (case)
                  (destructuring-bind (tests #rest then) case
                    (if (== tests else:)
                        case
                        (concatenate
                         `(,(concatenate
                             `(or)
                             (map test-expression tests)))
                         then))))
                cases))))))

(define-function destructure (bindings values body)
  (if (instance? values <symbol>)
      (destructuring-bind (required rest key)
          (analyze-lambda-list bindings)
        (bind ((i (size required)))
          (reduce (method (body binding)
                    (dec! i)
                    (if (instance? binding <symbol>)
                        `(bind ((,binding (%element ,values ,i)))
                           ,body)
                        (destructure binding `(%element ,values ,i) body)))
                  (wrap-rest/keys body
                                  values
                                  required rest key)
                  (reverse required))))
      ;; ensures values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var body)))))

(define-default-macro destructuring-bind (_ bindings values #rest body)
  (destructure bindings values
               (concatenate `(begin) body)))

(define-default-macro bind-methods (_ bindings #rest body)
  (concatenate
   `(bind ,(map first bindings))
   (map (method (binding)
          (destructuring-bind (name arguments #rest body)
              binding
            `(set! ,name ,(concatenate `(method ,arguments)
                                       body))))
        bindings)
   body))

(define-default-macro inc! (_ object value)
  `(set! ,object (%+ ,object ,(or value 1))))

(define-default-macro dec! (_ object value)
  `(set! ,object (%- ,object ,(or value 1))))

(define-function transform-quoted (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (if (member? (first exp)
                 [(symbol "%comma") (symbol "%backqoute")])
        (second exp)
        (concatenate `(%array)
                     (map transform-quoted
                          exp))))
   ((instance? exp <symbol>)
    `(symbol ,(symbol-name exp)))
   (else:
    exp)))

(define-default-macro %backquote (_ exp)
  (transform-quoted exp))

;; comma is only used as a marker and
;; actually handled in backquote
(define-default-macro %comma (_ value)
  (signal (make <error> message: "comma not inside backquote")))

(define *dot-name-error*
  (make <error>
        message: "unsupported name for call in dot"))

(define-default-macro . (_ value #rest calls)
  (reduce (method (value call)
            (destructuring-bind (name #rest arguments) call
              (concatenate
               `((%get-property ,value
                                ,(select name instance?
                                   ((<string>)
                                    name)
                                   ((<symbol>)
                                    (symbol-name name))
                                   (else:
                                    (signal *dot-name-error*)))))
               arguments)))
          value
          calls))

(define-function function-definer (macro-name definer-name type?)
  (method (_ function-name arguments #rest body)
    (destructuring-bind (setter? name)
        (if (setter-name? function-name)
            [#t (setter-symbol (second function-name))]
            [#f function-name])
      (when (not (or (instance? name <symbol>)
                     setter?))
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "name not <var> or (setter <var>)"))))
      (bind ((arguments (map (method (argument)
                               (if (instance? argument <array>)
                                   (first argument)
                                   argument))
                             arguments)))
        `(define ,name
           (,(symbol definer-name)
            (%native-name ,(symbol-name name))
            ,(concatenate `(method ,arguments)
                          body)
            ,setter?
            ,(when (and type?
                        (not (empty? arguments)))
               (bind ((head (first arguments)))
                 (if (and (instance? head <array>)
                          (> (size head) 1))
                     (second head)
                     (symbol "<object>"))))))))))

(for-each ((arguments [["define-function" "%make-function" #f]
                       ["define-method" "%make-method" #t]]))
          ()
  (set! (get *default-macros* (first arguments))
        (apply function-definer arguments)))


(define-default-macro define-generic (_ name arguments)
  `(define ,name
     (%make-generic
      (%native-name ,(symbol-name name)))))

(define-default-macro define-class (_ name superclass #rest slots)
  (bind ((object `(make-object)))
    (for-each ((slot slots))
              ()
      (if (instance? slot <array>)
          (begin
           (push-last object (symbol-name (first slot)))
           (push-last object `(method ()
                                ,(second slot))))
          (begin
           (push-last object (symbol-name slot))
           (push-last object #f))))
    `(define ,name
       (%make-class
        (%native-name ,(symbol-name name))
        ,(first superclass)
        ,object))))

(define-default-macro define-module (_ name #key (import []) (export []))
  ;; TODO: add exports to env
  (concatenate `(begin)
               (map (method (module)
                      ;; TODO: support for symbol (import all)
                      (destructuring-bind (name #rest names) module
                        (bind ((temp (generate-symbol)))
                           `(%bind (,temp (require ,(symbol-name name)))
                              ,(concatenate
                                `(begin)
                                (map (method (name)
                                       `(%define ,name
                                                 (%get-property
                                                  ,temp ,(symbol-name name))
                                                 #f))
                                     names))))))
                    import)))

;; see lift-defines
(define-default-macro define (_ name value)
  ;; TODO: check env if exported
  `(%define ,name ,value #f))



;;;; lift defines

;; search for all %define and create top-level bindings,
;; replace with assignment to new top-level-binding

(define-function lift-defines (exp)
  (lift-define exp (make-object) identity))

(define-function definition-replacement (name value export?)
  (bind ((assignment `(%set ,name ,value)))
    (if export?
        `(%begin
          ,assignment
          (%export (%native-name ,(symbol-name name))
                   ,name))
        assignment)))

(define-function lift-define (exp defined k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-define
            value defined
            (method (lvalue defined)
              (lift-define
               body defined
               (method (lbody defined)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    defined)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-define
            e2 defined
            (method (le2 defined)
              (k `(,m ,e1 ,le2)
                 defined)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-define*
            e* defined
            (method (le* defined)
              (k (concatenate [m] le*)
                 defined)))))
        (("%define")
         (destructuring-bind (_ var value export?) exp
           (bind ((name (symbol-name var)))
             (if (get defined name)
                 (k (definition-replacement
                      var value export?)
                    defined)
                 (begin
                  (set! (get defined name) #t)
                  `(%bind (,var #f)
                     ,(k (definition-replacement
                           var value export?)
                         defined)))))))
        (else:
         (lift-define** exp defined k)))
      (k exp defined)))

(define-function lift-define* (exp* defined k)
  (if (empty? exp*)
      (k [] defined)
      (lift-define** exp* defined k)))

(define-function lift-define** (exp defined k)
  (lift-define
   (first exp) defined
   (method (t defined)
     (lift-define*
      (rest exp) defined
      (method (t* defined)
        (k (concatenate [t] t*)
           defined))))))



;; TODO: %try, %throw, block, handler-case

;;;; symbol macros

;; utilities

(define *default-symbol-macros*
  (make-object))

(define-macro define-default-symbol-macro (name #rest definition)
  `(set! (get *default-symbol-macros* ,(symbol-name name))
         ,(concatenate `(method)
                       definition)))

;; definitions

(define-default-symbol-macro next-method (_)
  `(%next-method %this-method))

;;;; macro expansion

(define-class <environment> (<object>)
  (macros *default-macros*)
  (symbol-macros *default-symbol-macros*))

(define-function macro-definition (form env)
  (select form instance?
    ((<array>)
     (get env "macros" (symbol-name (first form))))
    ((<symbol>)
     (get env "symbol-macros" (symbol-name form)))))

(define-function macroexpand-1 (form env)
  (if-bind (macro (macro-definition form env))
    (apply macro env (if (instance? form <array>)
                         (rest form)
                         form))
    form))

(define-function macroexpand (form env)
  (bind ((expanded (macroexpand-1 form env)))
    (if (== expanded form)
        form
        (macroexpand expanded env))))

(define-function macroexpand-all (form env)
  (select form instance?
    ((<array>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         (if-bind (expander (special-form-definition form env))
           (apply expander env (rest form))
           (map (rcurry macroexpand-all env)
                form))))
    ((<symbol>)
     (if (macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         form))
    (else: form)))

;;;; alpha conversion

(define-function rename-variables (variables env)
  (bind ((env (wrap-object env)))
    [(map (method (variable)
            (set! (get env (symbol-name variable))
                  (generate-symbol)))
          variables)
     env]))

(define-function find-variable (variable env)
  ;; TODO: use deep-get, signal error if not found
  (js:get-property env (symbol-name variable)))

(define-function alpha-convert (form env)
  (select form instance?
    ((<array>)
     (select (symbol-name (first form)) ==
       (("%method")
        (destructuring-bind (_ arguments body) form
          (destructuring-bind (new-arguments env*)
              (rename-variables arguments env)
            `(%method ,new-arguments
               ,(alpha-convert body env*)))))
       (("%bind")
        (destructuring-bind (_ (var value) body) form
          (destructuring-bind ((new-var) env*)
              (rename-variables [var] env)
            ;; TODO: make binding available inside value?
            `(%bind (,new-var ,(alpha-convert value env))
               ,(alpha-convert body env*)))))
       (else:
        (map (rcurry alpha-convert env)
             form))))
    ((<symbol>)
     (or (find-variable form env)
         form))
    (else: form)))

;;;; beta reduction

;; ((L (x y) (+ x y)) a (+ a 1))
;; => ((L (y) (+ a y)) (+ a 1))

(define-function substitute-variables (variables new-variables env)
  (bind ((env (wrap-object env)))
    (for-each ((variable variables)
               (new-variable new-variables))
              ()
      (set! (get env (symbol-name variable))
            new-variable))
    env))


;;;; TODO: eliminate
;;;; ((L () X)) => X
;;;; (begin 1) => 1

;;(define-function beta-reduce (form env)
;;  (select form instance?
;;    ((<array>)
;;     ;; TODO: bind
;;     (if (and (instance? (first form) <array>)
;;              (== (symbol-name (first (first form))) "%method"))
;;         (destructuring-bind ((_ arguments #rest body) #rest values)
;;             form
;;           ;; TODO: maybe also support constant values (numbers, etc.)
;;           (bind ((variables [])
;;                  (new-variables [])
;;                  (new-arguments [])
;;                  (new-values []))
;;             (for-each ((argument arguments)
;;                        (value values))
;;                 ()
;;               (if (atomic? value)
;;                   (begin
;;                    (push-last variables argument)
;;                    (push-last new-variables value))
;;                   (begin
;;                    (push-last new-arguments argument)
;;                    (push-last new-values value))))
;;             (bind ((env (substitute-variables variables new-variables env)))
;;               (concatenate `(,(concatenate `(%method ,new-arguments)
;;                                            (beta-reduce body env)))
;;                            new-values))))
;;         (map (rcurry beta-reduce env)
;;              form env)))
;;    ((<symbol>)
;;     (or (find-variable form env)
;;         form))
;;    (else: form)))


;;;; ANF

;; TODO: also normalize when function can be inlined?

(define-function atomic? (expression)
  (any? (curry instance? expression)
        [<number> <boolean> <string> <symbol>
                  ;; TODO: aren't keywords symbols?
                  <keyword>]))

(define-function normalize-term (expression)
  (normalize expression identity))

(define-function normalize (exp k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (k `(%method ,arguments
                 ,(normalize-term body)))))
        (("%begin")
         (destructuring-bind (_ exp1 #rest e*) exp
           (if (empty? e*)
               (normalize exp1 k)
               (normalize
                exp1 (method (aexp1)
                       `(%begin
                         ,aexp1
                         ,(normalize (concatenate
                                      `(%begin) e*)
                                     k)))))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (normalize
            value (method (avalue)
                   `(%bind (,var ,avalue)
                      ,(normalize body k))))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           (normalize-value
            test (method (atest)
                   (k `(%if ,atest
                            ,(normalize-term then)
                            ,(normalize-term else)))))))
        (("%while")
         (destructuring-bind (_ test body) exp
           (k `(%while ,(normalize-term test)
                       ,(normalize-term body)))))
        (("%set")
         (destructuring-bind (_ var value) exp
           (normalize-value
            value (method (avalue)
                   (k `(%set ,var ,avalue))))))

        (else:
         (if (contains-statements? exp)
             (normalize-all exp k)
             (k exp))))
      (k exp)))

(define-function normalize-value (exp k)
  (if (contains-statements? exp)
      (normalize-name exp k)
      (k (if (instance? exp <array>)
             (map normalize-term exp)
             exp))))

(define-function contains-statements? (exp)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%begin" "%if" "%while" "%bind") #t)
        (("%set")
         (contains-statements? (last exp)))
        (("%method") #f)
        (else:
         (any? contains-statements? exp)))
      #f))

(define-function normalize-name (exp k)
  (normalize
   exp (method (aexp)
         (if (atomic? aexp)
             (k aexp)
             (bind ((t (generate-symbol)))
               `(%bind (,t ,aexp)
                  ,(k t)))))))

(define-function normalize-name* (exp* k)
  (if (empty? exp*)
      (k [])
      (normalize-all exp* k)))

(define-function normalize-all (exp k)
  (normalize-name
   (first exp) (method (t)
                 (normalize-name*
                  (rest exp) (method (t*)
                               (k (concatenate [t] t*)))))))


;;;; statements

;; "sink"/wrap return value with expression
;; e.g. to assign or explicitly return

;; NOTE: wrap-value, transform-statements and
;; flatten-statements are destructive!
;; => mutation of expressions reduces consing

(define-function wrap-value (exp wrapper)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%begin" "%bind")
         ;; wrap body
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%if")
         ;; wrap then and else
         (set! (third exp)
               (wrap-value (third exp) wrapper))
         (set! (last exp)
               (wrap-value (last exp) wrapper))
         exp)
        (("%while")
         `(%begin
           ,exp
           ,(wrap-value #f wrapper)))
        (else:
         (concatenate wrapper [exp])))
      (concatenate wrapper [exp])))


(define-function add-explicit-return (exp)
  (wrap-value exp `(%return)))

;; after ANF: if value of binding is control-flow (%if, %while, etc.):
;; turn into statement form, then "sink" assignment:
;; (%bind ($1 (%if ... (%bind ($2 ...) (foo $2) ...))) (bar $1 baz))
;; => (%bind ($1 #f)
;;      (%begin
;;       (%if ...
;;            (%bind ($2 ...)
;;              (set! $1 (foo $2)))
;;            ...)
;;       (bar $1 baz)))

(define-function statement? (exp)
  (and (instance? exp <array>)
       (not (empty? exp))
       (member? (first exp)
                `(%if %while %begin %bind))))

(define-function transform-statements (exp)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method")
         (set! (last exp)
               (add-explicit-return
                (transform-statements (last exp))))
         exp)
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (concatenate `(%begin)
                        (map transform-statements
                             exps))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (if (statement? value)
               `(%bind (,var #f)
                  (%begin
                   ,(wrap-value (transform-statements value)
                                `(%set ,var))
                   ,(transform-statements body)))
               `(%bind (,var ,(transform-statements value))
                  ,(transform-statements body)))))
        (("%if")
         (set! (third exp)
               (transform-statements (third exp)))
         (set! (last exp)
               (transform-statements (last exp)))
         exp)
        (("%while" "%set")
         (set! (last exp)
               (transform-statements (last exp)))
         exp)
        (else:
         (map transform-statements exp)))
      exp))



;;;; symbol lifting

;; TODO: keywords, hash-symbols

(define-function lift-symbols (exp)
  (lift-symbol exp (make-object) identity))

(define-function lift-all (exp mapping k)
  (lift-symbol
   (first exp) mapping
   (method (t mapping)
     (lift-symbol*
      (rest exp) mapping
      (method (t* mapping)
        (k (concatenate [t] t*)
           mapping))))))

(define-function lift-symbol (exp mapping k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-symbol
            value mapping
            (method (lvalue mapping)
              (lift-symbol
               body mapping
               (method (lbody mapping)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    mapping)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-symbol
            e2 mapping
            (method (le2 mapping)
              (k `(,m ,e1 ,le2)
                 mapping)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-symbol*
            e* mapping
            (method (le* mapping)
              (k (concatenate `(,m) le*)
                 mapping)))))
        (("symbol")
          (destructuring-bind (_ name) exp
            (if-bind (t (get mapping name))
              (k t mapping)
              (bind ((t (set! (get mapping name)
                              (generate-symbol))))
                `(%bind (,t ,exp)
                        ,(k t mapping))))))
        (else:
         (lift-all exp mapping k)))
      (k exp mapping)))

(define-function lift-symbol* (exp* mapping k)
  (if (empty? exp*)
      (k [] mapping)
      (lift-all exp* mapping k)))



;;;; fold-statements

(define-function fold-statements (exp)
  (if (instance? exp <array>)
      (select (symbol-name (first exp)) ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           `(%method ,arguments
              ,(fold-statements body))))
        (("%begin")
         (destructuring-bind (_ #rest exps) exp
           (reduce concatenate
                   `(%begin)
                   (map (method (exp)
                          (bind ((folded (fold-statements exp)))
                            (if (and (instance? folded <array>)
                                     (not (empty? folded))
                                     (== (first folded) (symbol "%begin")))
                                (rest folded)
                                [folded])))
                        exps))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (bind ((bindings [[var value]]))
             (while (and (instance? body <array>)
                         (not (empty? body))
                         (== (first body) (symbol "%bind")))
               (push-last bindings
                          (second body))
               (set! body (third body)))
             (fold-statements
              `(%begin
                ,(concatenate `(js:var)
                              bindings)
                ,body)))))
        (("%if")
         (destructuring-bind (_ test then else) exp
           `(%if ,test
                 ,(fold-statements then)
                 ,(fold-statements else))))
        (("%while")
         (destructuring-bind (_ test body) exp
           `(%while ,test
              ,(fold-statements body))))
        ;; %set: leave as is
        (else:
         exp))
      exp))

;;;; compilation to JS

;; TODO: inline, unary

(define *escaped*
  (make-object
   "\"" "\""
   "\\" "\\"
   "\b" "b"
   "\f" "f"
   "\n" "n"
   "\r" "r"
   "\v" "v"
   "\t" "t"))

(define-function fill-zeros (string)
  (concatenate
   (slice "0000" 0 (- 4 (size string)))
   string))

(define-function hex (code)
  (fill-zeros ((js:get-property code "toString") 16)))

(define-function escape-string (string)
  (join (map (method (char)
               (if-bind (escaped (get *escaped* char))
                 (concatenate "\\" escaped)
                 (bind ((code (char-code char)))
                   (if (< 0x1f code  0x7f)
                       char
                       (concatenate "\\u" (hex code))))))
             (as-array string))
        ""))

(define-function compile-js (exp)
  (select exp instance?
    ((<array>)
     (if (empty? exp)
         (signal (make <error> message: "empty expression"))
         (compile-js-exp exp)))
    ((<number>)
     (as-string exp))
    ((<boolean>)
     (if exp "true" "false"))
    ((<string>)
     (concatenate "\"" (escape-string exp) "\""))
    (else:
     (description exp))))

(define-function compile-js-exp (exp)
  (bind ((name (symbol-name (first exp))))
    (select name ==
      (("%array")
       (destructuring-bind (_ #rest elements) exp
         (concatenate
          "[" (join (map compile-js elements) ", ") "]")))
      (("%if")
       (destructuring-bind (_ test then else) exp
         (concatenate
          "if (" (compile-js test) ")\n"
          (compile-js then)
          (if else
              (concatenate
               "\nelse " (compile-js else))
              ""))))
      (("%while")
       (destructuring-bind (_ test body) exp
         "while (" (compile-js test) ")\n"
         (compile-js body)))
      (("%return")
       (concatenate
        "return " (compile-js (second exp))))
      (("%begin")
       (concatenate
        "{" (join (map compile-js (rest exp)) ";\n") "}"))
      (("%set")
       (destructuring-bind (_ var value) exp
         (concatenate
          (compile-js var) " = "
          (compile-js value))))
      (("%method")
       ;; TODO: add to environment
       (bind ((name (generate-symbol)))
         (destructuring-bind (_ arguments body) exp
           (concatenate
            "function " (compile-js name)
            " (" (join (map compile-js arguments) ", ") ") {\n"
            ;; optimization: default is false
            (if body
                ;; TOOD: check if %begin and directly embed
                (compile-js body)
                "")
            "}"
            ))))
       (("js:var")
        (destructuring-bind (_ #rest bindings) exp
          (concatenate
           "var "
           (join (map (method (binding)
                        (destructuring-bind (var value)
                            binding
                          (concatenate
                           (compile-js var)
                           (if value
                               (concatenate
                                " = " (compile-js value))
                               ""))))
                      bindings)
                 ",\n"))))
      (else:
       (destructuring-bind (head #rest tail) exp
         (concatenate
          (compile-js head)
          "(" (join (map compile-js tail) ", ") ")"))))))

