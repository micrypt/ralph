
(define-module ralph/compiler2
  import: (ralph/format
           ralph/compiler2/environment
           ralph/compiler2/macroexpansion
           ralph/compiler2/syntax-quote)
  export: (*core-symbol-macros*
           *core-special-forms*
           *internal-special-forms*
           *all-special-forms*
           *core-macros*
           *internal-macros*))

;;;; utilities

;; => (normal-parameters
;;     rest-parameter
;;     keyword-parameters)
(define-function destructure-parameter-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function setter-identifier? (form)
  (and (instance? form <array>)
       (== (size form) 2)
       (every? (rcurry instance? <symbol>)
               form)
       (== (symbol-name (first form))
           "setter")))


(define-function transform-setter-identifier (identifier)
  (symbol (concatenate (symbol-name identifier)
                       "-setter")))

(define-function identifier-name (identifier)
  (symbol-name
   (if (setter-identifier? identifier)
       (transform-setter-identifier (second identifier))
       identifier)))

(define $hash-symbols [#key #rest])

(define-function parameter-list-identifiers (parameter-list)
  (map (method (parameter)
         (if (instance? parameter <array>)
             (first parameter)
             parameter))
       (choose (method (parameter)
                 (not (member? parameter $hash-symbols)))
               parameter-list)))

(define-function check-identifier (identifier env format-string)
  (unless (or (not (get identifier "module"))
              (== (get identifier "module")
                  (get env "module" "name")))
    (signal (format-to-string (or format-string
                                  "External identifier: %=")
                              identifier))))

(define-function check-type (value type format-string)
  (unless (instance? value type)
    (signal (format-to-string format-string value))))

(define-function expand-forms (symbol env #rest forms)
  `(,symbol
    ,@(map (rcurry macroexpand-all env)
           forms)))


(define-function wrap-keys (form rest-parameter keyword-parameters)
  (bind ((keyword-parameters*
          (map (method (parameter)
                 (if (instance? parameter <array>)
                     parameter
                     [parameter #f]))
               keyword-parameters)))
    `(bind-properties ,(map first keyword-parameters*)
         (%keys ,rest-parameter
                (%object
                 ,@(reduce1 concatenate
                            (map (method (parameter)
                                   (destructuring-bind (key value)
                                       parameter
                                     [(symbol-name key) value]))
                                 keyword-parameters*))))
       ,form)))


(define-function wrap-rest/keys
    (form all-parameters normal-parameters
     rest-parameter keyword-parameters)
  (bind ((rest? rest-parameter)
         (rest-parameter (or rest-parameter
                             (unless (empty? keyword-parameters)
                               (generate-symbol))))
         (form* (if (empty? keyword-parameters)
                    form
                    (wrap-keys form rest-parameter
                               keyword-parameters))))
    (if (or rest? (not (empty? keyword-parameters)))
        `(bind ((,rest-parameter
                 (%native-call "$SL.call" ,all-parameters
                               ,(size normal-parameters))))
           ,form*)
        form*)))

(define-function strip-types (parameters)
  (map (method (parameter)
         (if (instance? parameter <array>)
             (first parameter)
             parameter))
       parameters))

(define-function named-method (name parameter-list form)
  (destructuring-bind (normal-parameters
                       rest-parameter
                       keyword-parameters)
      (destructure-parameter-list parameter-list)
    `(%method ,name
              ,(strip-types normal-parameters)
              ,(wrap-rest/keys
                form
                '%all-arguments
                normal-parameters
                rest-parameter
                keyword-parameters))))


;;;; special forms
;; control expansion, track shadowing
;; * handler-case is a special form
;; * bind-methods is not a special form, just a macro
;; * block and for are not available/implemented, instead: while

;; core special forms

(define *core-special-forms*
  (make-plain-object))

(set! (get *core-special-forms* "quote")
      (method (_ form #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(quote ,form)))

(set! (get *core-special-forms* "bind")
      (method (env bindings #rest forms)
        ;; NOTE: sequential check and bind of identifiers
        (bind ((identifiers [])
               (bindings*
                (map (method (binding)
                       (bind ((array? (instance? bindings <array>)))
                         (destructuring-bind (identifier value #rest superflous)
                             (if array?
                                 binding
                                 [binding])
                           ;; TODO [#B]: (unless (empty? superflous) (warn ...))
                           (check-type identifier <symbol>
                                       "Non-symbol identifier in bind: %=")
                           ;; check if identifier is local
                           (check-identifier identifier env
                                             "External identifier in bind: %=")
                           ;; expand value (before binding identifier)
                           (bind ((value* (macroexpand-all value env)))
                             ;; bind identifier, save for unbind
                             ;; after expanding forms
                             (bind! identifier env)
                             (push-last identifiers identifier)
                             ;; result
                             (if array?
                                 `(,identifier ,value*)
                                 identifier)))))
                     bindings)))
          ;; expand forms
          (bind ((forms* (map (rcurry macroexpand-all env)
                              forms)))
            ;; unbind identifiers
            (do (rcurry unbind! env)
                identifiers)
            `(bind (,@bindings*)
               ,@forms*)))))

(set! (get *core-special-forms* "method")
      (method (env parameter-list #rest forms)
        ;; determine identifiers introduced through parameter list
        (bind ((identifiers
                (parameter-list-identifiers parameter-list)))
          ;; TODO: check identifiers are symbols
          ;; check if identifiers are local
          (do (rcurry check-identifier env
                      "External identifier in parameter list of method: %=")
              identifiers)
          ;; generate new parameter-list: expand keyword default values
          ;; (before binding identifiers)
          (bind ((parameter-list*
                  (destructuring-bind (normal-parameters
                                       rest-parameter
                                       keyword-parameters)
                      (destructure-parameter-list parameter-list)
                    (concatenate normal-parameters
                                 (if rest-parameter
                                     `(#rest ,rest-parameter)
                                     [])
                                 (if keyword-parameters
                                     `(#key
                                       ,@(map (method (parameter)
                                                (if (instance? parameter <array>)
                                                    [(first parameter)
                                                     (macroexpand-all
                                                      (second parameter) env)]
                                                    parameter))
                                              keyword-parameters))
                                     [])))))
            ;; bind identifiers
            (do (rcurry bind! env)
                identifiers)
            ;; expand forms
            (bind ((forms* (map (rcurry macroexpand-all env)
                                forms)))
              ;; unbind identifiers
              (do (rcurry unbind! env)
                  identifiers)
              ;; result
              `(method ,parameter-list*
                 ,@forms*))))))

(set! (get *core-special-forms* "set!")
      ;; place new-value #rest arguments
      ;; TODO: expansion of place correct ?
      (curry expand-forms `set!))

(set! (get *core-special-forms* "define")
      (method (env identifier initial-value #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type identifier <symbol>
                    "Non-symbol identifier in define: %=")
        ;; check if identifier is local
        (check-identifier identifier env
                          "External identifier in define: %=")
        ;; TODO [#A]: warn if identifier is imported
        ;;            (accidental redefinition)
        ;; bind identifier
        (bind-globally! identifier env)
        ;; result
        (if initial-value
            `(define ,identifier
               ,(macroexpand-all initial-value env))
            `(define ,identifier))))

(set! (get *core-special-forms* "if")
      (method (env test consequent alternate #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(if ,@(map (rcurry macroexpand-all env)
                    [test consequent alternate]))))

(set! (get *core-special-forms* "begin")
      (curry expand-forms `begin))


(set! (get *core-special-forms* "while")
      ;; test #rest forms
      (curry expand-forms `while))

(set! (get *core-special-forms* "handler-case")
      (method (env protected-form #rest cases)
        `(handler-case
          ,(macroexpand-all protected-form env)
          ,@(map (method (case)
                   (check-type case <array>
                               "Non-array case in handler-case: %=")
                   (destructuring-bind (binding #rest forms) case
                     (check-type binding <array>
                                 "Non-array case-binding in handler-case: %=")
                     (destructuring-bind (type #key condition) binding
                       (when condition
                         (check-type condition <symbol>
                                     "Non-symbol condition variable in handler-case: %=")
                         ;; check if identifier is local
                         (check-identifier condition env
                                           "External identifier in handler-case: %=")
                         ;; bind condition
                         (bind! condition env))
                       ;; expand type and forms
                       (bind ((type* (macroexpand-all type env))
                              (forms* (map (rcurry macroexpand-all env)
                                           forms)))
                         (when condition
                           ;; unbind condition
                           (unbind! condition env))
                         ;; result: new case
                         `((,type* ,@(rest binding)) ,@forms*)))))
                 cases))))

;; internal special forms

(define *internal-special-forms*
  (make-plain-object))

(set! (get *internal-special-forms* "%quote")
      (method (_ form #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(%quote ,form)))

(set! (get *internal-special-forms* "%bind")
      (method (env binding form #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type binding <array>
                    "Non-array binding in %%bind: %=")
        (destructuring-bind (identifier value) binding
          ;; TODO: check identifier is a symbol
          ;; check if identifier is local
          (check-identifier identifier env
                            "External identifier in %%bind: %=")
          ;; expand value (before binding identifier)
          (bind ((value* (macroexpand-all value env)))
            ;; bind identifier
            (bind! identifier env)
            ;; expand form
            (bind ((form* (macroexpand-all form env)))
              ;; unbind identifier
              (unbind! identifier env)
              ;; result
              `(%bind (,identifier ,value*)
                      ,form*))))))

(set! (get *internal-special-forms* "%method")
      (method (env name parameters form #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (bind ((identifiers (cons name parameters)))
          ;; check name is a symbol
          (check-type name <symbol>
                      "Non-symbol name in %%method: %=")
          ;; check all parameters are symbols
          (do (method (parameter)
                (check-type parameter <symbol>
                            "Non-symbol parameter in %%method: %="))
              parameters)
          ;; check if identifiers are local
          (do (rcurry check-identifier env
                      "External identifier in parameter list of %%method: %=")
              identifiers)
          ;; bind identifiers
          (do (rcurry bind! env)
              identifiers)
          ;; expand form
          (bind ((form* (macroexpand-all form env)))
            ;; unbind identifiers
            (do (rcurry unbind! env)
                identifiers)
            ;; result
            `(%method ,name ,parameters
                      ,form*)))))

(set! (get *internal-special-forms* "%set")
      (method (env identifier value #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type identifier <symbol>
                    "Non-symbol identifier in %%set: %=")
        ;; TODO [#A]: check if identifier is local ?
        `(%set ,identifier
               ,(macroexpand-all value env))))

(set! (get *internal-special-forms* "%define")
      (method (env identifier #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type identifier <symbol>
                    "Non-symbol identifier in %%define: %=")
        ;; bind identifier
        (bind-globally! identifier env)
        `(%define ,identifier)))

(set! (get *internal-special-forms* "%if")
      (method (env test consequent alternate #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(%if ,@(map (rcurry macroexpand-all env)
                     [test consequent alternate]))))

(set! (get *internal-special-forms* "%begin")
      ;; #rest forms
      (curry expand-forms `%begin))

(set! (get *internal-special-forms* "%while")
      (method (env test form #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(%while ,@(map (rcurry macroexpand-all env)
                        [test form]))))

(set! (get *internal-special-forms* "%try")
      (method (env protected-form identifier handling-form #rest superfluous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type identifier <symbol>
                    "Non-symbol identifier in %%try: %=")
        ;; check if identifier is local
        (check-identifier identifier env
                          "External identifier in %%try: %=")
        ;; bind identifier
        (bind! identifier env)
        ;; expand handling form
        (bind ((handling-form* (macroexpand-all handling-form env)))
          ;; unbind identifier
          (unbind! identifier env)
          ;; result
          `(%try ,(macroexpand-all protected-form env)
                 ,identifier
                 ,handling-form*))))

(set! (get *internal-special-forms* "%var")
      (method (env identifier #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type identifier <symbol>
                    "Non-symbol identifier in %%var: %=")
        `(%var ,identifier)))

(set! (get *internal-special-forms* "%native-name")
      (method (env name #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type name <string>
                    "Non-string name in %%native-name: %=")
        `(%native-name ,name)))

(set! (get *internal-special-forms* "%native-call")
      (method (env operator #rest arguments)
        (check-type operator <string>
                    "Non-string operator in %%native-call: %=")
        `(%native-call ,operator
                       ,@(map (rcurry macroexpand-all env)
                              arguments))))

(set! (get *internal-special-forms* "%infix")
      (method (env operator #rest arguments)
        ;; TODO [#B]: check operator is a string
        `(%infix ,operator
                 ,@(map (rcurry macroexpand-all env)
                        arguments))))

(set! (get *internal-special-forms* "%native")
      ;; #rest forms
      (curry expand-forms `%native))

(set! (get *internal-special-forms* "%object")
      (method (env #rest property/values)
        `(%object ,@(reduce1 concatenate
                             (map (method (property/value)
                                    (destructuring-bind (property value)
                                        property/value
                                      (check-type property <string>
                                                  "Non-string property in %%object: %=")
                                      [property (macroexpand-all value env)]))
                                  (partition 2 property/values))))))

(set! (get *internal-special-forms* "%array")
      ;; #rest elements
      (curry expand-forms `%array))

(set! (get *internal-special-forms* "%get-property")
      ;; object #rest properties
      (curry expand-forms `%get-property))



;; all special forms

(define *all-special-forms*
  (make-plain-object))

(extend! *all-special-forms*
         *internal-special-forms*)
(extend! *all-special-forms*
         *core-special-forms*)


;;;; macros

;; core macros

(define *core-macros*
  (make-plain-object))

(set! (get *core-macros* "when")
      (method (_ test #rest forms)
        `(if ,test
             (begin ,@forms)
             #f)))

(set! (get *core-macros* "unless")
      (method (_ test #rest forms)
        `(if (not ,test)
             (begin ,@forms)
             #f)))

(set! (get *core-macros* "parallel-set!")
      (method  (_ identifier new-value #rest clauses)
        (if (empty? clauses)
            `(set! ,identifier ,new-value)
            (bind ((value (generate-symbol)))
              `(bind ((,value ,new-value))
                 (parallel-set! ,@clauses)
                 (set! ,identifier ,value))))))

(set! (get *core-macros* "cond")
      (method (_ #rest cases)
        (unless (empty? cases)
          (bind ((case (first cases)))
            (check-type case <array>
                        "Non-array case in cond: %=")
            (destructuring-bind (test #rest forms) case
              (bind ((form `(begin ,@forms)))
                (if (== test else:)
                    form
                    `(if ,test
                         ,form
                         (cond ,@(rest cases))))))))))

(set! (get *core-macros* "and")
      (method (_ #rest forms)
        (select (size forms) ==
          ((0) #t)
          ((1) (first forms))
          (else: `(when ,(first forms)
                    (and ,@(rest forms)))))))

(set! (get *core-macros* "or")
      (method (_ #rest forms)
        (select (size forms) ==
          ((0) #f)
          ((1) (first forms))
          (else:
           (bind ((value (generate-symbol)))
             `(bind ((,value ,(first forms)))
                (if ,value
                    ,value
                    (or ,@(rest forms)))))))))

(set! (get *core-macros* "if-bind")
      (method (_ binding consequent alternate #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (check-type binding <array>
                    "Non-array binding in if-bind: %=")
        (destructuring-bind (var value) binding
          (bind ((temp (generate-symbol)))
            `(bind ((,temp ,value))
               (if ,temp
                   (bind ((,var ,temp))
                     ,consequent)
                   ,alternate))))))

(set! (get *core-macros* "until")
      (method (_ test #rest forms)
        `(while (not ,test)
           ,@forms)))

(set! (get *core-macros* "dotimes")
      (method (_ binding #rest forms)
        (check-type binding <array>
                    "Non-array binding in dotimes: %=")
        (bind ((temp (generate-symbol)))
          (destructuring-bind (var count result) binding
            (check-type var <symbol>
                        "Non-symbol var in dotimes: %=")
            `(bind ((,temp ,count))
               (for ((,var 0 (+ ,var 1)))
                   ((>= ,var ,temp) ,(or result #f))
                 ,@forms))))))

(set! (get *core-macros* "for")
      (method (_ clauses end-clause #rest forms)
        (check-type clauses <array>
                    "Non-array set of clauses in for: %=")
        (check-type end-clause <array>
                    "Non-array end-clause in for: %=")
        (bind ((init-clauses [])
               (next-clauses [])
               (vars (map first clauses)))
          (for-each ((clause clauses))
                    ()
            (check-type clause <array>
                        "Non-array clause in for: %=")
            ;; init form
            (push-last init-clauses
                       (slice clause 0 2))
            ;; next form
            (push-last next-clauses
                       (first clause))
            (push-last next-clauses
                       (third clause)))
          ;; result
          `(bind ,init-clauses
             (while ,(or (empty? end-clause)
                         `(not ,(first end-clause)))
               ;; create closure
               ((method ,vars ,@forms)
                ,@vars)
               (parallel-set! ,@next-clauses))
             (begin ,@(rest end-clause))))))

(set! (get *core-macros* "for-each")
      (method (_ clauses end-clause #rest forms)
        (check-type clauses <array>
                    "Non-array set of clauses in for: %=")
        (check-type end-clause <array>
                    "Non-array end-clause in for: %=")
        (bind ((clauses
                (map (method (clause)
                       (check-type clause <array>
                                   "Non-array clause in for-each: %=")
                       (cons (generate-symbol)
                             clause))
                     clauses))
               (end? (generate-symbol))
               (values (generate-symbol))
               (result (generate-symbol))
               (form `(begin
                       ;; rebind variables to create closure
                       ,(bind ((vars (map second clauses)))
                          `((method ,vars ,@forms)
                            ,@vars))
                       ;; update temporary collection bindings
                       ,@(map (method (clause)
                                `(set! ,(first clause)
                                       (rest ,(first clause))))
                              clauses)
                       (set! ,values
                             (%array ,@(map first clauses))))))
          ;; evaluate each collection once
          `(bind (,@(map (method (clause)
                           (destructuring-bind (temp var values)
                               clause
                             [temp values]))
                         clauses)
                  (,end? #f)
                  (,result #f)
                  (,values (%array ,@(map first clauses))))
             ;; check exhaustion
             (until (or ,end? (any? empty? ,values))
               ;; bind each var to next element
               (bind ,(map (method (clause)
                             (destructuring-bind (temp var values) clause
                               [var `(first ,temp)]))
                           clauses)
                 ,(if-bind (end-test (first end-clause))
                    `(if ,end-test
                         (begin
                          (set! ,result
                                (begin ,@(rest end-clause)))
                          (set! ,end? #t))
                         ,form)
                    form)))
             ,result))))

(set! (get *core-macros* "select")
      (method (_ value test #rest cases)
        (bind ((value* (generate-symbol))
               (test* (if (instance? test <symbol>)
                          test
                          (generate-symbol))))
          (bind-methods ((test-expression (test-value)
                           [test* value* test-value]))
            `(bind ,(concatenate
                     [[value* value]]
                     (if (instance? test <symbol>)
                         []
                         [[test* test]]))
               (cond
                ,@(map (method (case)
                         (check-type case <array>
                                     "Non-array case in select: %=")
                         (destructuring-bind (test-forms #rest forms) case
                           (if (== test-forms else:)
                               case
                               (begin
                                (check-type test-forms <array>
                                            "Non-array set of test forms in select: %=")
                                `((or ,@(map test-expression test-forms))
                                  ,@forms)))))
                       cases)))))))

(define-function destructure (bindings values form)
  (if (instance? values <symbol>)
      (begin
       (check-type bindings <array>
                   "Non-array set of bindings while destructuring: %=")
       (destructuring-bind (normal-parameters
                            rest-parameter
                            keyword-parameters)
           (destructure-parameter-list bindings)
         (bind ((i (size normal-parameters)))
           (reduce (method (form binding)
                     (dec! i)
                     (if (instance? binding <symbol>)
                         `(bind ((,binding (%get-property ,values ,i)))
                            ,form)
                         (destructure binding
                                      `(%get-property ,values ,i)
                                      form)))
                   (wrap-rest/keys form values
                                   normal-parameters
                                   rest-parameter
                                   keyword-parameters)
                   (reverse normal-parameters)))))
      ;; ensure values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var form)))))

(set! (get *core-macros* "destructuring-bind")
      (method (_ bindings values #rest forms)
        (destructure bindings values
                     `(begin ,@forms))))

(set! (get *core-macros* "bind-properties")
      (method (_ properties object #rest forms)
        (bind ((object* (generate-symbol)))
          `(bind ((,object* ,object)
                  ,@(map (method (property)
                           `(,property
                             (%get-property ,object*
                                            ,(symbol-name property))))
                         properties))
             ,@forms))))

(set! (get *core-macros* "bind-methods")
      (method (_ bindings #rest forms)
        (check-type bindings <array>
                    "Non-array set of bindings in bind-methods: %=")
        `(bind ,(map first bindings)
           ,@(map (method (binding)
                    (check-type bindings <array>
                                "Non-array binding in bind-methods: %=")
                    (destructuring-bind
                        (identifier parameter-list #rest forms)
                        binding
                      `(set! ,identifier
                             ,(named-method identifier parameter-list
                                            `(begin ,@forms)))))
                  bindings)
           ,@forms)))

; TODO: once-only
; (_ names #rest forms)
;   (bind ((symbols (map (method (name)
;                          (generate-symbol))
;                        names)))
;     `(bind (,@(map (method (symbol)
;                      `(,symbol (generate-symbol)))
;                    symbols))
;        `(bind (,,@(map (method (symbol name)
;                          ``(,,symbol ,,name))
;                        symbols names))
;           ,(bind (,@(map (method (name symbol)
;                            `(,name ,symbol))
;                          names symbols))
;           ,@forms))))

(set! (get *core-macros* "inc!")
      (method (_ object value)
        `(set! ,object (+ ,object ,(or value 1)))))

(set! (get *core-macros* "dec!")
      (method (_ object value)
        `(set! ,object (- ,object ,(or value 1)))))

(define-function signal-unsupported-dot-name (property)
  (signal (format-to-string "Unsupported name for call in dot: %="
                            property)))

(set! (get *core-macros* ".")
      (method (_ form #rest calls)
        (reduce (method (form call)
                  (check-type call <array>
                              "Non-array call in dot: %=")
                  (destructuring-bind (property #rest arguments) call
                    (bind ((bindings (map (method (argument)
                                            [(generate-symbol) argument])
                                          arguments))
                           (form* (generate-symbol)))
                      ;; prevent lifting through ANF
                      `(bind ((,form* ,form))
                         (bind ,bindings
                           ((%get-property ,form*
                                           ,(select property instance?
                                              ((<string>) property)
                                              ((<symbol>) (symbol-name property))
                                              (else: (signal-unsupported-dot-name
                                                      property))))
                            ,@(map first bindings)))))))
                form
                calls)))

(define-function make-function-definer
    (macro-name definer #key name? type/existing? record?)
  (method (env identifier parameter-list #rest forms)
    (destructuring-bind (setter? identifier)
        (if (setter-identifier? identifier)
            [#t (transform-setter-identifier (second identifier))]
            [#f identifier])
      (unless (or (instance? identifier <symbol>)
                  setter?)
        (signal (format-to-string "Identifier not symbol or setter in %s: %="
                                  macro-name identifier)))
      (when (and type/existing?
                 (empty? parameter-list))
        (signal (format-to-string "Empty parameter-list in %s: %="
                                  macro-name parameter-list)))
      (bind ((name (symbol-name identifier))
             (method-definition
              (named-method (if name?
                                identifier
                                (generate-symbol))
                            parameter-list
                            `(begin ,@forms))))
        (when record?
          (set! (get env "module" "functions" name)
                method-definition))
        ;; result
        `(define ,identifier
           (,definer
             (%native-name ,name)
             ,method-definition
             ,setter?
             ,@(if type/existing?
                   `(,(bind ((head (first parameter-list)))
                        (if (and (instance? head <array>)
                                 (> (size head) 1))
                            (second head)
                            `<object>))
                     ,identifier)
                   [])))))))

(for-each ((arguments [["define-function" `%make-function
                        record?: #t
                        name?: #t]
                       ["define-method" `%make-method
                        type/existing?: #t]]))
          ()
  (set! (get *core-macros* (first arguments))
        (apply make-function-definer arguments)))

(set! (get *core-macros* "define-generic")
      (method (_ identifier arguments #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        `(define ,identifier
           (%make-generic
            (%native-name ,(symbol-name identifier))))))

(set! (get *core-macros* "define-class")
      (method (_ identifier superclass #rest properties)
        `(define ,identifier
           (%make-class
            ;; superclass
            ,(unless (empty? superclass)
               (first superclass))
            ;; properties
            (%object
             ,@(reduce1 concatenate
                        (map (method (property)
                               (if (instance? property <array>)
                                   [(symbol-name (first property))
                                    `(method ()
                                       ,(second property))]
                                   [(symbol-name property) #f]))
                             properties)))
            ;; constructor
            (%method ,identifier ()
              (%begin
               ,@(map (method (property)
                        `(%set (%get-property (%native "this")
                                              ,(if (instance? property <array>)
                                                   (symbol-name (first property))
                                                   (symbol-name property)))
                               (%native "undefined")))
                      properties)))))))


(set! (get *core-macros* "define-macro")
      (method (_ identifier parameter-list #rest forms)
        (check-type identifier <symbol>
                    "Non-symbol identifier in define-macro: %=")
        (check-type parameter-list <array>
                    "Non-array parameter-list in define-macro: %=")
        `(begin
          ;; TODO [#A]: properly inject environment (and complete form ?)
          (define-function ,identifier (,(generate-symbol)
                                        ,@parameter-list)
            ,@forms)
          (set! (%get-property ,identifier "%macro?") #t))))

(set! (get *core-macros* "define-symbol-macro")
      (method (_ identifier parameter-list #rest forms)
        (check-type identifier <symbol>
                    "Non-symbol identifier in define-symbol-macro: %=")
        (check-type parameter-list <array>
                    "Non-array parameter-list in define-symbol-macro: %=")
        `(begin
          ;; TODO: properly inject environment
          (define-function ,identifier ()
            ,@forms)
          (set! (%get-property ,identifier "%symbol-macro?") #t))))

(set! (get *core-macros* "syntax-quote")
      (method (env form #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        (syntax-quote-form form env)))


;; TODO [#A]: define-module


;; core symbol macros

(define *core-symbol-macros*
  (make-plain-object))

;; internal macros

(define *internal-macros*
  (make-plain-object))

(set! (get *internal-macros* "quote")
      (method (_ form #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        ;;            NOTE: also already checked by if
        `(%quote ,form)))

(set! (get *internal-macros* "begin")
      (method (_ #rest forms)
        (select (size forms) ==
          ((0) #f)
          ((1) (first forms))
          (else:
           `(%begin ,@forms)))))

(set! (get *internal-macros* "bind")
      (method (_ bindings #rest forms)
        (reduce (method (form binding)
                  `(%bind ,(if (instance? binding <symbol>)
                               `(,binding #f)
                               binding)
                          ,form))
                `(begin ,@forms)
                (reverse bindings))))

(set! (get *internal-macros* "method")
      (method (_ parameter-list #rest forms)
        (named-method (generate-symbol)
                      parameter-list
                      `(begin ,@forms))))

(set! (get *internal-macros* "while")
      (method (_ test #rest forms)
        `(%while ,test
           (begin ,@forms))))

(set! (get *internal-macros* "if")
      (method (_ test then else #rest superflous)
        ;; TODO [#B]: (unless (empty? superflous) (warn ...))
        ;;            NOTE: also already checked by if
        `(%if ,test ,then ,else)))

(set! (get *internal-macros* "set!")
      (method (_ place #rest new-values)
        (if (and (instance? place <array>)
                 (not (== (first place)
                          '%get-property)))
            ;; invoke setter
            `(,(transform-setter-identifier (first place))
              ,@(rest place)
              ,@new-values)
            ;; primitive set
            ;; TODO [#B]: (unless (empty? (rest values)) (warn ...))
            `(%set ,place ,(first new-values)))))

(set! (get *internal-macros* "define")
      (method (env identifier value)
        `(begin
          (%define ,identifier)
          (%set ,identifier ,value))))


(set! (get *internal-macros* "handler-case")
      (method  (_ protected-form #rest cases)
        (bind ((condition-var (generate-symbol)))
          `(%try ,protected-form
                 ,condition-var
                 (cond
                  ,@(map (method (case)
                           (destructuring-bind ((type #key condition) #rest body) case
                             (concatenate `((instance? ,condition-var ,type))
                                          (if condition
                                              `((bind ((,condition ,condition-var))
                                                  ,@body))
                                              body))))
                         cases))))))



;; NOTE: ensure an internal macro exists for each core special form

(do (method (name)
      (unless (has? *internal-macros* name)
        (signal (format-to-string
                 "No internal macro for special form: %s" name))))
    (object-properties *core-special-forms*))
