
(define-module ralph/compiler
  import: (ralph/stream ralph/format
           ralph/reader ralph/file-system
           ralph/compiler/utilities
           ralph/compiler/alpha
           ralph/compiler/anf
           ralph/compiler/statements
           ralph/compiler/flattening
           ralph/compiler/javascript)
  compile-time-import: (ralph/compiler-macros)
  export: (compile-module
           compile-expression
           analyze-dependencies
           macroexpand-1
           macroexpand
           macroexpand-all
           <module> <environment>
           ;; for testing purposes
           *core-symbol-macros*
           *core-macros*
           define-free-variables
           analyze-lambda-list
           lift-symbols
           lift-defines
           atomic?))

;; NOTE: naming convention:
;; - identifier = symbol, name = string
;; - verbed functions or predicates

;; NOTE: no symbol expansion after macroexpand-all,
;;       as ANF uses atomic? to decide if expression
;;       has side-effects and needs to be normalized
;;       (influences evaluation order)

;;;; modules

;; module-name => <module>
(define *modules* (make-object))

(define-class <module> (<object>)
  name
  native?
  ;; name*
  (exports [])
  ;; [module name*]*
  (imports [])
  (dependencies [])
  ;; name*
  (inline []))

(define *defined?*
  `(%all-arguments %this-method))

(define-class <environment> (<object>)
  module
  (macros (make-plain-object))
  (symbol-macros (make-plain-object))
  ;; see alpha conversion
  (identifiers (make-object))
  (defined? (make-object))
  (lifted (make-object))
  (import-identifiers (make-plain-object)))



(define-function bind! (env identifier)
  (set! (get env "bound?" (symbol-name identifier))
        #t))

(define-function unbind! (env identifier)
  (set! (get env "bound?" (symbol-name identifier))
        #f))


;;;; special forms

;; utilities

(define *special-forms*
  (make-object))

(define-function find-special-form (form env)
  (when (expression? form)
    (get *special-forms*
         (symbol-name (first form)))))

;; definitions
(define-special-form %method (env arguments body)
  (do (curry bind! env)
      arguments)
  (bind ((expanded-body
          (macroexpand-all body env)))
    (do (curry unbind! env)
        arguments)
    `(%method ,arguments
       ,expanded-body)))

(define-special-form
  %set (env identifier value)
  `(%set ,identifier ,(macroexpand-all value env)))

(define-special-form define (env identifier value)
  (bind! env identifier)
  `(define ,identifier
     ,(macroexpand-all value env)))

;; TODO: make binding available inside value?
;; (if so, also change alpha-convert,
;;  find-free-variables)
(define-special-form %bind (env binding body)
  (destructuring-bind (var value) binding
    (bind ((expanded-value
            (macroexpand-all value env)))
      (bind! env var)
      (bind ((result
              `(%bind (,var ,expanded-value)
                      ,(macroexpand-all body env))))
        (unbind! env var)
        result))))

;;;; core macros

;; utilities

(define *core-macros*
  (make-object))

;; => [required rest keys]
(define-function analyze-lambda-list (list)
  (bind-methods ((position (symbol)
                   (find-key list (curry = symbol))))
    (bind ((rest (position #rest))
           (key (position #key)))
      [(copy-sequence list
                      end: (or rest key
                               (size list)))
       (when rest
         (element list (inc rest)))
       (when key
         (copy-sequence list
                        start: (inc key)))])))

(define-function wrap (form #rest wrappers)
  (reduce (method (result wrapper)
            (wrapper result))
          form
          wrappers))

(define-function wrap-rest/keys (body all required rest key)
  (bind ((rest? rest)
         (rest (or rest
                   (unless (empty? key)
                     (generate-symbol)))))
    (wrap body
          (method (body)
            (if (empty? key)
                body
                (bind ((key-values
                        (map (method (binding)
                               (if (instance? binding <array>)
                                   binding
                                   [binding #f]))
                             key)))
                  `(bind-properties ,(map first key-values)
                       (%keys ,rest
                              ,(concatenate `(%object)
                                            (reduce1 concatenate
                                                     (map (method (key-value)
                                                            (destructuring-bind (key value)
                                                                key-value
                                                              [(symbol-name key) value]))
                                                          key-values))))
                     ,body))))
          (method (body)
            (if (or rest? (not (empty? key)))
                `(bind ((,rest (%native-call "$SL.call" ,all ,(size required))))
                   ,body)
                body)))))

;; definitions

(define-core-macro begin (_ #rest expressions)
  (maybe-begin expressions))

(define-core-macro method (_ arguments #rest body)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    `(%method ,required
       ,(wrap-rest/keys
         (maybe-begin body)
         (symbol "%all-arguments")
         required rest key))))


(define-core-macro bind (_ bindings #rest body)
  (if (empty? bindings)
      (maybe-begin body)
      (reduce (method (body binding)
                `(%bind
                  ,(if (instance? binding <symbol>)
                       `(,binding #f)
                       binding)
                  ,body))
              (maybe-begin body)
              (reverse bindings))))

(define-core-macro if (_ test then else)
  `(%if ,test ,then ,else))

(define-core-macro set! (_ place #rest values)
  (if (and (instance? place <array>)
           (not (== (first place)
                    (symbol "%get-property"))))
      (concatenate `(,(transform-setter-identifier (first place)))
                   (rest place)
                   values)
      `(%set ,place ,(first values))))


(define-core-macro parallel-set! (_ var value #rest clauses)
  (if (empty? clauses)
      `(set! ,var ,value)
      (bind ((temp (generate-symbol)))
        `(bind ((,temp ,value))
           ,(concatenate `(parallel-set!)
                         clauses)
           (set! ,var ,temp)))))


(define-core-macro cond (_ #rest cases)
  (unless (empty? cases)
    (destructuring-bind (test #rest then) (first cases)
      (bind ((then (maybe-begin then)))
        (if (== test else:)
            then
            `(if ,test
                 ,then
                 ,(concatenate `(cond)
                               (rest cases))))))))

(define-core-macro when (_ test #rest body)
  `(if ,test
       ,(maybe-begin body)
       #f))

(define-core-macro unless (_ test #rest body)
  `(if (not ,test)
       ,(maybe-begin body)
       #f))

(define-core-macro and (_ #rest values)
  (select (size values) ==
    ((0) #t)
    ((1) (first values))
    (else: `(when ,(first values)
              ,(concatenate `(and)
                            (rest values))))))

(define-core-macro or (_ #rest values)
  (select (size values) ==
    ((0) #f)
    ((1) (first values))
    (else:
     (bind ((value (generate-symbol)))
       `(bind ((,value ,(first values)))
          (if ,value
              ,value
              ,(concatenate `(or)
                            (rest values))))))))

(define-core-macro if-bind (_ binding then else)
  (destructuring-bind (var value) binding
    (bind ((temp (generate-symbol)))
      `(bind ((,temp ,value))
         (if ,temp
             (bind ((,var ,temp))
               ,then)
             ,else)))))

(define-core-macro while (_ test #rest body)
  `(%while ,test
     ,(maybe-begin body)))

(define-core-macro until (_ test #rest body)
  (concatenate `(while (not ,test))
               body))

(define-core-macro dotimes (_ binding #rest body)
  (bind ((temp (generate-symbol)))
    (destructuring-bind (var count result) binding
      `(bind ((,temp ,count))
         ,(concatenate
           `(for ((,var 0 (+ ,var 1)))
                 ((>= ,var ,temp) ,(or result #f)))
           body)))))

(define-core-macro for (_ clauses end #rest body)
  (bind ((init-clauses [])
         (next-clauses [])
         (vars (map first clauses)))
    (for-each ((clause clauses))
              ()
      ;; init
      (push-last init-clauses
                 (slice clause 0 2))
      ;; next
      (push-last next-clauses
                 (first clause))
      (push-last next-clauses
                 (third clause)))
    `(bind ,init-clauses
       ,(concatenate `(while ,(or (empty? end)
                                  `(not ,(first end)))
                        ,(concatenate
                          `(,(concatenate `(method ,vars)
                                          body))
                          vars)
                        ,(concatenate `(parallel-set!)
                                      next-clauses)))
       ,(unless (empty? (rest end))
          (concatenate `(begin)
                       (rest end))))))

(define-core-macro for-each (_ clauses end #rest body)
  (bind ((clauses
          (map (method (clause)
                 (concatenate [(generate-symbol)]
                              clause))
               clauses))
         (end? (generate-symbol))
         (values (generate-symbol))
         (result (generate-symbol))
         (body (concatenate
                `(begin
                  ;; rebind variables to create closure
                  ,(bind ((vars (map second clauses)))
                     (concatenate
                      `(,(concatenate `(method ,vars)
                                      ;; actual body
                                      body))
                      vars)))
                ;; update temporary collection bindings
                (map (method (clause)
                       `(set! ,(first clause)
                              (rest ,(first clause))))
                     clauses)
                `((set! ,values
                        ,(concatenate `(%array)
                                      (map first clauses)))))))
    ;; evaluate each collection once
    `(bind ,(concatenate
             (map (method (clause)
                    (destructuring-bind (temp var values) clause
                      [temp values]))
                  clauses)
             `((,end? #f)
               (,result #f)
               (,values ,(concatenate `(%array)
                                      (map first clauses)))))
       ;; check exhaustion
       (until (or ,end? (any? empty? ,values))
         ;; bind each var to next element
         (bind ,(map (method (clause)
                       (destructuring-bind (temp var values) clause
                         [var `(first ,temp)]))
                     clauses)
           ,(if-bind (end-test (first end))
              `(if ,end-test
                   (begin
                    (set! ,result
                          ,(maybe-begin
                            ;; execute all result expressions, returning last; false if none
                            (bind ((results (rest end)))
                              (if (empty? results)
                                  [#f]
                                  results))))
                    (set! ,end? #t))
                   ,body)
              body)))
       ,result)))

(define-core-macro bind-properties (_ properties object #rest body)
  (bind ((object* (generate-symbol)))
    (concatenate
     `(bind ,(concatenate
              `((,object* ,object))
              (map (method (property)
                     `(,property
                       (%get-property ,object*
                                      ,(symbol-name property))))
                   properties)))
     body)))

(define-core-macro select (_ value test #rest cases)
  (bind ((value* (generate-symbol))
         (test* (if (instance? test <symbol>)
                    test
                    (generate-symbol))))
    (bind-methods ((test-expression (test-value)
                     [test* value* test-value]))
      `(bind ,(concatenate
               [[value* value]]
               (if (instance? test <symbol>)
                   []
                   [[test* test]]))
         ,(concatenate
           `(cond)
           (map (method (case)
                  (destructuring-bind (tests #rest then) case
                    (if (== tests else:)
                        case
                        (concatenate
                         `(,(concatenate
                             `(or)
                             (map test-expression tests)))
                         then))))
                cases))))))

(define-function destructure (bindings values body)
  (if (instance? values <symbol>)
      (destructuring-bind (required rest key)
          (analyze-lambda-list bindings)
        (bind ((i (size required)))
          (reduce (method (body binding)
                    (dec! i)
                    (if (instance? binding <symbol>)
                        `(bind ((,binding (%get-property ,values ,i)))
                           ,body)
                        (destructure binding
                                     `(%get-property ,values ,i)
                                     body)))
                  (wrap-rest/keys body
                                  values
                                  required rest key)
                  (reverse required))))
      ;; ensures values is only evaluated once
      (bind ((var (generate-symbol)))
        `(bind ((,var ,values))
           ,(destructure bindings var body)))))

(define-core-macro destructuring-bind (_ bindings values #rest body)
  (destructure bindings values
               (concatenate `(begin) body)))

(define-core-macro bind-methods (_ bindings #rest body)
  (concatenate
   `(bind ,(map first bindings))
   (map (method (binding)
          (destructuring-bind (identifier arguments #rest body)
              binding
            `(set! ,identifier
                   ,(concatenate `(method ,arguments)
                                 body))))
        bindings)
   body))

(define-core-macro inc! (_ object value)
  `(set! ,object (+ ,object ,(or value 1))))

(define-core-macro dec! (_ object value)
  `(set! ,object (- ,object ,(or value 1))))

(define-core-macro + (_ #rest values)
  (if (empty? values)
      0
      (concatenate `(%plus) values)))

(define-core-macro - (_ minuend #rest subtrahends)
  (if (empty? subtrahends)
      `(%native-call "-" ,minuend)
      (concatenate `(%minus ,minuend)
                   subtrahends)))

(define-core-macro * (_ #rest values)
  (if (empty? values)
      1
      (concatenate `(%times) values)))

(define-core-macro / (_ numerator #rest denominators)
  (if (empty? denominators)
      `(%divide 1 ,numerator)
      (concatenate `(%divide ,numerator)
                   denominators)))


;; TODO: backend-specific
(define-core-macro call-next-method (_)
  `((%get-property next-method "apply")
    (%native "null")
    %all-arguments))

(define-function transform-quoted (form)
  (cond
   ((instance? form <array>)
    (if (and (not (empty? form))
             (== (symbol-name (first form))
                 "%comma"))
        (second form)
        (concatenate `(%array)
                     (map transform-quoted
                          form))))
   ((instance? form <symbol>)
    `(symbol ,(symbol-name form)))
   (else:
    form)))

(define-core-macro %backquote (_ exp)
  (transform-quoted exp))

;; comma is only used as a marker and
;; actually handled in backquote
(define-core-macro %comma (_ value)
  (signal (make <error> message: "comma not inside backquote")))

(define *dot-name-error*
  (make <error>
        message: "unsupported name for call in dot"))

(define-core-macro . (_ value #rest calls)
  (reduce (method (value call)
            (destructuring-bind (property #rest arguments) call
              (concatenate
               `((%get-property ,value
                                ,(select property instance?
                                   ((<string>)
                                    property)
                                   ((<symbol>)
                                    (symbol-name property))
                                   (else:
                                    (signal *dot-name-error*)))))
               arguments)))
          value
          calls))

(define-function simplify-arguments (arguments)
  (destructuring-bind (required rest key)
      (analyze-lambda-list arguments)
    (bind ((required
            (map (method (argument)
                   (if (instance? argument <array>)
                       (first argument)
                       argument))
                 required)))
      (concatenate
       required
       (if rest
           (concatenate `(#rest) rest)
           [])
       (if key
           (concatenate `(#key) key)
           [])))))

(define-function make-function-definer
    (macro-name definer-name #key type/existing? record?)
  (method (env identifier arguments #rest body)
    (destructuring-bind (setter? identifier)
        (if (setter-identifier? identifier)
            [#t (transform-setter-identifier (second identifier))]
            [#f identifier])
      (unless (or (instance? identifier <symbol>)
                  setter?)
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "name not <var> or (setter <var>)"))))
      (when (and type/existing?
                 (empty? arguments))
        (signal (make <error> message:
                      (concatenate macro-name ": "
                                   "method has no arguments"))))
      (bind ((simplified-arguments (simplify-arguments arguments))
             (method-definition
              (macroexpand-all
               (concatenate `(method ,simplified-arguments)
                            body)
               env)))
        (when record?
          (set! (get env "module" "functions"
                     (symbol-name identifier))
                method-definition))
        ;; result
        `(define ,identifier
           ,(concatenate
             `(,(symbol definer-name)
               (%native-name ,(symbol-name identifier))
               ,method-definition
               ,setter?)
             (if type/existing?
                 `(,(bind ((head (first arguments)))
                      (if (and (instance? head <array>)
                               (> (size head) 1))
                          (second head)
                          (symbol "<object>")))
                   ,identifier)
                 [])))))))

(for-each ((arguments [["define-function" "%make-function"
                        type/existing?: #f
                        record?: #t]
                       ["define-method" "%make-method"
                        type/existing?: #t]]))
          ()
  (set! (get *core-macros* (first arguments))
        (apply make-function-definer arguments)))


(define-core-macro define-generic (_ identifier arguments)
  `(define ,identifier
     (%make-generic
      (%native-name ,(symbol-name identifier)))))

(define-core-macro define-class (_ identifier superclass #rest properties)
  (bind ((object `(%object)))
    (for-each ((property properties))
              ()
      (if (instance? property <array>)
          (begin
           (push-last object (symbol-name (first property)))
           (push-last object `(method ()
                                ,(second property))))
          (begin
           (push-last object (symbol-name property))
           (push-last object #f))))
    `(define ,identifier
       (%make-class
        ,(unless (empty? superclass)
           (first superclass))
        ,object))))

(define-function get-import-module-name/options (import)
  [;; module-name
   (symbol-name
    (if (instance? import <array>)
        (first import)
        import))
   ;; options
   (if (instance? import <array>)
       (rest import)
       [])])


;; TODO: identifiers: support setter identifiers
(define-core-macro define-module (env _ #key (import []) (export [])
                                             (compile-time-import [])
                                             (inline []))
  ;; exports
  (set! (get env "module" "exports")
        (map identifier-name export))
  ;; compile-time imports
  (do (method (import)
        (destructuring-bind (module-name options)
            (get-import-module-name/options import)
          (apply compile-time-import-module
                 env module-name options)))
      compile-time-import)
  ;; inline
  (set! (get env "module" "inline")
        (map identifier-name inline))
  ;; imports
  (maybe-begin
   (map (method (import)
          (destructuring-bind (module-name options)
              (get-import-module-name/options import)
            (apply import-module (get env "module")
                   module-name options)
            (make-import-definition module-name env)))
        import)))

;; NOTE: requires module has been imported
(define-function make-import-definition (module-name env)
  (bind ((identifier (generate-symbol)))
    (set! (get env "import-identifiers" module-name)
          identifier)
    `(define ,identifier
       ((%native "require") ,module-name))))

(define-core-macro define-macro (env identifier arguments #rest body)
  `(begin
    ,(concatenate
      `(define-function ,identifier
         ;; TODO: properly inject environment
         ,(concatenate `(,(generate-symbol))
                       arguments))
      body)
    (set! (%get-property ,identifier "%macro?") #t)))

(define-core-macro define-symbol-macro (env identifier arguments #rest body)
  `(begin
    ;; ignore arguments
    ,(concatenate `(define-function ,identifier ())
                  body)
    (set! (%get-property ,identifier "%symbol-macro?") #t)))


;; TODO: inline make-object
;;       (initialize with string keys, evaluate and set rest)


(define-core-macro handler-case (_ body #rest cases)
  (bind ((condition-var (generate-symbol)))
    `(%try ,body ,condition-var
           ,(concatenate
             `(cond)
             (map (method (case)
                    (destructuring-bind ((type #key condition) #rest body) case
                      (concatenate `((instance? ,condition-var ,type))
                                   (if condition
                                       `(,(concatenate
                                           `(bind ((,condition ,condition-var)))
                                           body))
                                       body))))
                  cases)))))

;;;; lift defines

;; replace defines with top-level %defines
;; and local assignments

(define-function lift-defines (exp env)
  (lift-define exp env identity))

(define-function lift-define (exp env k)
  (if (expression? exp)
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-define
            value env
            (method (lvalue env)
              (lift-define
               body env
               (method (lbody env)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    env)))))))
        (("%try")
         (destructuring-bind (m e1 v e2) exp
           (lift-define*
            [e1 e2] env
            (method (le* env)
              (destructuring-bind (le1 le2) le*
                (k `(,m ,le1 ,v ,le2)
                   env))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-define
            e2 env
            (method (le2 env)
              (k `(,m ,e1 ,le2)
                 env)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-define*
            e* env
            (method (le* env)
              (k (concatenate [m] le*)
                 env)))))
        (("define")
         (destructuring-bind (_ var value export?) exp
           (bind ((name (symbol-name var)))
             (if (has? (get env "defined?") name)
                 (k `(%set ,var ,value)
                    env)
                 (begin
                  (set! (get env "defined?" name) #t)
                  `(%begin
                    (%define ,var)
                    ,(k `(%set ,var ,value)
                        env)))))))
        (else:
         (lift-define** exp env k)))
      (k exp env)))

(define-function lift-define* (exp* env k)
  (if (empty? exp*)
      (k [] env)
      (lift-define** exp* env k)))

(define-function lift-define** (exp env k)
  (lift-define
   (first exp) env
   (method (t env)
     (lift-define*
      (rest exp) env
      (method (t* env)
        (k (concatenate [t] t*)
           env))))))



;;;; symbol macros

;; utilities

(define *core-symbol-macros*
  (make-object))

;; definitions

(define-core-symbol-macro next-method (_)
  `(%next-method %this-method))

;;;; macro expansion

(define-function find-macro-definition (form env)
  ;; TODO: deep-get
  (select form instance?
    ((<array>)
     (when (empty? form)
       (signal "Empty form"))
     (bind ((name (symbol-name (first form))))
       (unless (get env "bound?" name)
         (%get-property env "macros" name))))
    ((<symbol>)
     (bind ((name (symbol-name form)))
       (unless (get env "bound?" name)
         (%get-property env "symbol-macros" name))))))

(define-function macroexpand-1 (form env)
  (if-bind (macro (find-macro-definition form env))
    (apply macro env (if (instance? form <array>)
                         (rest form)
                         form))
    form))

(define-function macroexpand (form env)
  (bind ((done? #f))
    (until done?
      (bind ((expanded (macroexpand-1 form env)))
        (set! done? (== expanded form))
        (set! form expanded)))
    form))

(define-function macroexpand-all (form env)
  (select form instance?
    ((<array>)
     (if (find-macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         (if-bind (expander (find-special-form form env))
           (apply expander env (rest form))
           (map (rcurry macroexpand-all env)
                form))))
    ((<symbol>)
     (if (find-macro-definition form env)
         (macroexpand-all (macroexpand form env) env)
         form))
    (else: form)))



;;;; define free variables

(define-function find-module/import-name (definition-name env)
  (any? (method (import)
          (destructuring-bind (module names) import
            (any? (method (name)
                    (destructuring-bind (import-name new-name)
                        (if (instance? name <array>)
                            name
                            [name name])
                      (when (== definition-name
                                new-name)
                        [module import-name])))
                  names)))
        (get env "module" "imports")))

(define-function find-import-identifier (module env)
  (get env "import-identifiers"
       (get module "name")))

(define-function define-free-variables (exp env)
  (bind ((variables
          (set-subtract!
           (set-subtract!
            (find-free-variables exp)
            (as-set (map symbol
                         (object-properties (get env "defined?")))))
           *defined?*)))
    (if (empty? variables)
        exp
        (concatenate
         `(%begin)
         (map (method (variable)
                (bind ((name (symbol-name variable)))
                  (set! (get env "defined?" name) #t)
                  (maybe-begin
                   (concatenate
                    `((%define ,variable))
                    ;; imported?
                    (bind ((module/import-name (find-module/import-name name env)))
                      (if module/import-name
                          (destructuring-bind (module import-name) module/import-name
                            (bind ((import-identifier (find-import-identifier module env)))
                              `((%set ,variable (%get-property ,import-identifier ,import-name)))))
                          []))))))
              variables)
         [exp]))))


(define-function define-free-variables2 (exp env)
  (bind ((free (set-subtract! (find-free-variables exp)
                              *defined?*))
         (variables (choose
                     (method (variable)
                       (not (has? (get env "definition-names")
                                  (symbol-name variable))))
                     free)))
    (if (empty? variables)
        exp
        (concatenate
         `(%begin)
         (map (method (variable)
                (bind (;; TODO: old name?
                       (name (symbol-name variable)))
                  ;; TODO: use "defined-after-inline" instead and subtract above?
                  (set! (get env "defined?" name) #t)
                  (maybe-begin
                   (concatenate
                    `((%define ,variable))
                    ;; imported?
                    (bind ((module/import-name (find-module/import-name name env)))
                      (if module/import-name
                          (destructuring-bind (module import-name) module/import-name
                            (bind ((old-import-identifier (find-import-identifier module env))
                                   (import-identifier (get env "new-identifiers"
                                                           (symbol-name old-import-identifier))))
                              `((%set ,variable (%get-property ,import-identifier ,import-name)))))
                          []))))))
              variables)
         [exp]))))

(define-function find-free-variables (exp)
  (cond
   ((and (instance? exp <array>)
         (not (empty? exp)))
    (bind ((head (first exp))
           (name (and (instance? head <symbol>)
                      (symbol-name head))))
      (select name ==
        (("%method")
         (destructuring-bind (_ arguments body) exp
           (set-subtract!
            (find-free-variables body)
            (as-set arguments))))
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           ;; TODO: make binding available inside value?
           ;; (if so, also change alpha-convert,
           ;;  %bind special form)
           (set-union!
            (set-subtract!
             (find-free-variables body)
             (as-set [var]))
            (find-free-variables value))))
        (("%begin")
         ;; %define will only appear in %begin,
         ;; see previous pass lift-defines
         (bind ((definitions []))
           (set-subtract!
            (as-set
             (reduce (method (result e)
                       (concatenate
                        result
                        (if (and (expression? e)
                                 (== (first e)
                                     (symbol "%define")))
                            (begin
                             (push-last definitions (second e))
                             [])
                            (find-free-variables e))))
                     [] (rest exp)))
            (as-set definitions))))
        (("%try")
         (destructuring-bind (_ e1 v e2) exp
           (set-subtract!
            (set-union!
             (as-set (find-free-variables e1))
             (as-set (find-free-variables e2)))
            (as-set [v]))))
        (("%set" "%if" "%while"
          "%array" "%object" "%infix"
          "%get-property" "%native-call"
          "%plus" "%minus" "%times" "%divide")
         (as-set (reduce concatenate []
                         (map find-free-variables
                              (rest exp)))))
        (("%native" "%native-name" "%define")
         (as-set []))
        (else:
         (reduce1 set-union!
                  (map find-free-variables
                       exp))))))
   ((instance? exp <symbol>)
    (as-set [exp]))
   (else:
    (as-set []))))



;;; inlining

(define-function inline (form env)
  (if (and (instance? form <array>)
           (not (empty? form)))
      (if (instance? (first form) <symbol>)
          (select (symbol-name (first form)) ==
            ;; inline only last
            (("%method" "%set")
             (set! (last form)
                   (inline (last form) env))
             form)
            (("%bind")
             (destructuring-bind (_ binding body) form
               (set! (second binding)
                     (inline (second binding) env))
               (set! (last form)
                     (inline body env))
               form))
            (("%try")
             (destructuring-bind (_ body var catch) form
               (set! (second form)
                     (inline body env))
               (set! (last form)
                     (inline catch env))
               form))
            ;; inline all arguments
            (("%begin" "%if" "%while" "%array" "%object"
              "%get-property" "%native-call" "%infix"
              "%plus" "%minus" "%times" "%divide")
             (concatenate [(first form)]
                          (map (rcurry inline env)
                               (rest form))))
            ;; no inlining
            (("%native" "%native-name" "%define")
             form)
            ;; application of function with name
            (else:
             (bind ((name (symbol-name (first form)))
                    (definition-name (or (get env "definition-names" name)
                                         name))
                    (definition
                      ;; local definition?
                      (or (when (inline? (get env "module")
                                         definition-name)
                            (get env "module" "functions"
                                 definition-name))
                          ;; imported definition?
                          (if-bind (module/import-name
                                    (find-module/import-name
                                     definition-name env))
                            (destructuring-bind (module import-name)
                                module/import-name
                              (when (inline? module import-name)
                                (get module "functions"
                                     import-name)))))))
               (if definition
                   (inline-definition definition (rest form) env)
                   ;; normal call
                   (map (rcurry inline env)
                        form)))))
          ;; application of expression, can't be inlined
          (map (rcurry inline env)
               form))
      ;; not an array
      form))

(define-function inline? (module name)
  (any? (curry == name)
        (get module "inline")))

(define-function inline-definition (definition values env)
  ;; TODO: move preparation to method definition?
  ;; inlines definition itself and inlines values before., e.g. (not (not ...))
  (destructuring-bind (_ arguments body) definition
    ;; TODO: rest and keyword parameters
    ;; rebind arguments, so values are only evaluated once
    (bind ((body (reduce (method (body argument)
                           `(%bind (,argument ,argument)
                                   ,body))
                         body
                         (reverse arguments)))
           (inlined (inline body env))
           (prepared (alpha-convert inlined env)))
      ;; create initial bindings
      (dotimes (i (size arguments))
        (bind ((argument (element arguments i))
               (value (element values i)))
          (destructuring-bind (module-name name)
              (get-module-name/name argument)
            (ensure-naming-structure env module-name name)
            (push (get env "identifiers" module-name name)
                  (if value
                      (inline value env)
                      `(%native "undefined"))))))
      ;; rename
      (bind ((result (alpha-convert body env)))
        (restore-identifiers arguments env)
        result))))


;;;; symbol lifting

(define-function lift-symbols (exp env)
  (lift-symbol exp env identity))

(define-function lift-symbol (exp env k)
  (if (and (instance? exp <array>)
           (not (empty? exp)))
      (select (symbol-name (first exp)) ==
        (("%bind")
         (destructuring-bind (_ (var value) body) exp
           (lift-symbol
            value env
            (method (lvalue env)
              (lift-symbol
               body env
               (method (lbody env)
                 (k `(%bind (,var ,lvalue)
                       ,lbody)
                    env)))))))
        (("%method" "%set")
         (destructuring-bind (m e1 e2) exp
           (lift-symbol
            e2 env
            (method (le2 env)
              (k `(,m ,e1 ,le2)
                 env)))))
        (("%begin" "%if" "%while")
         (destructuring-bind (m #rest e*) exp
           (lift-symbol*
            e* env
            (method (le* env)
              (k (concatenate [m] le*)
                 env)))))
        (("%try")
         (destructuring-bind (_ e1 v e2) exp
           (lift-symbol*
            [e1 e2] env
            (method (le* env)
              (destructuring-bind (le1 le2) le*
                (k `(%try ,le1 ,v ,le2)
                   env))))))
        ;; TODO: fix, already renamed
        (("symbol")
         (destructuring-bind (_ name) exp
           (lift-value
            name exp "symbol" env k)))
        (else:
         (lift-symbol** exp env k)))
      (select exp instance?
        ((<keyword>)
         (lift-value
          (symbol-name exp) exp "keyword" env k))
        ((<hash-symbol>)
         (lift-value
          (symbol-name exp) exp "hash" env k))
        (else:
         (k exp env)))))

(define-function lift-value (name value type env k)
  (if-bind (t (get env "lifted" type name))
    (k t env)
    (bind ((t (set! (get env "lifted" type name)
                    (generate-symbol))))
      `(%bind (,t ,value)
         ,(k t env)))))

(define-function lift-symbol* (exp* env k)
  (if (empty? exp*)
      (k [] env)
      (lift-symbol** exp* env k)))

(define-function lift-symbol** (exp env k)
  (lift-symbol
   (first exp) env
   (method (t env)
     (lift-symbol*
      (rest exp) env
      (method (t* env)
        (k (concatenate [t] t*)
           env))))))




;;;;

(define-function read-program (source)
  (read (make <string-stream>
              string: (concatenate "(" source "\n)"))))

(define-function compile-expression (exp env)
  (reduce (method (result name/fn)
            (destructuring-bind (name fn) name/fn
;;              (format-out "### %s:\n" name)
              (bind ((result (fn result)))
;;                (format-out "%=\n" result)
                result)))
          exp
          [["source" identity]
           ["macroexpanded"
            (rcurry macroexpand-all env)]
           ["lifted defines"
            (rcurry lift-defines env)]
           ["defined free variables"
            (rcurry define-free-variables env)]
           ["alpha-converted"
            (rcurry alpha-convert env)]
           ["inline"
            (rcurry inline env)]
           ["defined free variables after inline"
            (rcurry define-free-variables2 env)]
           ["ANF"
            normalize-term]
           ["lifted symbols"
            (rcurry lift-symbols env)]
           ["statements"
            (rcurry transform-statements! env)]
           ["flattened"
            flatten-statements!]
           ["compiled"
            (rcurry compile-js env)]]))

;;;;

(define-function executable-path (module-name)
  (resolve-path "build" (concatenate module-name ".js")))

(define-function module-path (base-path module-name)
  (resolve-path base-path
                (concatenate module-name ".rm")))

(define-function source-path (module-name)
  (resolve-path "src" (concatenate module-name ".ralph")))

(define-function recompile? (module-name)
  (and (not (get *modules* module-name "native?"))
       (bind ((path (executable-path module-name)))
         (or (not (file-exists? path))
             (bind ((path2 (source-path module-name)))
               (< (get (file-properties path) "modification-date")
                  (get (file-properties path2) "modification-date")))))))

(define-function compile-time-import-module (env module-name #key options)
  (destructuring-bind (macros symbol-macros)
      (if (== module-name "ralph/core")
          [*core-macros* *core-symbol-macros*]
          (begin
           ;; ensure latest version is compiled
           (compile-module module-name)
           (bind ((definitions (%native-call "require" module-name))
                  (macros (make-plain-object))
                  (symbol-macros (make-plain-object)))
             (do (method (name)
                   (bind ((definition (get definitions name)))
                     (cond
                      ((get definition "%macro?")
                       (set! (get macros name)
                             definition))
                      ((get definition "%symbol-macro?")
                       (set! (get symbol-macros name)
                             definition)))))
                 (apply process-names (object-properties definitions)
                        options))
             [macros symbol-macros])))
    (chain-object (get env "macros")
                  macros)
    (chain-object (get env "symbol-macros")
                  symbol-macros)))


(define-function process-names (all #key only exclude prefix rename)
  (bind-methods ((resolve (exp)
                   (if (instance? exp <string>)
                       exp
                       (identifier-name exp))))
    (bind ((names (as-set (if (instance? only <array>)
                              (map resolve only)
                              all)))
           (renamings (as-object (map resolve
                                      (or rename [])))))
      ;; remove all from exclude
      (do (curry remove! names)
          (map resolve exclude))
      ;; rename overwrites only
      (set-union! names
                  (object-properties renamings))
      ;; prefix or rename
      (map (method (name)
             (if-bind (renaming (get renamings name))
               [name renaming]
               (if (instance? prefix <string>)
                   [name (concatenate prefix name)]
                   name)))
           names))))

(define-function import-module (module module-name #rest options)
  ;; TODO: open database first
  (if-bind (other-module (find-module module-name))
    (begin
     (push (get module "imports")
           [other-module
            (apply process-names (get other-module "exports")
                   options)])
     (push (get module "dependencies")
           module-name)
     other-module)
    (signal (concatenate "unable to import module '"
                         module-name "'"))))

(define-function find-module (module-name)
  (or (compile-module module-name)
      (get *modules* module-name)
      (read-module "build" module-name)
      (read-module "src" module-name)))

(define-function read-module (base-path module-name)
  (bind ((path (module-path base-path module-name)))
    (when (file-exists? path)
      (apply (curry make <module> name:)
             (read (make <string-stream>
                         string: (read-file path)))))))

(define-function compile-module (module-name)
  ;; module in source directory? (native)
  (unless (has? *modules* module-name)
    (if-bind (module (read-module "src" module-name))
      (set! (get *modules* module-name)
            module)))
  (when (recompile? module-name)
    (unless (file-exists? (source-path module-name))
      (signal (concatenate "unable to compile module '"
                           module-name "'")))
    (bind ((module (make <module> name: module-name))
           (env (make <environment> module: module))
           (source (read-file (source-path module-name)))
           (program (read-program source))
           (result ""))
      (set! (get *modules* module-name)
            module)
      (compile-time-import-module env "ralph/core")
      ;; special case core?
      (unless (== module-name "ralph/core")
        ;; implicitly import and load core
        (import-module module "ralph/core")
        (push program
              (make-import-definition "ralph/core" env)))
      ;; compile
      (do (method (expression)
            (bind ((code (compile-expression expression env)))
              (set! result
                    (concatenate result code "\n"))))
          program)
      ;; write executable
      (write-file (executable-path module-name)
                  result)
      ;; write module
      (write-file (module-path "build" module-name)
                  ;; ignore imports for now
                  (description [module-name
                                exports: (get module "exports")
                                inline: (get module "inline")
                                dependencies: (get module "dependencies")]))
      module)))


;; required loading order
(define-function analyze-dependencies (module-name)
  (if-bind (module (find-module module-name))
    (begin
     (set! (get *modules* module-name)
           module)
     (bind-properties (dependencies) module
       (bind ((result (copy-sequence dependencies)))
         (do (method (dependency)
               (do (method (sub-dependency)
                     (when (member? sub-dependency result)
                       (remove! result sub-dependency))
                     (push result sub-dependency))
                   (analyze-dependencies dependency)))
             dependencies)
         result)))
    (signal (concatenate "unable to find-module '"
                         module-name "'"))))
