
(define-module dylan
  export: (%define
	   %export
	   %define-getter
	   %define-setter
	   setter
	   %interned-keywords
	   (js:identifier "_k")
	   <object>
	   <non-local-exit>
	   values))

;;;; define

(%%define %define
  (%function js:null (name value)
    (begin
      (js:set (js:get-property *module* name) value)
      (js:if (js:>= ((js:get-property *module* "%exports" "indexOf") name) 0)
             (%export name value)
	     #f))))

(define %export
  (%function js:null (name value)
     (js:set (js:get-property exports name) value)))

;; manual export necessary
(%export (js:escape %define) %define)

(define js:has-property?
  (%function js:null (object name)
    (js:return ((js:get-property object "hasOwnProperty") name))))

(define %get-definition
  (%function js:null (name)
    (js:return (and (js:has-property? *module* name)
		    (js:get-property *module* name)))))


;;;; boolean primitives

(define js:constructor?
  (%function js:null (object constructor)
    (js:return (js:=== (js:get-property object "constructor")
		       constructor))))

(define %true?
  (%function js:null (value)
    (js:return
     (js:and (js:not (js:=== value js:null))
	     (js:not (js:=== value js:undefined))
	     (js:or (js:constructor? value (js:identifier "Number"))
		    (js:constructor? value (js:identifier "String"))
		    (js:not (js:not value)))))))

(define %not
  (%function js:null (value)
    (js:return (js:not (%true? value)))))

;;;; getter

(define %define-getter
  (%function js:null (name function)
    (bind ((getter (%get-definition name))
	   (setter (and getter
			(js:has-property? getter "%setter")
			(js:get-property getter "%setter"))))
      (%define name function)
      (when setter
	(js:set (js:get-property function "%setter") setter)))))

;;;; setter

(define %define-setter
  (%function js:null (name function)
    (begin
      (when (%not (%get-definition name))
	(%define name (js:new (js:identifier "Function"))))
      (js:set (js:get-property (%get-definition name) "%setter") function))))

(define-function setter (function)
  (when (js:has-property? function "%setter")
    (js:get-property function "%setter")))

;;;; keywords

(define %interned-keywords (js:new (js:identifier "Object")))

(%define "_k"
  (%function js:null (name)
    (begin
      (js:var keyword js:null)
      (js:return
       (if (js:has-property? %interned-keywords name)
	   (js:get-property %interned-keywords name)
	   (begin
	    (js:set keyword (js:new <keyword>))
	    (js:set (js:get-property keyword "%name") name)
	    (js:set (js:get-property %interned-keywords name) keyword)
	    keyword))))))

;;;; non-local exit

;; TODO: replace with proper define-class with slot
;; (superclass: condition?)
(define <non-local-exit>
  (%function js:null (name values)
    (begin
     (js:set (js:get-property js:this "name") name)
     (js:set (js:get-property js:this "values") values)
     (js:return js:this))))

;; TODO: replace with proper initialization method
(define-function %make-non-local-exit-function (name)
  (method (#rest values)
    ;; TODO: use signal and proper make call
    (js:throw (js:new <non-local-exit>
		      name values))))

;;;; multiple return values

(define-function values (#rest values)
  (when (%empty? values)
    (js:set values (%array #f)))
  (when (js:> (%size values) 1)
    ;; function who called 'values'
    (js:var callee (js:get-property js:arguments "callee" "caller"))
    ;; skip 'scope functions'
    (js:var caller
	    (for ((caller callee (js:get-property caller "caller"))
		  (caller2 #f caller))
		 ((or (%not caller)
		      (and (js:has-property? caller "%top")
			   (%not (js:has-property? caller "%skip"))))
		  caller2)))
    ;; set values on the function
    ;; that called the function which returns values
    (js:set (js:get-property caller "otherValues")
	    ((js:get-property values "slice") 1)))
  (js:get-property values 0))

;;;; JS utilities

(define-function js:length (array)
  (js:get-property array "length"))

(define-function js:for-each (function objects)
  ((js:get-property objects "forEach") function))

(define-function js:slice (array start end)
  ((js:get-property array "slice")
   (or start 0)
   (or end (js:length array))))

(define-function js:property-sequence (object)
  (bind ((keys (js:new (js:identifier "Array"))))
    (js:for-in (key object)
      ((js:get-property keys "push") key))
    keys))

(define-function js:argument-list (arguments skip)
  ((js:get-property "Array" "prototype"
		    "slice" "call")
   arguments skip))

(define-function js:make-object ()
  (js:new (js:identifier "Object")))

;;;; collection primitives
;; (only work on JavaScript arrays)

(define-function %array (#rest elements)
  elements)

(define-function %push (array new-value)
  ((js:get-property array "unshift") new-value)
  array)

(define-function %push-last (array new-value)
  ((js:get-property array "push") new-value)
  array)

(define-function %pop (array)
  ((js:get-property array "shift"))
  array)

(define-function %pop-last (array)
  ((js:get-property array "pop"))
  array)

(define-function %add! (array new-value)
  (%push array new-value))

(define-function %copy-sequence (array #key (start 0) (end (%size array)))
  (js:slice array start end))

(define-function %concatenate (first-array #rest more-arrays)
  ((js:get-property "Array" "prototype" "concat" "apply")
   first-array more-arrays))

(define-function %reverse! (array)
  ((js:get-property array "reverse")))

(define-function %reverse (array)
  ((js:get-property (%copy-sequence array) "reverse")))

(define-function %sort! (array #key (test <))
  ((js:get-property array "sort") test))

(define-function %sort (array #key (test <))
  (%sort! (%copy-sequence array) test: test))

(define-function %element (array key #key default)
  (or (js:get-property array key) default))

(define-function (setter %element) (array key new-value)
  (js:set (js:get-property array key) new-value))

(define-function %key-sequence (array)
  (js:property-sequence array))

(define-function %size (array)
  (js:length array))

(define-function %empty? (array)
  (js:== (%size array) 0))

(define-function %do (function array)
  (js:for-each function array))

(define-function %map (function array)
  ((js:get-property array "map") function))

(define-function %reduce1 (function array)
  ((js:get-property array "reduce") function))

(define-function %reduce (function initial-value array)
  (%reduce1 function
	    (%concatenate (%array initial-value)
			  array)))

(define-function %every? (function array)
  ((js:get-property array "every")
   (method (element)
     (%true? (function element)))))

(define-function %choose (function array)
  ((js:get-property array "filter")
   (method (element)
     (%true? (function element)))))

(define %not-found (js:make-object))

(define-function %find-key (array predicate #key (skip 0) failure)
  (bind ((keys (%choose (method (index)
			  (%true? (predicate (%element array index))))
			(%key-sequence array))))
    (or (%element keys skip) failure)))

(define-function %any? (function array)
  (block (return)
    (js:for-in (i array)
      (js:var result (function (%element array i)))
      (when result
	(return result)))
    #f))

(define-function %member? (value array)
  (%true? (%any? (method (other-value)
		   (%== value other-value))
		 array)))

(define-function %replace-subsequence (target-array insert-array
				       #key (start 0) (end (%size target-array)))
  (%concatenate (%copy-sequence target-array end: start)
		insert-array
		(%copy-sequence target-array start: end)))

(define-function %first (array)
  (%element array 0))

(define-function %second (array)
  (%element array 1))

(define-function %third (array)
  (%element array 2))

(define-function %last (array)
  (%element array (js:- (%size array) 1)))

(define-function %rest (array)
  (js:slice array 1))

(define-function %but-last (array)
  (js:slice array 0 -1))

(define-function %choose-by (predicate test-array value-array)
  (bind ((test-keys (%choose (method (test-key)
			       (predicate (%element test-array test-key)))
			     (%key-sequence test-array))))
    (%map (%curry %element value-array) test-keys)))

;;;; string primitives

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable

(define-function %as-uppercase (string)
  ((js:get-property string "toUpperCase")))

(define-function %as-lowercase (string)
  ((js:get-property string "toLowerCase")))

;;;; functional primitives

(define-function %apply (function #rest arguments)
  (js:set (js:get-property %apply "%skip") #t)
  ((js:get-property function "apply") js:null
   (if (js:> (%size arguments) 1)
       (%concatenate (%but-last arguments)
		     (%last arguments))
       (%first arguments))))

(define-function %curry (function #rest curried-args)
  (method (#rest args)
    (%apply function (%concatenate curried-args args))))

(define-function %rcurry (function #rest curried-args)
  (method (#rest args)
    (%apply function (%concatenate args curried-args))))

(define-function %always (value)
  (method (#rest args)
    value))

;;;; arithmetic primitives
;; (only work on JavaScript numbers)

(define-function %+ (number #rest more-numbers)
  (%reduce (method (number1 number2)
	     (js:+ number1 number2))
	   number more-numbers))

(define-function %- (number #rest more-numbers)
  (if (%empty? more-numbers)
      (js:negative number)
      (%reduce (method (number1 number2)
	        (js:- number1 number2))
	      number more-numbers)))

;;;; comparison primitives

(define-function %binary= (object1 object2)
  ;; TODO:
  (js:and (js:=== (%object-class object1)
		  (%object-class object2))
	  (js:== object1 object2)))

(define-function %binary< (object1 object2)
  ;; TODO:
  (js:< object1 object2))

(define-function %compare (function object1 object2 more-objects)
  (block (return)
    (%reduce1 (method (object1 object2)
	        (if (function object1 object2)
		    object2
		    (return #f)))
	      (%concatenate (%array object1 object2)
			    more-objects))
    #t))

(define-function %= (object1 object2 #rest more-objects)
  (%compare %binary= object1 object2 more-objects))

(define-function %== (object1 object2 #rest more-objects)
  (%compare (method (object1 object2)
	      (js:=== object1 object2))
	    object1 object2 more-objects))

(define-function %< (object1 object2 #rest more-objects)
  (%compare %binary< object1 object2 more-objects))

(define-function %> (object1 object2 #rest more-objects)
  (%compare (method (object1 object2)
	      (%not (or (%binary< object1 object2)
			(%binary= object1 object2))))
	    object1 object2 more-objects))

(define-function %<= (object1 object2 #rest more-objects)
  (%compare (method (object1 object2)
	      (or (%binary< object1 object2)
		  (%binary= object1 object2)))
	    object1 object2 more-objects))

(define-function %>= (object1 object2 #rest more-objects)
  (%compare (method (object1 object2)
	      (%not (%binary< object1 object2)))
	    object1 object2 more-objects))

;;;; reflection primitives

(define-function %object-class (object)
  ;; Object.getPrototypeOf on primitives only works in FireFox:
  ;; ((js:get-property "Object" "getPrototypeOf") object))
  (bind ((type (js:get-property object "constructor")))
    (if (js:has-property? type "%mapped-type")
	(js:get-property type "%mapped-type")
	type)))

(define-function %check-type (value type)
  (when (%not (%instance? value type))
    (error "check-type failed")))

(define-function %instance? (object type)
  (js:var actual-type
	  (if (js:has-property? type "%internal-type")
	      (js:get-property type "%internal-type")
	      type))
  (js:or
   ;; primitive
   (js:constructor? object actual-type)
   ;; object
   ((js:get-property actual-type "prototype"
		     "isPrototypeOf")
    object)))
;; TODO:
;;   (subclass? (object-class object) type)


;;;; object

(define-function direct-superclasses ((class <class>))
  (js:get-property class "class-direct-superclasses"))

(define-function subclass? (class1 class2)
  (or (%== class1 class2)
      (block (return)
        (for ((classes-left
	       (direct-superclasses class1)
	       (%concatenate (direct-superclasses (%first classes-left))
			     (%rest classes-left))))
	     ((%empty? classes-left) #f)
	  (when (%== class2 (%first classes-left))
	    (return #t))))))

(define-function compute-class-linearization ((c <class>))
  (bind-methods ((merge-lists (reversed-partial-result
			       remaining-inputs)
		   (if (%every? %empty? remaining-inputs)
		       (%reverse! reversed-partial-result)
		       (bind-methods ((candidate ((c <class>))
                                        (bind-methods ((rest? (l)
                                                         (%member? c (%rest l))))
					  (unless (%any? rest? remaining-inputs)
					    c)))
				      (candidate-at-head (l)
                                        (unless (%empty? l)
					  (candidate (%first l)))))
                         (bind ((next (%any? candidate-at-head remaining-inputs)))
                           (if next
                               (bind-methods ((remove-next ((l <list>))
                                                (if (%== (%first l) next)
						    (%rest l)
                                                    l)))
                                 (merge-lists (%add! reversed-partial-result next)
					      (%map remove-next remaining-inputs)))
			       (error "Inconsistent precedence graph")))))))
    (bind ((c-direct-superclasses (direct-superclasses c)))
      (merge-lists (%array c)
		   (%concatenate (%map compute-class-linearization c-direct-superclasses)
				 (%array c-direct-superclasses))))))


(define-function %make-object ()
  (js:var object (js:make-object))
;;  (js:set (js:get-property object "%class") <object>)
  object)

(define-function %make-class (name direct-superclasses)
  (js:var class (js:make-object))
;;  (js:set (js:get-property object "%class") <class>)
;; TODO: remove
  (js:set (js:get-property class "toString")
	  (method ()
	    (js:+ "{class " name "}")))
  (js:set (js:get-property class "class-name") name)
  (js:set (js:get-property class "class-direct-superclasses")
	  direct-superclasses)
  class)

(%define-class <object> ())
(%define-class <type> (<object>))
(%define-class <class> (<type>))
(%define-class <singleton> (<type>))
(%define-class <function> (<object>))
(%define-class <number> (<object>))
(%define-class <boolean> (<object>))
(%define-class <collection> (<object>))
(%define-class <keyword> (<object>))
(%define-class <table> (<collection>))
(%define-class <sequence> (<collection>))
(%define-class <string> (<sequence>))
(%define-class <array> (<sequence>))
(%define-class <vector> (<array>))

(define-function %map-types (source-type target-type)
  (js:set (js:get-property source-type "%internal-type")
	  target-type)
  (js:set (js:get-property target-type "%mapped-type")
	  source-type))

(%map-types <vector> (js:identifier "Array"))
(%map-types <object> (js:identifier "Object"))
(%map-types <string> (js:identifier "String"))
(%map-types <number> (js:identifier "Number"))
(%map-types <boolean> (js:identifier "Boolean"))
