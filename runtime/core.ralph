
(define-module dylan
  export: (%define %export %define-getter %define-setter
	   (js:identifier "_k") (js:identifier "_key") (js:identifier "_rest")
	   keyword keyword? symbol
           <object> <string> <number> <boolean> <array> <symbol>
           not true?
           *environment*
           %make-protocol %make-dispatcher
           <non-local-exit> <error>
           %non-local-exit? %make-non-local-exit-function
           get %set
           make initialize type instance?
           as-string as-array
           apply reduce reduce1 map
           any? every? member? choose-by find-key
           complement curry rcurry
           string-position
           as-lowercase as-uppercase
           make-array element first second third last rest
           size empty? but-last copy-sequence replace-subsequence
           reverse reverse! sort sort!
           push push-last pop pop-last
           = == > < >= <=
           + - * /
           inc dec
           description
           identity))

;;;; define

(js:function %define (module exports name value)
  (begin
    (set! (js:get-property module name) value)
    (js:if (js:>= ((js:get-property module "%exports" "indexOf") name) 0)
           (%export exports name value)
           #f)))

(define %export
  (js:function js:null (exports name value)
     (set! (js:get-property exports name) value)))

;; manual export necessary
(%export exports (js:escape %define) %define)

(define %has-property?
  (js:function js:null (object name)
    (js:return ((js:get-property object "hasOwnProperty") name))))

(define %get-property
  (js:function js:null (object name)
    (js:return (when (and object (%has-property? object name))
                 (js:get-property object name)))))

(define %get-definition
  (js:function js:null (module name)
    (js:return (js:and (js:defined (js:get-property module name))
		       (js:get-property module name)))))

(define %has-constructor?
  (js:function js:null (object constructor)
    (js:return (js:=== (js:get-property object "constructor")
                       constructor))))

(define %make-object
  (js:function js:null ()
    (js:return (js:new (js:identifier "Object")))))

(define %make-function
  (js:function js:null (name function)
    (js:return (js:new (js:identifier "Function")))))

;;;; boolean primitives

(define true?
  (js:function js:null (value)
    (js:return
     (js:and (js:not (js:=== value js:null))
             (js:not (js:=== value js:undefined))
             (js:or (%has-constructor? value (js:identifier "Number"))
                    (%has-constructor? value (js:identifier "String"))
                    (js:not (js:not value)))))))

(define not
  (js:function js:null (value)
    (js:return (js:not (true? value)))))

;;;; getter

(define %define-getter
  (js:function js:null (module exports name function type-name)
    (bind ((getter (%get-definition module name))
           (protocol (when getter
                       (%get-property getter "%protocol")))
           (setter (if protocol
                       (bind ((type (%actual-type
                                     (%get-definition module type-name)))
                              (prototype (js:get-property type "prototype"))
                              (getter (%get-property prototype name)))
                         (set! (js:get-property function "%type") type)
                         (set! (js:get-property prototype name) function)
                         (%get-property getter "%setter"))
                       (begin
                        (%define module exports name function)
                        (%get-property getter "%setter")))))
          (set! (js:get-property function "%name") name)
          (when setter
            (set! (js:get-property function "%setter") setter)))))

;;;; setter

(define %define-setter
  (js:function js:null (module exports name function type-name)
    (bind ((getter (%get-definition module name))
           (protocol (when getter
                       (%get-property getter "%protocol"))))
      (if protocol
          (bind ((type (%actual-type (%get-definition module type-name)))
                 (prototype (js:get-property type "prototype"))
                 (getter (or (%get-property prototype name)
                             (bind ((temp (%make-function)))
                               (set! (js:get-property prototype name)
                                     temp)
                               temp))))
            (set! (js:get-property getter "%setter") function))
          (begin
           (unless (%get-definition module name)
             (%define module exports name (%make-function)))
           (set! (js:get-property (%get-definition module name) "%setter")
                 function))))))

(define-function %set ((function <function>) #rest arguments)
  (bind ((protocol (%get-property function "%protocol"))
         (name (%get-property function "%name"))
         (getter (if protocol
                     (bind ((type (%actual-type (type (first arguments))))
                            (prototype (js:get-property type "prototype"))
                            (getter (%get-property prototype name)))
                       getter)
                     function))
         (setter (%get-property getter "%setter")))
    (apply setter arguments)))

;;;;

(define-function %describe (object)
  ((js:identifier "JSON.stringify")
   object))

(define *environment*
    (if (js:defined window)
        "browser"
        "commonjs"))

;;;; objects

(define-function make (type #rest arguments)
  (bind ((type (%actual-type type))
         (object (js:new type)))
    (apply initialize object arguments)
    object))

;;;; keywords

(define %keywords (%make-object))

(define <keyword> (%make-function))

(define-function keyword? (keyword)
  (instance? keyword <keyword>))

(%define *module* exports "_k"
  (js:function js:null (name)
    (begin
      (js:var keyword js:null)
      (js:set name ((js:get-property name "toLowerCase")
                    name))
      (js:return
       (if (%has-property? %keywords name)
           (js:get-property %keywords name)
           (begin
            (set! keyword (js:new <keyword>))
            (set! (js:get-property keyword "name") name)
            (set! (js:get-property %keywords name) keyword)
            keyword))))))

(define keyword (js:identifier "_k"))

;;;; non-local exit

;; TODO: should be a type that conforms to condition protocol

(define <non-local-exit>
  (js:function js:null (name value)
    (begin
     (set! (js:get-property js:this "name") name)
     (set! (js:get-property js:this "value") value)
     (js:return js:this))))

(define-function %non-local-exit? (condition)
  (instance? condition <non-local-exit>))

;; TODO: replace with proper initialization method
(define-function %make-non-local-exit-function (name)
  (method (value)
    ;; TODO: use signal and proper make call
    (js:throw (js:new <non-local-exit>
                      name value))))

(define-function as-array (arguments skip)
  ((js:get-property "Array" "prototype"
                    "slice" "call")
   arguments (or skip 0)))

(define-function as-string (object)
  ((js:get-property object "toString")))

(define-function as-number (object)
  ((js:identifier "Number") object))

(define-function get (object #rest keys)
  (block (return)
    (reduce (method (object key)
              (if (%has-property? object key)
                  (js:get-property object key)
                  (return #f)))
            object keys)))

(define-function (setter get) (object #rest properties/value)
  (if (js:<= (size properties/value) 2)
      (set! (js:get-property object (first properties/value))
            (second properties/value))
      (bind ((property (first properties/value))
             (object2 (if (%has-property? object property)
                          (get object property)
                          (bind ((new (%make-object)))
                            (set! (js:get-property object property) new)
                            new))))
        (apply %set get object2
               (rest properties/value)))))

(define-function size ((array <array>))
  (js:get-property array "length"))

(define-function copy-sequence ((array <array>)
                                #key (start 0) (end (size array)))
  ((js:get-property array "slice")
   (or start 0)
   (or end (size array))))

(define-function push-last ((array <array>) new-value)
  ((js:get-property array "push") new-value)
  array)

(define-function inc ((number <number>))
  (js:+ number 1))

(define-function dec ((number <number>))
  (js:- number 1))

(define-function + ((number <number>) #rest more-numbers)
  (reduce (method (number1 number2)
            (js:+ number1 number2))
          number more-numbers))

(define-function - ((number <number>) #rest more-numbers)
  (if (empty? more-numbers)
      (js:negative number)
      (reduce (method (number1 number2)
                (js:- number1 number2))
              number more-numbers)))

(define-function * ((number1 <number>) (number2 <number>)
                    #rest more-numbers)
  (reduce1 (method (number1 number2)
             (js:* number1 number2))
           (concatenate (make-array number1
                                    number2)
                        more-numbers)))

(define-function keys (object)
  (bind ((keys (js:new (js:identifier "Array"))))
    (if (instance? object (js:identifier "Array"))
        ;; TODO: replace with range
        (for ((i 0 (inc i)))
             ((>= i (size object)) keys)
          (push-last keys i))
        (begin
         (js:for-in (key object)
           (push-last keys key))
         keys))))

(define-function make-array (#rest elements)
  elements)

(define-function push ((array <array>) new-value)
  ((js:get-property array "unshift") new-value)
  array)

(define-function pop ((array <array>))
  ((js:get-property array "shift"))
  array)

(define-function pop-last ((array <array>))
  ((js:get-property array "pop"))
  array)

(define-function add! ((array <array>) new-value)
  (push array new-value))

(define-function %concat (array1 array2 )
  ((js:get-property array1 "concat") array2))

(define-function reverse! ((array <array>))
  ((js:get-property array "reverse")))

(define-function reverse ((array <array>))
  (reverse! (copy-sequence array)))

(define-function sort! ((array <array>) #key (test <))
  ((js:get-property array "sort") test))

(define-function sort ((array <array>) #key (test <))
  (sort! (copy-sequence array) test: test))

(define-function element ((array <array>) key #key default)
  (or (js:get-property array key) default))

(define-function (setter element) ((array <array>) key new-value)
  (set! (js:get-property array key) new-value))

(define-function empty? ((array <array>))
  (== (size array) 0))

;; the functions passed to map and reduce are
;; wraped in additional method, as the JS version
;; also additionally passes the index and
;; the traversed array - might clash when
;; using curry/rcurry

(define-function map ((function <function>) (array <array>))
  ((js:get-property array "map")
   (method (element)
     (function element))))

(define-function do ((function <function>) (array <array>))
  ((js:get-property array "forEach")
   (method (element)
     (function element))))

(define-function reduce1 ((function <function>) (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))))

(define-function reduce ((function <function>) initial-value (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))
   initial-value))

(define-function every? ((function <function>) (array <array>))
  ((js:get-property array "every")
   (method (element)
     (true? (function element)))))

(define-function choose ((function <function>) (array <array>))
  ((js:get-property array "filter")
   (method (element)
     (true? (function element)))))

(define %not-found (%make-object))

(define-function find-key ((array <array>) (predicate <function>)
                           #key (skip 0) failure from-end?)
  (bind ((keys (keys array))
         (satisfying-keys
          (choose (method (index)
                    (true? (predicate (element array index))))
                  (if from-end?
                      (reverse keys)
                      keys))))
    (or (element satisfying-keys skip)
        failure)))

(define-function string-position ((target-string <string>)
                                  (search-string <string>))
  (bind ((position ((js:get-property target-string "indexOf")
                    search-string)))
    (when (> position -1)
      position)))

(define-function any? ((function <function>) (array <array>))
  (block (return)
    (do (method (element)
          (bind ((result (function element)))
            (when result
              (return result))))
        array)
    #f))

(define-function member? (value (array <array>))
  (true? (any? (method (other-value)
                 (== value other-value))
               array)))

(define-function choose-by ((predicate <function>)
                            (test-array <array>)
                            (value-array <array>))
  (bind ((test-keys (choose (method (test-key)
                              (predicate (element test-array test-key)))
                            (keys test-array))))
    (map (curry element value-array)
         test-array)))

(define-function first ((array <array>))
  (element array 0))

(define-function second ((array <array>))
  (element array 1))

(define-function third ((array <array>))
  (element array 2))

(define-function last ((array <array>))
  (element array (dec (size array))))

(define-function rest ((array <array>))
  (copy-sequence array start: 1))

(define-function but-last ((array <array>) #key (n 1))
  (copy-sequence array end: (js:* n -1)))

(define-function replace-subsequence (target-array insert-array
                                      #key (start 0) (end (size target-array)))
  (concatenate (copy-sequence target-array end: start)
               insert-array
               (copy-sequence target-array start: end)))

;;;; string

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable

(define-function as-uppercase ((string <string>))
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  ((js:get-property string "toLowerCase")))

;; TODO: generic interpose, interleave
(define-function join ((array <array>) (string <string>))
  ((js:get-property array "join") string))

;;;; functional

(define-function apply ((function <function>) #rest arguments)
  ((js:get-property function "apply") js:null
   (%concat (but-last arguments)
            (last arguments))))

(define-function curry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate curried-args args))))

(define-function rcurry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate args curried-args))))

(define-function always (value)
  (method (#rest args)
    value))

(define-function complement ((function <function>))
  (method (#rest arguments)
    (not (apply function arguments))))

;;;; reflection primitives

(define-function %constructor (object)
  (and object
       (js:get-property object "constructor")))

(define-function type (object)
  ;; Object.getPrototypeOf on primitives only works in FireFox:
  ;; ((js:get-property "Object" "getPrototypeOf") object))
  (bind ((type (%constructor object)))
    (or (%get-property type "%ralph-type")
        type)))

(define %actual-type
  (js:function js:null (type)
    (js:return (or (%get-property type "%js-type")
                   type))))

(define-function instance? (object type)
  (bind ((type (%actual-type type)))
    (or
     ;; primitive
     (%has-constructor? object type)
     ;; object
     ((js:get-property type "prototype"
                       "isPrototypeOf")
      object))))

(define-function check-type (value type)
  (unless (instance? value type)
    ;; TODO: throw condition
    (error "check-type failed")))

(define-type <object>)
(define-type <string>)
(define-type <number>)
(define-type <array>)
(define-type <boolean>)
(define-type <function>)

(define-function %alias-type (ralph-type javascript-type)
  (set! (js:get-property ralph-type "%js-type") javascript-type)
  (set! (js:get-property javascript-type "%ralph-type") ralph-type))

(%alias-type <object> (js:identifier "Object"))
(%alias-type <string> (js:identifier "String"))
(%alias-type <number> (js:identifier "Number"))
(%alias-type <array> (js:identifier "Array"))
(%alias-type <boolean> (js:identifier "Boolean"))
(%alias-type <function> (js:identifier "Function"))

;; protocols

(define-type <protocol>)

(define-function %make-protocol ()
  (bind ((protocol (js:new <protocol>)))
    ;; TODO: add slots
    protocol))

(define-function %make-dispatcher (protocol function-name)
  (bind-methods ((dispatcher (#rest arguments)
                   (if-bind (fn (js:get-property
                                 (first arguments)
                                 function-name))
                     (apply fn arguments))))
    (set! (js:get-property dispatcher "%protocol")
          protocol)
    (set! (js:get-property dispatcher "%name")
          function-name)
    dispatcher))

(define-protocol <initialization>
    (initialize (object #rest)))

;; error

(define-type <error>
  message)

(%alias-type <error> (js:identifier "Error"))

;;

(define-protocol <concatenatable>
  (concatenate (first #rest more)))

(define-function concatenate ((first-string <string>) #rest more-strings)
  (reduce (method (current next)
            (js:+ current next))
          first-string
          more-strings))

(define-function concatenate ((first-array <array>) #rest more-arrays)
  (reduce %concat first-array more-arrays))

;;

(define-protocol <describable>
  (description))

(define-function description (number)
  (js:+ "" number))

(define-function description ((string <string>))
  (js:var escaped ((js:get-property string "replace")
                   "\"" "\\\"" "g"))
  (js:+ "\"" escaped "\""))

(define-function description ((array <array>))
  (js:+ "(" (join (map description array) " ") ")"))

(define-function description ((value <boolean>))
  (if value "#t" "#f"))

;;

(define-protocol <condition>
  (signal))

(define-function signal ((error <error>))
  (js:throw error))

;;;; comparison

(define-protocol <comparable>
  (binary= (object1 object2))
  (binary< (object1 object2)))

(define-function binary= (object1 object2)
  (js:and (js:=== (type object1)
                  (type object2))
          (js:== object1 object2)))

(define-function binary< (object1 object2)
  (js:and (js:=== (type object1)
                  (type object2))
          (js:< object1 object2)))

(define-function compare ((function <function>) object1 object2 more-objects)
  (block (return)
    (reduce1 (method (object1 object2)
               (if (function object1 object2)
                   object2
                   (return #f)))
             (%concat (make-array object1 object2)
                      more-objects))
    #t))

(define-function = (object1 object2 #rest more-objects)
  (compare binary= object1 object2 more-objects))

(define-function == (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (js:=== object1 object2))
           object1 object2 more-objects))

(define-function < (object1 object2 #rest more-objects)
  (compare binary< object1 object2 more-objects))

(define-function <= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (and object1
                  object2
                  (or (binary< object1 object2)
                      (binary= object1 object2))))
           object1 object2 more-objects))

(define-function > (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
              (and object1
                   object2
                   (not (binary< object1 object2))
                   (not (binary= object1 object2))))
           object1 object2 more-objects))

(define-function >= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
             (and object1
                  object2
                  (or (not (binary< object1 object2))
                      (binary= object1 object2))))
           object1 object2 more-objects))

(define-function binary= ((array1 <array>) (array2 <array>))
  (and (= (size array1)
          (size array2))
       (block (return)
         (dotimes (i (size array1))
          (unless (= (get array1 i)
                     (get array2 i))
            (return #f)))
         #t)))

(define-function make-object (#rest key-vals)
  (bind ((object (%make-object)))
    (for ((i 0 (+ i 2)))
         ((>= i (size key-vals)) object)
      (set! (get object (get key-vals i))
            (get key-vals (inc i))))))

;; symbols

(define-type <hash-symbol>
    name)

(%define *module* exports "_key"
	 (make <hash-symbol> name: "key"))

(%define *module* exports "_rest"
	 (make <hash-symbol> name: "rest"))


(define-type <symbol>
    name)

(define %symbols (%make-object))

(define-function symbol (name)
  (bind ((name (as-lowercase name)))
    (or (get %symbols name)
        (set! (get %symbols name)
              (make <symbol> name: name)))))

(define-function symbol-name (symbol)
  (get symbol "name"))

(define-function description ((symbol <symbol>))
  (get symbol "name"))

(define-function description ((keyword <keyword>))
  (concatenate (symbol-name keyword) ":"))

(define-function description ((symbol <hash-symbol>))
  (concatenate "#" (symbol-name symbol)))

(define-function identity (value)
  value)

(define-function repeatedly ((function <function>) (count <integer>))
  (bind ((result (make-array)))
    (dotimes (i count result)
      (push-last result (function)))))