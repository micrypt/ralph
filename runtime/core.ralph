
(define-module dylan
  export: (%define
	   %export
	   %define-getter
	   %define-setter
	   setter
	   empty?
	   (js:identifier "_k")
	   <object>
	   <return-value>

;;;; utility functions

(js:define %define
  (js:function (name value)
    (begin
      (js:set (js:get-property *module* name) value)
      (js:if (js:>= ((js:get-property *module* "%exports" "indexOf") name) 0)
             (%export name value)
	     #f))))

(define %export
  (js:function (name value)
     (js:set (js:get-property exports name) value)))

;; manual export necessary
(%export (js:escape %define) %define)

(define %get-definition
  (js:function (name)
    (js:get-property *module* name)))

(define %define-getter
  (js:function (name function)
    (bind ((existing-function (%get-definition name))
	   (setter (and existing-function
			((js:get-property function "hasOwnProperty") "%setter")
			(js:get-property function "%setter"))))
      (%define name function)
      (js:if setter
	     (js:set (js:get-property function "%setter") setter)
	     #f))))

(define %define-setter
  (js:function (name function)
    (begin
      (js:if (js:not (%get-definition name))
	     (%define name (js:new (js:identifier "Function")))
	     #f)
      (js:set (js:get-property (%get-definition name) "%setter") function))))

(%define %interned-keywords (js:new (js:identifier "Object")))

(%define "_k"
  (js:function (name)
    (begin
      (js:var keyword js:null)
      (js:if ((js:get-property %interned-keywords "hasOwnProperty") name)
	     (js:get-property %interned-keywords name)
	     (begin
	       (js:set keyword (js:new <keyword>))
	       (js:set (js:get-property keyword "%name") name)
	       (js:set (js:get-property %interned-keywords name) keyword)
	       keyword)))))

(define-method as ((type (singleton <string>)) (keyword <keyword>))
  (js:get-property keyword "%name"))

(define-method as ((type (singleton <keyword>)) (string <string>))
  ((%get-defintion "_k") string))
;; TODO: replace with proper define-class with slot and initialize method
(define <return-value>
  (js:function (value)
    (js:set (js:get-property js:this "value") value)))

(define-function js:length (object)
  (js:get-property object "length"))

(define-function js:add (object1 #rest more-objects)
  (reduce (method (object1 object2)
	    (js:+ object1 object2))
	  first-object more-objects))

(define-function js:slice (object start end)
  ((js:get-property object "slice") start end))

(define-function js:set-property (object key new-value)
  (js:set (js:get-property object key) new-value))

(define-function js:property-sequence (object)
  (bind ((keys (make <array>)))
    (js:for-in (key object)
      (add! keys key))
    keys))

(define-function setter (function)
  (when ((js:get-property function "hasOwnProperty") "%setter")
    (js:get-property function "%setter")))

;;;; object

(define-class <object> ())

(define-method make ((type <type>))
  (bind ((instance (js:new type)))
    (initialize instance)
    instance))

;;;; keyword

(define-class <keyword> (<object>))

;;;; collection

;; every subclass needs to define:
;; * key-sequence
;; * size
;; * element
;; * (setter element)

(define-class <collection> (<object>))

(define-function elements ((collection <collection>))
  (map (curry element collection)
       (key-sequence collection)))

(define-method empty? ((collection <collection>))
  "Returns true if the collection has zero elements."
  (= (size collection) 0))

(define-method find-key ((collection <collection>) (predicate <function>)
			 #key (skip 0) failure)
  "Returns the key in a collection such that the corresponding collection
element satisfies a predicate."
  (bind ((keys (choose (method (element)
		         (true? (predicate element)))
		       (elements collection))))
    (or (element keys skip) failure)))

(define-method binary= ((collection1 <collection>) (collection2 <collection>))
  (and (== (size collection1) (size collection2))
       (bind ((keys1 (key-sequence collection1))
	      (keys2 (key-sequence collection2)))
         (and (every? == keys1 keys2)
	      (every? =
		      (map (curry element collection1) keys1)
		      (map (curry element collection2) keys2))))))

(define-function any? ((function <function>) (collection <collection>)
		       #rest more-collections)
  "Returns true if a predicate returns true at least
once for the elements of the collection."
  ;; TODO: return as soon as #t
  (reduce (method (previous current)
	    (or previous (function current)))
	  #f (elements collection)))

(define-function every? ((function <function>) (collection <collection>)
			 #rest more-collections)
  "Returns true if a predicate returns true for every
element of the collection."
  (reduce (method (previous current)
	    (and previous (function current)))
	  #t (elements collection)))

;;;; comparison

(define-function true? (value)
  (or (js:=== value 0)
      (js:not (js:not value))))

(define-function not (value)
  (js:not (true? value)))

(define-method binary= (object1 object2)
  (js:== object1 object2))

(define-method binary= ((number <number>) (string <string>))
  #f)

(define-method binary= ((string <string>) (number <number>))
  #f)

(define-method = (object1 object2 #rest objects)
  "Compares objects for equality."
  (cond
    ;; TODO: implement as 2 methods with singletons
    ((or (and (js:== object1 0) (js:== object2 #f))
	 (and (js:== object1 #f) (js:== object2 0)))
     #f)
    (else: (true? (reduce1 (method (object1 object2)
			     (when (binary= object1 object2)
			       object2))
			   (concatenate (list object1 object2)
					objects))))))

(define-function == (object1 object2 #rest objects)
  "Compares objects for identity."
  (true? (reduce1 (method (object1 object2)
		    (when (js:== object1 object2)
		      object2))
		  (concatenate (list object1 object2)
			       objects))))

(define-method < (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:< object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method > (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:> object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method <= (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:<= object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method >= (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:>= object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

;;;; arithmetic

(define-class <number> (<object>))

(define-function + ((number <number>) #rest more-numbers)
  "Returns the sum of its arguments."
  (apply js:add number more-numbers))

(define-function - (object1 #rest objects)
  "Returns the difference of its arguments."
  (if (empty? objects)
      (js:negative object1)
      (reduce (method (object1 object2)
	        (js:- object1 object2))
	      object1 objects)))


;;;; reflection

(define *type-mapping*
  (table (js:identifier "Object") <object>
	 (js:identifier "String") <string>
	 (js:identifier "Number") <number>
	 (js:identifier "Boolean") <boolean>))

(define-function object-class (object)
  "Returns the class of an object."
  ;; Object.getPrototypeOf on primitives only works in FireFox:
  ;; ((js:get-property "Object" "getPrototypeOf") object))
  (bind ((constructor (js:get-property object "__proto__" "constructor")))
    (or (element *type-mapping* constructor)
	constructor)))

(define-function check-type (value (type <type>))
  "Checks an object to ensure that it is an instance of a specified type."
  (when (not (instance? value type))
    (signal (make <type-error>
		  value: value
		  type: type))))

(define-function instance? (object (type <type>))
  "Tests wether an object is an instance of a type."
  (bind ((mapped-type (find-key *type-mapping* (curry == type))))
    ((js:get-property (if mapped-type
			  (element *type-mapping* mapped-type)
			  type)
		      "prototype" "isPrototypeOf")
     object)))


;;;; functional

;; unlike the specification, doesn't require any arguments
(define-function apply ((function <function>) #rest arguments)
  "Applies a function to arguments."
  ((js:get-property function "apply") js:null
   (if (> (size more-arguments) 1)
       (concatenate (but-last arguments)
		    (last arguments))
       arguments)))

(define-function curry ((function <function>) #rest curried-args)
  "Returns a function based on an exisiting function
and a number of default initial arguments."
  (method (#rest args)
    (apply function (concatenate curried-args args))))

(define-function rcurry ((function <function>) #rest curried-args)
  "Returns a function based on an exisiting function
and a number of default final arguments."
  (method (#rest args)
    (apply function (concatenate args curried-args))))

(define-function always (value)
  "Returns a function that always returns a particular object."
  (method (#rest args)
    value))


;;;; sequence

;; every subclass needs to implement
;; * copy-sequence
;; * reverse(!)
;; * sort(!)

(define-class <sequence> (<collection>))

(define-function first ((sequence <sequence>))
  "Returns the first element of a sequence."
  (element sequence 0))

(define-function second ((sequence <sequence>))
  "Returns the second element of a sequence."
  (element sequence 1))

(define-function third ((sequence <sequence>))
  "Returns the third element of a sequence."
  (element sequence 2))

;; unlike specification, defined as function
(define-function last ((sequence <sequence>))
  "Returns the last element of a sequence."
  (element sequence (- (size sequence) 1)))

(define-method replace-subsequence
    ((target-sequence <sequence>) (insert-sequence <sequence>)
     #key (start 0) (end (size target-sequence)))
  "Returns a sequence where a portion of the sequence is replaced with
the elements of another sequence."
  (concatenate (copy-sequence target-sequence end: start)
	       insert-sequence
	       (copy-sequence target-sequence start: end)))

(define-method but-last ((sequence <sequence>))
  (copy-sequene sequence end: (- (size sequence) 1)))

(define-method choose-by ((predicate <function>) (test-sequence <sequence>)
			  (value-sequence <sequence>))
  "Returns those elments of a sequence that correspond to those in another
sequence that satisfy a predicate."
  (bind ((test-keys (choose (method (test-key)
			      (predicate (element test-sequence test-key)))
			    (key-sequence test-sequence))))
    (map (curry element value-sequence) test-keys)))

;;;; table

(define-class <table> (<collection>))

(define-method make ((class (singleton <deque>)) #key (size 0))
  ;; size ignored
  (js:new (js:identifier "Object")))

(define-method element ((table <table>) key #key default)
  "Returns the element associated with a particular key."
  (or (when ((js:get-property table "hasOwnProperty") key)
	(js:get-property table key))
      default))

(define-method (setter element) ((table <table>) key new-value)
  "Sets the element associated with a particular key."
  (js:set-property table key new-value))

(define-method key-sequence ((table <table>))
  "Returns a sequence containing the keys of its collection argument."
  (js:property-sequence table))

(define-method size ((table <table>))
  "Returns the size of table."
  (js:length table))

(define-function table (#rest elements)
  (bind ((table (make <table>)))
    (reduce (method (key current)
	      (if key
		  (begin
		    (set! (element table key) current)
		    #f)
		  current))
	    #f elements)))

;;;; deque

(define-class <deque> (<sequence>))

(define-method make ((class (singleton <deque>)) #key (size 0) fill)
  (bind ((deque (js:new (js:identifier "Array") size)))
    (do (rcurry (curry (setter element) deque) fill)
        (key-sequence deque))
    deque))

(define-method push ((deque <deque>) new-value)
  "Adds an element to the front of a deque."
  ((js:get-property deque "unshift") new-value))

(define-method push-last ((deque <deque>) new-value)
  "Adds an element to the end of a deque."
  ((js:get-property deque "push") new-value))

(define-method pop ((sequence <sequence>))
  "Removes and returns the first element of a deque."
  ((js:get-property deque "shift")))

(define-method pop-last ((sequence <sequence>))
  "Removes and returns an element from the end of a deque."
  ((js:get-property sequence "pop")))

(define-method add! ((deque <deque>) new-value)
  "Adds an element at the beginning of the deque."
  (push deque new-value))

(define-method copy-sequence ((deque <deque>)
			      #key (start 0) (end (size deque)))
  "Returns a new deque containing the elements of deque
between start and end."
  (js:slice deque start end))

(define-method element ((deque <deque>) key #key default)
  "Returns the element associated with a particular key."
  (or (js:get-property deque key) default))

(define-method (setter element) ((deque <deque>) key new-value)
  "Sets the element associated with a particular key."
  (js:set-property deque key new-value))

(define-method key-sequence ((deque <deque>))
  "Returns a sequence containing the keys of its collection argument."
  (js:property-sequence deque))

(define-method size ((deque <deque>))
  "Returns the size of deque."
  (js:length deque))

;;;; string

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable
;; * generic < works for strings

(define-class <string> (<sequence>))

;; TODO
;; (define-method make ((class (singleton <deque>)) #key (size 0) (fill " "))
;;   (bind ((deque (js:new (js:identifier "String") size)))
;;     (do (rcurry (curry (setter element) deque) fill)
;;         (key-sequence deque))
;;     deque))

(define-method element ((string <string>) position #key default)
  (or ((js:get-property string "charAt") position) default))

(define-function as-uppercase ((string <string>))
  "Coerces a string to uppercase."
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  "Coerces a string to lowercase."
  ((js:get-property string "toLowerCase")))

(define-method size ((string <string>))
  "Returns the size of string."
  (js:length string))

(define-method concatenate ((first-string <string>) #rest more-strings)
  "Returns the concatenation of one or more strings."
  (apply js:add first-string more-strings))

(define-method copy-sequence ((string <string>)
			      #key (start 0) (end (size string)))
  "Returns a new string containing the elements of string
between start and end."
  (js:slice string start end))

;;;; list / __vector__ / array ?!

;; TODO

(define-method copy-sequence ((sequence <sequence>)
			      #key (start 0) (end (size sequence)))
  "Returns a new string containing the elements of sequence
between start and end."
  (js:slice sequence start end))

(define-function list (#rest elements)
  (bind ((result (js:new "Array")))
    ((js:get-property "Array" "prototype" "splice" "apply")
     result (concatenate (list 0 0) elements))
    result))

(define-method concatenate ((first-sequence <sequence>) #rest more-sequences)
  "Returns the concatenation of one or more sequences."
  ((js:get-property "Array" "prototype" "concat" "apply")
   first-sequence more-sequences))

(define-method element ((sequence <sequence>) key #key default)
  "Returns the element associated with a particular key."
  (or (js:get-property sequence key) default))

(define-method (setter element) ((sequence <sequence>) key new-value)
  "Sets the element associated with a particular key."
  (js:set-property sequence key new-value))

(define-method key-sequence ((sequence <sequence>))
  "Returns a sequence containing the keys of its collection argument."
  (js:property-sequence sequence))

(define-method size ((sequence <sequence>))
  "Returns the size of sequence."
  (js:length sequence))

(define-function reverse! ((source-sequence <sequence>))
  "Returns a sequence with elements in the reverse order
of its arguments sequence."
  ((js:get-property source-sequence "reverse")))

(define-method reverse ((source-sequence <sequence>))
  "Returns a sequence with elements in the reverse
order of its arguments sequence."
  (reverse! (copy-sequence source-sequence)))

(define-method sort! ((source-sequence <sequence>) #key (test <))
  "Returns a sequence containing the elements of its argument sequence, sorted."
  ((js:get-property (elements source-sequence) "sort") test))

(define-method sort ((source-sequence <sequence>) #key (test <))
  "Returns a sequence containing the elements of its
argument sequence, sorted."
  (sort! (copy-sequence source-sequence) test: test))

(define-method reduce1 ((function <function>) (collection <collection>))
  "Combines the elements of a collection into a single value by repeatedly
applying a binary function, using the first element of the collection as
the seed value."
  (bind ((elements (elements collection)))
    (reduce function
	    (first elements)
	    (rest elements))))

(define-method reduce ((function <function>) initial-value (collection <collection>))
  "Combines the elements of a collection and a seed value into a single value by
repeatedly applying a binary function."
  ;; TODO
  )

(define-method choose ((predicate <function>) (source-sequence <sequence>))
  "Returns those elements of a sequence that satisfy a predicate."
  ((js:get-property (elements source-sequence) "filter") predicate))