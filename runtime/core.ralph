
(define-module dylan
  export: (%define
	   %export
	   %define-getter
	   %define-setter
	   setter
	   empty?))

;;;; utility functions

(js:define %define
  (js:function (name value)
    (begin
      (js:set (js:get-property *module* name) value)
      (js:if (js:>= ((js:get-property *module* "%exports" "indexOf") name) 0)
             (%export name value)
	     #f))))

(define %export
  (js:function (name value)
     (js:set (js:get-property exports name) value)))

;; manual export necessary
(%export (js:escape %define) %define)

(define %define-getter
  (js:function (name function)
    (bind ((existing-function (js:get-property *module* name))
	   (setter (and existing-function
			((js:get-property function "hasOwnProperty") "%setter")
			(js:get-property function "%setter"))))
      (%define name function)
      (js:if setter
	     (js:set (js:get-property function "%setter") setter)
	     #f))))

(define %define-setter
  (js:function (name function)
    (begin
      (js:if (js:not (js:get-property *module* name))
	     (%define name (js:new (js:identifier "Function")))
	     #f)
      (js:set (js:get-property *module* name "%setter") function))))

(define-function js:length (object)
  (js:get-property object "length"))

(define-function js:add (object1 #rest more-objects)
  (reduce (method (object1 object2)
	    (js:+ object1 object2))
	  first-object more-objects))

(define-function js:slice (object start end)
  ((js:get-property object "slice") start end))

(define-function js:set-property (object key new-value)
  (js:set (js:get-property object key) new-value))

(define-function js:property-sequence (object)
  (bind ((keys (make <array>)))
    (js:for-in (key object)
      (add! keys key))
    keys))

(define-function setter (function)
  (when ((js:get-property function "hasOwnProperty") "%setter")
    (js:get-property function "%setter")))


;;;; object

(define-class <object> ())

(define-method make ((type <type>))
  (bind ((instance (js:new type)))
    (initialize instance)
    instance))

;;;; collection

;; every subclass needs to define:
;; * key-sequence
;; * size
;; * element
;; * (setter element)

(define-class <collection> (<object>))

(define-function elements ((collection <collection>))
  (map (curry element collection)
       (key-sequence collection)))

(define-method empty? ((collection <collection>))
  "Returns true if the collection has zero elements."
  (= (size collection) 0))

(define-method find-key ((collection <collection>) (predicate <function>)
			 #key (skip 0) failure)
  "Returns the key in a collection such that the corresponding collection
element satisfies a predicate."
  (bind ((keys (choose (method (element)
		         (true? (predicate element)))
		       (elements collection))))
    (or (element keys skip) failure)))

(define-method binary= ((collection1 <collection>) (collection2 <collection>))
  (and (== (size collection1) (size collection2))
       (bind ((keys1 (key-sequence collection1))
	      (keys2 (key-sequence collection2)))
         (and (every? == keys1 keys2)
	      (every? =
		      (map (curry element collection1) keys1)
		      (map (curry element collection2) keys2))))))

(define-function any? ((function <function>) (collection <collection>)
		       #rest more-collections)
  "Returns true if a predicate returns true at least
once for the elements of the collection."
  ;; TODO: return as soon as #t
  (reduce (method (previous current)
	    (or previous (function current)))
	  #f (elements collection)))

(define-function every? ((function <function>) (collection <collection>)
			 #rest more-collections)
  "Returns true if a predicate returns true for every
element of the collection."
  (reduce (method (previous current)
	    (and previous (function current)))
	  #t (elements collection)))
(define-function true? (value)
  (or (js:=== value 0)
      (js:not (js:not value))))

(define-function not (value)
  (js:not (true? value)))

(define-function false? (value)
  (not (true? value)))
(define-method binary= (object1 object2)
  (js:== object1 object2))

(define-function list (#rest elements)
  (bind ((result (js:new "Array")))
    ((js:get-property "Array" "prototype" "splice" "apply")
     result (concatenate (list 0 0) elements))
    result))
(define-method binary= ((number <number>) (string <string>))
  #f)

(define-method binary= ((string <string>) (number <number>))
  #f)

(define-method = (object1 object2 #rest objects)
  "Compares objects for equality."
  (cond
    ;; TODO: implement as 2 methods with singletons
    ((or (and (js:== object1 0) (js:== object2 #f))
	 (and (js:== object1 #f) (js:== object2 0)))
     #f)
    (else: (true? (reduce1 (method (object1 object2)
			     (when (binary= object1 object2)
			       object2))
			   (concatenate (list object1 object2)
					objects))))))

(define-function == (object1 object2 #rest objects)
  "Compares objects for identity."
  (true? (reduce1 (method (object1 object2)
		    (when (js:== object1 object2)
		      object2))
		  (concatenate (list object1 object2)
			       objects))))

(define-method < (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:< object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method > (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:> object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method <= (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:<= object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-method >= (object1 object2 #rest objects)
  (true? (reduce1 (method (object1 object2)
		    (when (js:>= object1 object2)
		      object2))
	       (concatenate (list object1 object2)
			    objects))))

(define-function + (object1 #rest objects)
  "Returns the sum of its arguments."
  (reduce1 (method (object1 object2)
	     (js:+ object1 object2))
	   (concatenate (list object1)
			objects)))

(define-function - (object1 #rest objects)
  "Returns the difference of its arguments."
  (if (empty? objects)
      (js:negative object1)
      (reduce1 (method (object1 object2)
	         (js:- object1 object2))
	       (concatenate (list object1)
			    objects))))

;; unlike the specification, is a method
(define-method = (object1 object2 #rest objects)
  "Compares objects for equality."
  (cond
    ;; TODO: implement as 2 methods with singletons
    ((or (and (js:== object1 0)
	      (js:== object2 #f))
	 (and (js:== object1 #f)
	      (js:== object2 0)))
     #f)
    (else: (true? (reduce1 (method (object1 object2)
			     (when (js:== object1 object2)
			       object2))
			   (concatenate (list object1 object2)
					objects))))))

(define-function == (object1 object2 #rest objects)
  "Compares objects for identity."
  (true? (reduce1 (method (object1 object2)
		    (when (js:== object1 object2)
		      object2))
		  (concatenate (list object1 object2)
			       objects))))

(define-function object-class (object)
  "Returns the class of an object."
  ;; Object.getPrototypeOf on primitives only works in FireFox"
  ;; ((js:get-property "Object" "getPrototypeOf") object))
  (js:get-property object "__proto__" "constructor"))

(define-function check-type (value (type <type>))
  "Checks an object to ensure that it is an instance of a specified type."
  (when (not (instance? value type))
    (signal (make <type-error>
		  value: value
		  type: type))))

(define-function instance? (object (type <type>))
  "Tests wether an object is an instance of a type."
  ((js:get-property type "prototype" "isPrototypeOf") object))

;; unlike the specification, doesn't require any arguments
(define-function apply ((function <function>) #rest arguments)
  "Applies a function to arguments."
  ((js:get-property function "apply") js:null
   (if (> (size more-arguments) 1)
       (concatenate (but-last arguments)
		    (last arguments))
       arguments)))

(define-function reduce1 ((function <function>) (collection <collection>))
  "Combines the elements of a collection into a single value by repeatedly
applying a binary function, using the first element of the collection as
the seed value."
  ((js:get-property collection "reduce") function))

;; unlike the specification, doesn't signal an error if the key wasn't found
;; and no default value was supplied
(define-method element ((collection <collection>) key #key default)
  "Returns the collection element associated with a particular key."
  (or (js:get-property collection key) default))

(define-method copy-sequence (source #key (start 0) (end (size source)))
  "Returns a new sequence containing the elements of source
between start and end."
  ((js:get-property source "slice") start end))

(define-method size ((sequence <sequence>))
  "Returns the size of object."
  ;; length is a property, not a function
  (js:get-property sequence "length"))

;; TODO: specification: push(-last), pop(-last) only defined on <deque>
(define-function push ((source-sequence <sequence>) new-value)
  "Adds an element to the front of a sequence."
  ((js:get-property source-sequence "unshift") new-value))

(define-function push-last ((source-sequence <sequence>) new-value)
  "Adds an element to the end of a sequence."
  ((js:get-property source-sequence "push") new-value))

(define-function pop ((sequence <sequence>))
  "Removes and returns the first element of a sequence."
  ((js:get-property source-sequence "shift")))

(define-function pop-last ((sequence <sequence>))
  "Removes and returns an element from the end of a sequence."
  ((js:get-property sequence "pop")))

(define-function reverse! ((source-sequence <sequence>))
  "Returns a sequence with elements in the reverse order
of its arguments sequence."
  ((js:get-property source-sequence "reverse")))

(define-method key-sequence ((collection <collection>))
  "Returns a sequence containing the keys of its collection argument."
  (bind ((keys (list)))
    (js:for-in (key collection)
      (add! keys key))
    keys))

(define-function as-uppercase ((string <string>))
  "Coerces a string to uppercase."
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  "Coerces a string to lowercase."
  ((js:get-property string "toLowerCase")))

;; as-uppercase! and as-lowercase! impossible,
;; as strings in JavaScript are immutable


;; TODO: more-collections for do, map, any?, every?:
;; iterate over shortest key-sequence, apply elements

(define-function do ((function <function>) (collection <collection>)
		     #rest more-collections)
  "Iterates over the collections for side effect."
  ;; TODO: forEach only defined on arrays, for-in also works on strings
  ((js:get-property collection "forEach") function))

(define-function map ((function <function>) (collection <collection>)
		      #rest more-collections)
  "Iterates over the collections and collects the results in a collection."
   ((js:get-property collection "map") function))




(define-method choose ((predicate <function>) (source-sequence <sequence>))
  "Returns those elements of a sequence that satisfy a predicate."
  ((js:get-property source-sequence "filter") predicate))

(define-method sort! ((source-sequence <sequence>) #key (test <))
  "Returns a sequence containing the elements of its argument sequence, sorted."
  ((js:get-property source-sequence "sort") test))

;; TODO: why is this a function in the specification?
(define-function concatenate ((first-sequence <sequence>) #rest more-sequences)
  "Returns the concatenation of one or more sequences."
  ((js:get-property "Array" "prototype" "concat" "apply") first-sequence more-sequences))




;;;; table

(define-class <table> (<collection>))

(define-method make ((class (singleton <deque>)) #key (size 0))
  ;; size ignored
  (js:new (js:identifier "Object")))

(define-method element ((table <table>) key #key default)
  "Returns the element associated with a particular key."
  (or (when ((js:get-property table "hasOwnProperty") key)
	(js:get-property table key))
      default))

(define-method (setter element) ((table <table>) key new-value)
  "Sets the element associated with a particular key."
  (js:set-property table key new-value))

(define-method key-sequence ((table <table>))
  "Returns a sequence containing the keys of its collection argument."
  (js:property-sequence table))

(define-method size ((table <table>))
  "Returns the size of table."
  (js:length table))

;;;; deque

(define-class <deque> (<sequence>))

(define-method make ((class (singleton <deque>)) #key (size 0) fill)
  (bind ((deque (js:new (js:identifier "Array") size)))
    (do (rcurry (curry (setter element) deque) fill)
        (key-sequence deque))
    deque))

(define-method push ((deque <deque>) new-value)
  "Adds an element to the front of a deque."
  ((js:get-property deque "unshift") new-value))

(define-method push-last ((deque <deque>) new-value)
  "Adds an element to the end of a deque."
  ((js:get-property deque "push") new-value))

(define-method pop ((sequence <sequence>))
  "Removes and returns the first element of a deque."
  ((js:get-property deque "shift")))

(define-method pop-last ((sequence <sequence>))
  "Removes and returns an element from the end of a deque."
  ((js:get-property sequence "pop")))

(define-method add! ((deque <deque>) new-value)
  "Adds an element at the beginning of the deque."
  (push deque new-value))

(define-method copy-sequence ((deque <deque>)
			      #key (start 0) (end (size deque)))
  "Returns a new deque containing the elements of deque
between start and end."
  (js:slice deque start end))

(define-method element ((deque <deque>) key #key default)
  "Returns the element associated with a particular key."
  (or (js:get-property deque key) default))

(define-method (setter element) ((deque <deque>) key new-value)
  "Sets the element associated with a particular key."
  (js:set-property deque key new-value))

(define-method key-sequence ((deque <deque>))
  "Returns a sequence containing the keys of its collection argument."
  (js:property-sequence deque))

(define-method size ((deque <deque>))
  "Returns the size of deque."
  (js:length deque))

;;;; string

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable
;; * generic < works for strings

(define-class <string> (<sequence>))

(define-method element ((string <string>) position #key default)
  (or ((js:get-property string "charAt") position) default))

(define-function as-uppercase ((string <string>))
  "Coerces a string to uppercase."
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  "Coerces a string to lowercase."
  ((js:get-property string "toLowerCase")))

(define-method size ((string <string>))
  "Returns the size of string."
  (js:length string))

(define-method concatenate ((first-string <string>) #rest more-strings)
  "Returns the concatenation of one or more strings."
  (apply js:add first-string more-strings))

(define-method copy-sequence ((string <string>)
			      #key (start 0) (end (size string)))
  "Returns a new string containing the elements of string
between start and end."
  (js:slice string start end))