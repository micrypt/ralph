
(define-module dylan
  export: (%define
	   %export
	   %define-getter
	   %define-setter
	   setter
	   %interned-keywords
	   (js:identifier "_k")
	   <object>
	   <non-local-exit>
	   not
	   true?))

;;;; define

(%function %define (name value)
  (begin
    (set! (js:get-property *module* name) value)
    (js:if (js:>= ((js:get-property *module* "%exports" "indexOf") name) 0)
	   (%export name value)
	   #f)))

(define %export
  (%function js:null (name value)
     (set! (js:get-property exports name) value)))

;; manual export necessary
(%export (js:escape %define) %define)

(define %has-property?
  (%function js:null (object name)
    (js:return ((js:get-property object "hasOwnProperty") name))))

(define %get-definition
  (%function js:null (name)
    (js:return (and (%has-property? *module* name)
		    (js:get-property *module* name)))))

(define %has-constructor?
  (%function js:null (object constructor)
    (js:return (js:=== (js:get-property object "constructor")
		       constructor))))

;;;; boolean primitives

(define true?
  (%function js:null (value)
    (js:return
     (js:and (js:not (js:=== value js:null))
	     (js:not (js:=== value js:undefined))
	     (js:or (%has-constructor? value (js:identifier "Number"))
		    (%has-constructor? value (js:identifier "String"))
		    (js:not (js:not value)))))))

(define not
  (%function js:null (value)
    (js:return (js:not (true? value)))))

;;;; getter

(define %define-getter
  (%function js:null (name function)
    (bind ((getter (%get-definition name))
	   (setter (and getter
			(%has-property? getter "%setter")
			(js:get-property getter "%setter"))))
      (%define name function)
      (when setter
	(set! (js:get-property function "%setter") setter)))))

;;;; setter

(define %define-setter
  (%function js:null (name function)
    (begin
      (unless (%get-definition name)
	(%define name (js:new (js:identifier "Function"))))
      (set! (js:get-property (%get-definition name) "%setter") function))))

(define-function setter ((function <function>))
  (when (%has-property? function "%setter")
    (js:get-property function "%setter")))

;;;; keywords

(define-function make (type)
  (js:new type))

(define-function make-object ()
  (make (js:identifier "Object")))

(define %interned-keywords (make-object))

(define <keyword> (js:new (js:identifier "Function")))

(define-function keyword? (keyword)
  (instance? keyword <keyword>))

(%define "_k"
  (%function js:null (name)
    (begin
      (js:var keyword js:null)
      (js:return
       (if (%has-property? %interned-keywords name)
	   (js:get-property %interned-keywords name)
	   (begin
	    (set! keyword (make <keyword>))
	    (set! (js:get-property keyword "%name") name)
	    (set! (js:get-property %interned-keywords name) keyword)
	    keyword))))))

;;;; non-local exit

;; TODO: should be a type that conforms to condition protocol

(define <non-local-exit>
  (%function js:null (name value)
    (begin
     (set! (js:get-property js:this "name") name)
     (set! (js:get-property js:this "value") value)
     (js:return js:this))))

(define-function %non-local-exit? (condition)
  (instance? condition <non-local-exit>))

;; TODO: replace with proper initialization method
(define-function %make-non-local-exit-function (name)
  (method (value)
    ;; TODO: use signal and proper make call
    (js:throw (js:new <non-local-exit>
		      name value))))

(define-function %as-array (arguments skip)
  ((js:get-property "Array" "prototype"
		    "slice" "call")
   arguments skip))

(define-function get (object #rest keys)
  (block (return)
    (reduce (method (object key)
	      (if (%has-property? object key)
		  (js:get-property object key)
		  (return #f)))
	    object keys)))

(define-function (setter get) (object #rest properties/value)
  (if (<= (size properties/value) 2)
      (set! (js:get-property object (first properties/value))
	    (second properties/value))
      (bind ((property (first properties/value))
	     (object2 (if (%has-property? object property)
			  (get object property)
			  (bind ((new (make-object)))
			    (set! (js:get-property object property) new)
			    new))))
        (apply (setter get) object2
	       (rest properties/value)))))

(define-function size ((array <array>))
  (js:get-property array "length"))

(define-function do ((function <function>) (array <array>))
  ((js:get-property array "forEach") function))

(define-function copy-sequence ((array <array>) #key (start 0) (end (size array)))
  ((js:get-property array "slice")
   (or start 0)
   (or end (js:length array))))

(define-function push-last ((array <array>) new-value)
  ((js:get-property array "push") new-value)
  array)

(define-function inc ((number <number>))
  (js:+ number 1))

(define-function dec ((number <number>))
  (js:- number 1))

(define-function + ((number <number>) #rest more-numbers)
  (reduce (method (number1 number2)
	    (js:+ number1 number2))
	  number more-numbers))

(define-function - ((number <number>) #rest more-numbers)
  (if (empty? more-numbers)
      (js:negative number)
      (reduce (method (number1 number2)
	        (js:- number1 number2))
	      number more-numbers)))

(define-function * ((number1 <number>) (number2 <number>)
		    #rest more-numbers)
  (reduce1 (method (number1 number2)
	     (js:* number1 number2))
	   (concatenate (make-array number1
				    number2)
			more-numbers)))

(define-function keys (object)
  (bind ((keys (js:new (js:identifier "Array"))))
    (if (instance? object (js:identifier "Array"))
	;; TODO: replace with range
	(for ((i 0 (inc i)))
	     ((>= i (size object)) keys)
	  (push-last keys i))
        (begin
	 (js:for-in (key object)
	   (push-last keys key))
	 keys))))

(define-function make-array (#rest elements)
  elements)

(define-function push ((array <array>) new-value)
  ((js:get-property array "unshift") new-value)
  array)

(define-function pop ((array <array>))
  ((js:get-property array "shift"))
  array)

(define-function pop-last ((array <array>))
  ((js:get-property array "pop"))
  array)

(define-function add! ((array <array>) new-value)
  (push array new-value))

(define-function concatenate ((first-array <array>) #rest more-arrays)
  ((js:get-property "Array" "prototype" "concat" "apply")
   first-array more-arrays))

(define-function reverse! ((array <array>))
  ((js:get-property array "reverse")))

(define-function reverse ((array <array>))
  (reverse! (copy-sequence array)))

(define-function sort! ((array <array>) #key (test <))
  ((js:get-property array "sort") test))

(define-function sort ((array <array>) #key (test <))
  (sort! (copy-sequence array) test: test))

(define-function element ((array <array>) (key <string>)
			  #key default)
  (or (js:get-property array key) default))

(define-function (setter element) ((array <array>) key new-value)
  (set! (js:get-property array key) new-value))

(define-function empty? ((array <array>))
  (== (size array) 0))

;; the functions passed to map and reduce are
;; wraped in additional method, as the JS version
;; also additionally passes the index and
;; the traversed array - might clash when
;; using curry/rcurry

(define-function map ((function <function>) (array <array>))
  ((js:get-property array "map")
   (method (element)
     (function element))))

(define-function reduce1 ((function <function>) (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))))

(define-function reduce ((function <function>) initial-value (array <array>))
  ((js:get-property array "reduce")
   (method (previous current)
     (function previous current))
   initial-value))

(define-function every? ((function <function>) (array <array>))
  ((js:get-property array "every")
   (method (element)
     (true? (function element)))))

(define-function choose ((function <function>) (array <array>))
  ((js:get-property array "filter")
   (method (element)
     (true? (function element)))))

(define %not-found (make-object))

(define-function find-key ((array <array>) (predicate <function>)
			   #key (skip 0) failure from-end)
  (bind ((keys (keys array))
	 (satisfying-keys
	  (choose (method (index)
		    (true? (predicate (element array index))))
		  (if from-end
		      (reverse keys)
		      keys))))
    (or (element satisfying-keys skip)
	failure)))

(define-function any? ((function <function>) (array <array>))
  (block (return)
    (do (method (element)
	  (bind ((result (function element)))
	    (when result
	      (return result))))
	array)
    #f))

(define-function member? (value (array <array>))
  (true? (any? (method (other-value)
		 (== value other-value))
	       array)))

(define-function choose-by ((predicate <function>)
			    (test-array <array>)
			    (value-array <array>))
  (bind ((test-keys (choose (method (test-key)
			      (predicate (element test-array test-key)))
			    (keys test-array))))
    (map (curry element value-array)
	 test-array)))

(define-function first ((array <array>))
  (element array 0))

(define-function second ((array <array>))
  (element array 1))

(define-function third ((array <array>))
  (element array 2))

(define-function last ((array <array>))
  (element array (dec (size array))))

(define-function rest ((array <array>))
  (copy-sequence array start: 1))

(define-function but-last ((array <array>) #key (n 1))
  (copy-sequence array end: (* n -1)))

(define-function replace-subsequence (target-array insert-array
				      #key (start 0) (end (size target-array)))
  (concatenate (copy-sequence target-array end: start)
	       insert-array
	       (copy-sequence target-array start: end)))

;;;; string

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable

(define-function as-uppercase ((string <string>))
  ((js:get-property string "toUpperCase")))

(define-function as-lowercase ((string <string>))
  ((js:get-property string "toLowerCase")))

;;;; functional

(define-function apply ((function <function>) #rest arguments)
  ((js:get-property function "apply") js:null
   (concatenate (but-last arguments)
		(last arguments))))

(define-function curry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate curried-args args))))

(define-function rcurry ((function <function>) #rest curried-args)
  (method (#rest args)
    (apply function (concatenate args curried-args))))

(define-function always (value)
  (method (#rest args)
    value))

(define-function complement ((function <function>))
  (method (#rest arguments)
    (not (apply function arguments))))

;;;; comparison

(define-function binary= (object1 object2)
  (js:and (js:=== (type object1)
		  (type object2))
	  (js:== object1 object2)))

(define-function binary< (object1 object2)
  (js:and (js:=== (type object1)
		  (type object2))
	  (js:< object1 object2)))

(define-function compare ((function <function>) object1 object2 more-objects)
  (block (return)
    (reduce1 (method (object1 object2)
	       (if (function object1 object2)
		   object2
		   (return #f)))
	     (concatenate (make-array object1 object2)
			  more-objects))
    #t))

(define-function = (object1 object2 #rest more-objects)
  (compare binary= object1 object2 more-objects))

(define-function == (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
	     (js:=== object1 object2))
	   object1 object2 more-objects))

(define-function < (object1 object2 #rest more-objects)
  (compare binary< object1 object2 more-objects))

(define-function <= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
	     (or (binary< object1 object2)
		 (binary= object1 object2)))
	   object1 object2 more-objects))

(define-function > (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
	     (and (not (binary< object1 object2))
		  (not (binary= object1 object2))))
	   object1 object2 more-objects))

(define-function >= (object1 object2 #rest more-objects)
  (compare (method (object1 object2)
	     (or (not (binary< object1 object2))
		 (binary= object1 object2)))
	   object1 object2 more-objects))

;;;; reflection primitives

(define-function type (object)
  ;; Object.getPrototypeOf on primitives only works in FireFox:
  ;; ((js:get-property "Object" "getPrototypeOf") object))
  (bind ((type (js:get-property object "constructor")))
    (if (%has-property? type "%ralph-type")
	(js:get-property type "%ralph-type")
	type)))

(define-function instance? (object type)
  (bind ((actual-type
	  (if (%has-property? type "%js-type")
	      (js:get-property type "%js-type")
	      type)))
    (or
     ;; primitive
     (%has-constructor? object actual-type)
     ;; object
     ((js:get-property actual-type "prototype"
		       "isPrototypeOf")
      object))))

(define-function check-type (value type)
  (unless (instance? value type)
    ;; TODO: throw condition
    (error "check-type failed")))

(define-type <object>)
(define-type <string>)
(define-type <number>)

(define-function alias-type (ralph-type javascript-type)
  (set! (js:get-property ralph-type "%js-type") javascript-type)
  (set! (js:get-property javascript-type "%ralph-type") ralph-type))

(alias-type <object> (js:identifier "Object"))
(alias-type <string> (js:identifier "String"))
(alias-type <number> (js:identifier "Number"))

;; protocols

(define-function %make-protocol-dispatcher (protocol function-name)
  (method (#rest arguments)
    (bind ((type (type (first arguments)))
	   (type-name (get type "%name")))
      (if-bind (implementation (get protocol "%imp" type-name function-name))
        (apply implementation arguments)
	(print "No method of " function-name " for type " type-name)))))

(define-type <protocol>)

(define-protocol <initialization>
    (initialize (object #rest)))

