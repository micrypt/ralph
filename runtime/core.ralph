
(define-module dylan
  export: (%define
	   %export
	   %define-getter
	   %define-setter
	   setter
	   %interned-keywords
	   (js:identifier "_k")
	   <object>
	   <non-local-exit>
	   values))

;;;; define

(%%define %define
  (%function js:null (name value)
    (begin
      (js:set (js:get-property *module* name) value)
      (js:if (js:>= ((js:get-property *module* "%exports" "indexOf") name) 0)
             (%export name value)
	     #f))))

(define %export
  (%function js:null (name value)
     (js:set (js:get-property exports name) value)))

;; manual export necessary
(%export (js:escape %define) %define)

(define js:has-property?
  (%function js:null (object name)
    (js:return ((js:get-property object "hasOwnProperty") name))))

(define %get-definition
  (%function js:null (name)
    (js:return (and (js:has-property? *module* name)
		    (js:get-property *module* name)))))


;;;; boolean primitives

(define js:constructor?
  (%function js:null (object constructor)
    (js:return (js:=== (js:get-property object "constructor")
		       constructor))))

(define %true?
  (%function js:null (value)
    (js:return
     (js:and (js:not (js:=== value js:null))
	     (js:not (js:=== value js:undefined))
	     (js:or (js:constructor? value (js:identifier "Number"))
		    (js:constructor? value (js:identifier "String"))
		    (js:not (js:not value)))))))

(define %not
  (%function js:null (value)
    (js:return (js:not (%true? value)))))

;;;; getter

(define %define-getter
  (%function js:null (name function)
    (bind ((getter (%get-definition name))
	   (setter (and getter
			(js:has-property? getter "%setter")
			(js:get-property getter "%setter"))))
      (%define name function)
      (when setter
	(js:set (js:get-property function "%setter") setter)))))

;;;; setter

(define %define-setter
  (%function js:null (name function)
    (begin
      (when (%not (%get-definition name))
	(%define name (js:new (js:identifier "Function"))))
      (js:set (js:get-property (%get-definition name) "%setter") function))))

(define-function setter (function)
  (when (js:has-property? function "%setter")
    (js:get-property function "%setter")))

;;;; keywords

(define %interned-keywords (js:new (js:identifier "Object")))

(%define "_k"
  (%function js:null (name)
    (begin
      (js:var keyword js:null)
      (js:return
       (if (js:has-property? %interned-keywords name)
	   (js:get-property %interned-keywords name)
	   (begin
	    (js:set keyword (js:new <keyword>))
	    (js:set (js:get-property keyword "%name") name)
	    (js:set (js:get-property %interned-keywords name) keyword)
	    keyword))))))

;;;; non-local exit

;; TODO: replace with proper define-class with slot
;; (superclass: condition?)
(define <non-local-exit>
  (%function js:null (name values)
    (begin
     (js:set (js:get-property js:this "name") name)
     (js:set (js:get-property js:this "values") values)
     (js:return js:this))))

;; TODO: replace with proper initialization method
(define-function %make-non-local-exit-function (name)
  (method (#rest values)
    ;; TODO: use signal and proper make call
    (js:throw (js:new <non-local-exit>
		      name values))))

;;;; multiple return values

(define-function values (#rest values)
  (when (%empty? values)
    (js:set values (%array #f)))
  (when (js:> (%size values) 1)
    ;; function who called 'values'
    (js:var callee (js:get-property js:arguments "callee" "caller"))
    ;; skip 'scope functions'
    (js:var caller
	    (for ((caller callee (js:get-property caller "caller"))
		  (caller2 #f caller))
		 ((or (%not caller)
		      (and (js:has-property? caller "%top")
			   (%not (js:has-property? caller "%skip"))))
		  caller2)))
    ;; set values on the function
    ;; that called the function which returns values
    (js:set (js:get-property caller "otherValues")
	    ((js:get-property values "slice") 1)))
  (js:get-property values 0))

;;;; JS utilities

(define-function js:length (array)
  (js:get-property array "length"))

(define-function js:for-each (function objects)
  ((js:get-property objects "forEach") function))

(define-function js:slice (array start end)
  ((js:get-property array "slice")
   (or start 0)
   (or end (js:length array))))

(define-function js:property-sequence (object)
  (bind ((keys (js:new (js:identifier "Array"))))
    (js:for-in (key object)
      ((js:get-property keys "push") key))
    keys))

(define-function js:argument-list (arguments skip)
  ((js:get-property "Array" "prototype"
		    "slice" "call")
   arguments skip))

(define-function js:make-object ()
  (js:new (js:identifier "Object")))

;;;; collection primitives
;; (only work on JavaScript arrays)

(define-function %array (#rest elements)
  elements)

(define-function %push (array new-value)
  ((js:get-property array "unshift") new-value)
  array)

(define-function %push-last (array new-value)
  ((js:get-property array "push") new-value)
  array)

(define-function %pop (array)
  ((js:get-property array "shift"))
  array)

(define-function %pop-last (array)
  ((js:get-property array "pop"))
  array)

(define-function %add! (array new-value)
  (%push array new-value))

(define-function %copy-sequence (array #key (start 0) (end (%size array)))
  (js:slice array start end))

(define-function %concatenate (first-array #rest more-arrays)
  ((js:get-property "Array" "prototype" "concat" "apply")
   first-array more-arrays))

(define-function %reverse! (array)
  ((js:get-property array "reverse")))

(define-function %reverse (array)
  ((js:get-property (%copy-sequence array) "reverse")))

(define-function %sort! (array #key (test <))
  ((js:get-property array "sort") test))

(define-function %sort (array #key (test <))
  (%sort! (%copy-sequence array) test: test))

(define-function %element (array key #key default)
  (or (js:get-property array key) default))

(define-function (setter %element) (array key new-value)
  (js:set (js:get-property array key) new-value))

(define-function %key-sequence (array)
  (js:property-sequence array))

(define-function %size (array)
  (js:length array))

(define-function %empty? (array)
  (js:== (%size array) 0))

(define-function %do (function array)
  (js:for-each function array))

(define-function %map (function array)
  ((js:get-property array "map") function))

(define-function %reduce1 (function array)
  ((js:get-property array "reduce") function))

(define-function %reduce (function initial-value array)
  (%reduce1 function
	    (%concatenate (%array initial-value)
			  array)))

(define-function %every? (function array)
  ((js:get-property array "every")
   (method (element)
     (%true? (function element)))))

(define-function %choose (function array)
  ((js:get-property array "filter")
   (method (element)
     (%true? (function element)))))

(define %not-found (js:make-object))

(define-function %find-key (array predicate #key (skip 0) failure)
  (bind ((keys (%choose (method (index)
			  (%true? (predicate (%element array index))))
			(%key-sequence array))))
    (or (%element keys skip) failure)))

(define-function %any? (function array)
  (block (return)
    (js:for-in (i array)
      (js:var result (function (%element array i)))
      (when result
	(return result)))
    #f))

(define-function %member? (value array)
  (%true? (%any? (method (other-value)
		   (%== value other-value))
		 array)))

(define-function %replace-subsequence (target-array insert-array
				       #key (start 0) (end (%size target-array)))
  (%concatenate (%copy-sequence target-array end: start)
		insert-array
		(%copy-sequence target-array start: end)))

(define-function %first (array)
  (%element array 0))

(define-function %second (array)
  (%element array 1))

(define-function %third (array)
  (%element array 2))

(define-function %last (array)
  (%element array (js:- (%size array) 1)))

(define-function %rest (array)
  (js:slice array 1))

(define-function %but-last (array)
  (js:slice array 0 -1))

(define-function %choose-by (predicate test-array value-array)
  (bind ((test-keys (%choose (method (test-key)
			       (predicate (%element test-array test-key)))
			     (%key-sequence test-array))))
    (%map (%curry %element value-array) test-keys)))

;;;; string primitives

;; * as-uppercase! and as-lowercase! impossible,
;;   as strings in JavaScript are immutable

(define-function %as-uppercase (string)
  ((js:get-property string "toUpperCase")))

(define-function %as-lowercase (string)
  ((js:get-property string "toLowerCase")))

;;;; functional primitives

(define-function %apply (function #rest arguments)
  (js:set (js:get-property %apply "%skip") #t)
  ((js:get-property function "apply") js:null
   (if (js:> (%size arguments) 1)
       (%concatenate (%but-last arguments)
		     (%last arguments))
       (%first arguments))))

(define-function %curry (function #rest curried-args)
  (method (#rest args)
    (%apply function (%concatenate curried-args args))))

(define-function %rcurry (function #rest curried-args)
  (method (#rest args)
    (%apply function (%concatenate args curried-args))))

(define-function %always (value)
  (method (#rest args)
    value))

  (js:set (js:get-property source-type "%internal-type")
	  target-type))

;; TODO: (do %map-types (...
(%map-type <array> (js:identifier "Array"))
(%map-type <object> (js:identifier "Object"))
(%map-type <string> (js:identifier "String"))
(%map-type <number> (js:identifier "Number"))
(%map-type <boolean> (js:identifier "Boolean"))

